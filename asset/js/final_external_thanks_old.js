(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hls = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    function EventEmitter() {
      this._events = this._events || {};
      this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;
    
    // Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;
    
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;
    
    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;
    
    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (!isNumber(n) || n < 0 || isNaN(n))
        throw TypeError('n must be a positive number');
      this._maxListeners = n;
      return this;
    };
    
    EventEmitter.prototype.emit = function(type) {
      var er, handler, len, args, i, listeners;
    
      if (!this._events)
        this._events = {};
    
      // If there is no 'error' event listener then throw.
      if (type === 'error') {
        if (!this._events.error ||
            (isObject(this._events.error) && !this._events.error.length)) {
          er = arguments[1];
          if (er instanceof Error) {
            throw er; // Unhandled 'error' event
          } else {
            // At least give some kind of context to the user
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
            err.context = er;
            throw err;
          }
        }
      }
    
      handler = this._events[type];
    
      if (isUndefined(handler))
        return false;
    
      if (isFunction(handler)) {
        switch (arguments.length) {
          // fast cases
          case 1:
            handler.call(this);
            break;
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          // slower
          default:
            args = Array.prototype.slice.call(arguments, 1);
            handler.apply(this, args);
        }
      } else if (isObject(handler)) {
        args = Array.prototype.slice.call(arguments, 1);
        listeners = handler.slice();
        len = listeners.length;
        for (i = 0; i < len; i++)
          listeners[i].apply(this, args);
      }
    
      return true;
    };
    
    EventEmitter.prototype.addListener = function(type, listener) {
      var m;
    
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
    
      if (!this._events)
        this._events = {};
    
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (this._events.newListener)
        this.emit('newListener', type,
                  isFunction(listener.listener) ?
                  listener.listener : listener);
    
      if (!this._events[type])
        // Optimize the case of one listener. Don't need the extra array object.
        this._events[type] = listener;
      else if (isObject(this._events[type]))
        // If we've already got an array, just append.
        this._events[type].push(listener);
      else
        // Adding the second element, need to change to array.
        this._events[type] = [this._events[type], listener];
    
      // Check for listener leak
      if (isObject(this._events[type]) && !this._events[type].warned) {
        if (!isUndefined(this._maxListeners)) {
          m = this._maxListeners;
        } else {
          m = EventEmitter.defaultMaxListeners;
        }
    
        if (m && m > 0 && this._events[type].length > m) {
          this._events[type].warned = true;
          console.error('(node) warning: possible EventEmitter memory ' +
                        'leak detected. %d listeners added. ' +
                        'Use emitter.setMaxListeners() to increase limit.',
                        this._events[type].length);
          if (typeof console.trace === 'function') {
            // not supported in IE 10
            console.trace();
          }
        }
      }
    
      return this;
    };
    
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    
    EventEmitter.prototype.once = function(type, listener) {
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
    
      var fired = false;
    
      function g() {
        this.removeListener(type, g);
    
        if (!fired) {
          fired = true;
          listener.apply(this, arguments);
        }
      }
    
      g.listener = listener;
      this.on(type, g);
    
      return this;
    };
    
    // emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener = function(type, listener) {
      var list, position, length, i;
    
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
    
      if (!this._events || !this._events[type])
        return this;
    
      list = this._events[type];
      length = list.length;
      position = -1;
    
      if (list === listener ||
          (isFunction(list.listener) && list.listener === listener)) {
        delete this._events[type];
        if (this._events.removeListener)
          this.emit('removeListener', type, listener);
    
      } else if (isObject(list)) {
        for (i = length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            position = i;
            break;
          }
        }
    
        if (position < 0)
          return this;
    
        if (list.length === 1) {
          list.length = 0;
          delete this._events[type];
        } else {
          list.splice(position, 1);
        }
    
        if (this._events.removeListener)
          this.emit('removeListener', type, listener);
      }
    
      return this;
    };
    
    EventEmitter.prototype.removeAllListeners = function(type) {
      var key, listeners;
    
      if (!this._events)
        return this;
    
      // not listening for removeListener, no need to emit
      if (!this._events.removeListener) {
        if (arguments.length === 0)
          this._events = {};
        else if (this._events[type])
          delete this._events[type];
        return this;
      }
    
      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        for (key in this._events) {
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = {};
        return this;
      }
    
      listeners = this._events[type];
    
      if (isFunction(listeners)) {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        while (listeners.length)
          this.removeListener(type, listeners[listeners.length - 1]);
      }
      delete this._events[type];
    
      return this;
    };
    
    EventEmitter.prototype.listeners = function(type) {
      var ret;
      if (!this._events || !this._events[type])
        ret = [];
      else if (isFunction(this._events[type]))
        ret = [this._events[type]];
      else
        ret = this._events[type].slice();
      return ret;
    };
    
    EventEmitter.prototype.listenerCount = function(type) {
      if (this._events) {
        var evlistener = this._events[type];
    
        if (isFunction(evlistener))
          return 1;
        else if (evlistener)
          return evlistener.length;
      }
      return 0;
    };
    
    EventEmitter.listenerCount = function(emitter, type) {
      return emitter.listenerCount(type);
    };
    
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    
    function isUndefined(arg) {
      return arg === void 0;
    }
    
    },{}],2:[function(_dereq_,module,exports){
    // see https://tools.ietf.org/html/rfc1808
    
    /* jshint ignore:start */
    (function(root) { 
    /* jshint ignore:end */
    
      var URL_REGEX = /^((?:[^\/;?#]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/;
      var FIRST_SEGMENT_REGEX = /^([^\/;?#]*)(.*)$/;
      var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
      var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g;
    
      var URLToolkit = { // jshint ignore:line
        // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
        // E.g
        // With opts.alwaysNormalize = false (default, spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
        // With opts.alwaysNormalize = true (default, not spec compliant)
        // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
        buildAbsoluteURL: function(baseURL, relativeURL, opts) {
          opts = opts || {};
          // remove any remaining space and CRLF
          baseURL = baseURL.trim();
          relativeURL = relativeURL.trim();
          if (!relativeURL) {
            // 2a) If the embedded URL is entirely empty, it inherits the
            // entire base URL (i.e., is set equal to the base URL)
            // and we are done.
            if (!opts.alwaysNormalize) {
              return baseURL;
            }
            var basePartsForNormalise = this.parseURL(baseURL);
            if (!baseParts) {
              throw new Error('Error trying to parse base URL.');
            }
            basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
            return URLToolkit.buildURLFromParts(basePartsForNormalise);
          }
          var relativeParts = this.parseURL(relativeURL);
          if (!relativeParts) {
            throw new Error('Error trying to parse relative URL.');
          }
          if (relativeParts.scheme) {
            // 2b) If the embedded URL starts with a scheme name, it is
            // interpreted as an absolute URL and we are done.
            if (!opts.alwaysNormalize) {
              return relativeURL;
            }
            relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
            return URLToolkit.buildURLFromParts(relativeParts);
          }
          var baseParts = this.parseURL(baseURL);
          if (!baseParts) {
            throw new Error('Error trying to parse base URL.');
          }
          if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
            // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc
            // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
            var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
            baseParts.netLoc = pathParts[1];
            baseParts.path = pathParts[2];
          }
          if (baseParts.netLoc && !baseParts.path) {
            baseParts.path = '/';
          }
          var builtParts = {
            // 2c) Otherwise, the embedded URL inherits the scheme of
            // the base URL.
            scheme: baseParts.scheme,
            netLoc: relativeParts.netLoc,
            path: null,
            params: relativeParts.params,
            query: relativeParts.query,
            fragment: relativeParts.fragment
          };
          if (!relativeParts.netLoc) {
            // 3) If the embedded URL's <net_loc> is non-empty, we skip to
            // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
            // (if any) of the base URL.
            builtParts.netLoc = baseParts.netLoc;
            // 4) If the embedded URL path is preceded by a slash "/", the
            // path is not relative and we skip to Step 7.
            if (relativeParts.path[0] !== '/') {
              if (!relativeParts.path) {
                // 5) If the embedded URL path is empty (and not preceded by a
                // slash), then the embedded URL inherits the base URL path
                builtParts.path = baseParts.path;
                // 5a) if the embedded URL's <params> is non-empty, we skip to
                // step 7; otherwise, it inherits the <params> of the base
                // URL (if any) and
                if (!relativeParts.params) {
                  builtParts.params = baseParts.params;
                  // 5b) if the embedded URL's <query> is non-empty, we skip to
                  // step 7; otherwise, it inherits the <query> of the base
                  // URL (if any) and we skip to step 7.
                  if (!relativeParts.query) {
                    builtParts.query = baseParts.query;
                  }
                }
              } else {
                // 6) The last segment of the base URL's path (anything
                // following the rightmost slash "/", or the entire path if no
                // slash is present) is removed and the embedded URL's path is
                // appended in its place.
                var baseURLPath = baseParts.path;
                var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;
                builtParts.path = URLToolkit.normalizePath(newPath);
              }
            }
          }
          if (builtParts.path === null) {
            builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
          }
          return URLToolkit.buildURLFromParts(builtParts);
        },
        parseURL: function(url) {
          var parts = URL_REGEX.exec(url);
          if (!parts) {
            return null;
          }
          return {
            scheme: parts[1] || '',
            netLoc: parts[2] || '',
            path: parts[3] || '',
            params: parts[4] || '',
            query: parts[5] || '',
            fragment: parts[6] || ''
          };
        },
        normalizePath: function(path) {
          // The following operations are
          // then applied, in order, to the new path:
          // 6a) All occurrences of "./", where "." is a complete path
          // segment, are removed.
          // 6b) If the path ends with "." as a complete path segment,
          // that "." is removed.
          path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
          // 6c) All occurrences of "<segment>/../", where <segment> is a
          // complete path segment not equal to "..", are removed.
          // Removal of these path segments is performed iteratively,
          // removing the leftmost matching pattern on each iteration,
          // until no matching pattern remains.
          // 6d) If the path ends with "<segment>/..", where <segment> is a
          // complete path segment not equal to "..", that
          // "<segment>/.." is removed.
          while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {} // jshint ignore:line
          return path.split('').reverse().join('');
        },
        buildURLFromParts: function(parts) {
          return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
        }
      };
    
    /* jshint ignore:start */
      if(typeof exports === 'object' && typeof module === 'object')
        module.exports = URLToolkit;
      else if(typeof define === 'function' && define.amd)
        define([], function() { return URLToolkit; });
      else if(typeof exports === 'object')
        exports["URLToolkit"] = URLToolkit;
      else
        root["URLToolkit"] = URLToolkit;
    })(this);
    /* jshint ignore:end */
    
    },{}],3:[function(_dereq_,module,exports){
    var bundleFn = arguments[3];
    var sources = arguments[4];
    var cache = arguments[5];
    
    var stringify = JSON.stringify;
    
    module.exports = function (fn, options) {
        var wkey;
        var cacheKeys = Object.keys(cache);
    
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            var exp = cache[key].exports;
            // Using babel as a transpiler to use esmodule, the export will always
            // be an object with the default export as a property of it. To ensure
            // the existing api and babel esmodule exports are both supported we
            // check for both
            if (exp === fn || exp && exp.default === fn) {
                wkey = key;
                break;
            }
        }
    
        if (!wkey) {
            wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
            var wcache = {};
            for (var i = 0, l = cacheKeys.length; i < l; i++) {
                var key = cacheKeys[i];
                wcache[key] = key;
            }
            sources[wkey] = [
                Function(['require','module','exports'], '(' + fn + ')(self)'),
                wcache
            ];
        }
        var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
    
        var scache = {}; scache[wkey] = wkey;
        sources[skey] = [
            Function(['require'], (
                // try to call default if defined to also support babel esmodule
                // exports
                'var f = require(' + stringify(wkey) + ');' +
                '(f.default ? f.default : f)(self);'
            )),
            scache
        ];
    
        var workerSources = {};
        resolveSources(skey);
    
        function resolveSources(key) {
            workerSources[key] = true;
    
            for (var depPath in sources[key][1]) {
                var depKey = sources[key][1][depPath];
                if (!workerSources[depKey]) {
                    resolveSources(depKey);
                }
            }
        }
    
        var src = '(' + bundleFn + ')({'
            + Object.keys(workerSources).map(function (key) {
                return stringify(key) + ':['
                    + sources[key][0]
                    + ',' + stringify(sources[key][1]) + ']'
                ;
            }).join(',')
            + '},{},[' + stringify(skey) + '])'
        ;
    
        var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
    
        var blob = new Blob([src], { type: 'text/javascript' });
        if (options && options.bare) { return blob; }
        var workerUrl = URL.createObjectURL(blob);
        var worker = new Worker(workerUrl);
        worker.objectURL = workerUrl;
        return worker;
    };
    
    },{}],4:[function(_dereq_,module,exports){
    /**
     * HLS config
     */
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
          value: true
    });
    exports.hlsDefaultConfig = undefined;
    
    var _abrController = _dereq_(5);
    
    var _abrController2 = _interopRequireDefault(_abrController);
    
    var _bufferController = _dereq_(8);
    
    var _bufferController2 = _interopRequireDefault(_bufferController);
    
    var _capLevelController = _dereq_(9);
    
    var _capLevelController2 = _interopRequireDefault(_capLevelController);
    
    var _fpsController = _dereq_(10);
    
    var _fpsController2 = _interopRequireDefault(_fpsController);
    
    var _xhrLoader = _dereq_(56);
    
    var _xhrLoader2 = _interopRequireDefault(_xhrLoader);
    
    var _audioTrackController = _dereq_(7);
    
    var _audioTrackController2 = _interopRequireDefault(_audioTrackController);
    
    var _audioStreamController = _dereq_(6);
    
    var _audioStreamController2 = _interopRequireDefault(_audioStreamController);
    
    var _cues = _dereq_(48);
    
    var _cues2 = _interopRequireDefault(_cues);
    
    var _timelineController = _dereq_(16);
    
    var _timelineController2 = _interopRequireDefault(_timelineController);
    
    var _subtitleTrackController = _dereq_(15);
    
    var _subtitleTrackController2 = _interopRequireDefault(_subtitleTrackController);
    
    var _subtitleStreamController = _dereq_(14);
    
    var _subtitleStreamController2 = _interopRequireDefault(_subtitleStreamController);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    //#endif
    
    //#endif
    
    //#if subtitle
    
    //import FetchLoader from './utils/fetch-loader';
    //#if altaudio
    var hlsDefaultConfig = exports.hlsDefaultConfig = {
          autoStartLoad: true, // used by stream-controller
          startPosition: -1, // used by stream-controller
          defaultAudioCodec: undefined, // used by stream-controller
          debug: false, // used by logger
          capLevelOnFPSDrop: false, // used by fps-controller
          capLevelToPlayerSize: false, // used by cap-level-controller
          initialLiveManifestSize: 1, // used by stream-controller
          maxBufferLength: 30, // used by stream-controller
          maxBufferSize: 60 * 1000 * 1000, // used by stream-controller
          maxBufferHole: 0.5, // used by stream-controller
          maxSeekHole: 2, // used by stream-controller
          lowBufferWatchdogPeriod: 0.5, // used by stream-controller
          highBufferWatchdogPeriod: 3, // used by stream-controller
          nudgeOffset: 0.1, // used by stream-controller
          nudgeMaxRetry: 3, // used by stream-controller
          maxFragLookUpTolerance: 0.2, // used by stream-controller
          liveSyncDurationCount: 3, // used by stream-controller
          liveMaxLatencyDurationCount: Infinity, // used by stream-controller
          liveSyncDuration: undefined, // used by stream-controller
          liveMaxLatencyDuration: undefined, // used by stream-controller
          maxMaxBufferLength: 600, // used by stream-controller
          enableWorker: true, // used by demuxer
          enableSoftwareAES: true, // used by decrypter
          manifestLoadingTimeOut: 10000, // used by playlist-loader
          manifestLoadingMaxRetry: 1, // used by playlist-loader
          manifestLoadingRetryDelay: 1000, // used by playlist-loader
          manifestLoadingMaxRetryTimeout: 64000, // used by playlist-loader
          startLevel: undefined, // used by level-controller
          levelLoadingTimeOut: 10000, // used by playlist-loader
          levelLoadingMaxRetry: 4, // used by playlist-loader
          levelLoadingRetryDelay: 1000, // used by playlist-loader
          levelLoadingMaxRetryTimeout: 64000, // used by playlist-loader
          fragLoadingTimeOut: 20000, // used by fragment-loader
          fragLoadingMaxRetry: 6, // used by fragment-loader
          fragLoadingRetryDelay: 1000, // used by fragment-loader
          fragLoadingMaxRetryTimeout: 64000, // used by fragment-loader
          fragLoadingLoopThreshold: 3, // used by stream-controller
          startFragPrefetch: false, // used by stream-controller
          fpsDroppedMonitoringPeriod: 5000, // used by fps-controller
          fpsDroppedMonitoringThreshold: 0.2, // used by fps-controller
          appendErrorMaxRetry: 3, // used by buffer-controller
          loader: _xhrLoader2.default,
          //loader: FetchLoader,
          fLoader: undefined,
          pLoader: undefined,
          xhrSetup: undefined,
          fetchSetup: undefined,
          abrController: _abrController2.default,
          bufferController: _bufferController2.default,
          capLevelController: _capLevelController2.default,
          fpsController: _fpsController2.default,
          //#if altaudio
          audioStreamController: _audioStreamController2.default,
          audioTrackController: _audioTrackController2.default,
          //#endif
          //#if subtitle
          subtitleStreamController: _subtitleStreamController2.default,
          subtitleTrackController: _subtitleTrackController2.default,
          timelineController: _timelineController2.default,
          cueHandler: _cues2.default,
          enableCEA708Captions: true, // used by timeline-controller
          enableWebVTT: true, // used by timeline-controller
          captionsTextTrack1Label: 'English', // used by timeline-controller
          captionsTextTrack1LanguageCode: 'en', // used by timeline-controller
          captionsTextTrack2Label: 'Spanish', // used by timeline-controller
          captionsTextTrack2LanguageCode: 'es', // used by timeline-controller
          //#endif
          stretchShortVideoTrack: false, // used by mp4-remuxer
          forceKeyFrameOnDiscontinuity: true, // used by ts-demuxer
          abrEwmaFastLive: 3, // used by abr-controller
          abrEwmaSlowLive: 9, // used by abr-controller
          abrEwmaFastVoD: 3, // used by abr-controller
          abrEwmaSlowVoD: 9, // used by abr-controller
          abrEwmaDefaultEstimate: 5e5, // 500 kbps  // used by abr-controller
          abrBandWidthFactor: 0.95, // used by abr-controller
          abrBandWidthUpFactor: 0.7, // used by abr-controller
          abrMaxWithRealBitrate: false, // used by abr-controller
          maxStarvationDelay: 4, // used by abr-controller
          maxLoadingDelay: 4, // used by abr-controller
          minAutoBitrate: 0 // used by hls
    };
    
    },{"10":10,"14":14,"15":15,"16":16,"48":48,"5":5,"56":56,"6":6,"7":7,"8":8,"9":9}],5:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _bufferHelper = _dereq_(35);
    
    var _bufferHelper2 = _interopRequireDefault(_bufferHelper);
    
    var _errors = _dereq_(31);
    
    var _logger = _dereq_(51);
    
    var _ewmaBandwidthEstimator = _dereq_(49);
    
    var _ewmaBandwidthEstimator2 = _interopRequireDefault(_ewmaBandwidthEstimator);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * simple ABR Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *  - compute next level based on last fragment bw heuristics
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    *  - implement an abandon rules triggered if we have less than 2 frag buffered and if computed bw shows that we risk buffer stalling
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    */
    
    var AbrController = function (_EventHandler) {
      _inherits(AbrController, _EventHandler);
    
      function AbrController(hls) {
        _classCallCheck(this, AbrController);
    
        var _this = _possibleConstructorReturn(this, (AbrController.__proto__ || Object.getPrototypeOf(AbrController)).call(this, hls, _events2.default.FRAG_LOADING, _events2.default.FRAG_LOADED, _events2.default.FRAG_BUFFERED, _events2.default.ERROR));
    
        _this.lastLoadedFragLevel = 0;
        _this._nextAutoLevel = -1;
        _this.hls = hls;
        _this.onCheck = _this._abandonRulesCheck.bind(_this);
        return _this;
      }
    
      _createClass(AbrController, [{
        key: 'destroy',
        value: function destroy() {
          this.clearTimer();
          _eventHandler2.default.prototype.destroy.call(this);
        }
      }, {
        key: 'onFragLoading',
        value: function onFragLoading(data) {
          var frag = data.frag;
          if (frag.type === 'main') {
            if (!this.timer) {
              this.timer = setInterval(this.onCheck, 100);
            }
            // lazy init of bw Estimator, rationale is that we use different params for Live/VoD
            // so we need to wait for stream manifest / playlist type to instantiate it.
            if (!this._bwEstimator) {
              var hls = this.hls,
                  level = data.frag.level,
                  isLive = hls.levels[level].details.live,
                  config = hls.config,
                  ewmaFast = void 0,
                  ewmaSlow = void 0;
    
              if (isLive) {
                ewmaFast = config.abrEwmaFastLive;
                ewmaSlow = config.abrEwmaSlowLive;
              } else {
                ewmaFast = config.abrEwmaFastVoD;
                ewmaSlow = config.abrEwmaSlowVoD;
              }
              this._bwEstimator = new _ewmaBandwidthEstimator2.default(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
            }
            this.fragCurrent = frag;
          }
        }
      }, {
        key: '_abandonRulesCheck',
        value: function _abandonRulesCheck() {
          /*
            monitor fragment retrieval time...
            we compute expected time of arrival of the complete fragment.
            we compare it to expected time of buffer starvation
          */
          var hls = this.hls,
              v = hls.media,
              frag = this.fragCurrent,
              loader = frag.loader,
              minAutoLevel = hls.minAutoLevel;
    
          // if loader has been destroyed or loading has been aborted, stop timer and return
          if (!loader || loader.stats && loader.stats.aborted) {
            _logger.logger.warn('frag loader destroy or aborted, disarm abandonRules');
            this.clearTimer();
            return;
          }
          var stats = loader.stats;
          /* only monitor frag retrieval time if
          (video not paused OR first fragment being loaded(ready state === HAVE_NOTHING = 0)) AND autoswitching enabled AND not lowest level (=> means that we have several levels) */
          if (v && (!v.paused && v.playbackRate !== 0 || !v.readyState) && frag.autoLevel && frag.level) {
            var requestDelay = performance.now() - stats.trequest,
                playbackRate = Math.abs(v.playbackRate);
            // monitor fragment load progress after half of expected fragment duration,to stabilize bitrate
            if (requestDelay > 500 * frag.duration / playbackRate) {
              var levels = hls.levels,
                  loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1000 / requestDelay),
                  // byte/s; at least 1 byte/s to avoid division by zero
              // compute expected fragment length using frag duration and level bitrate. also ensure that expected len is gte than already loaded size
              level = levels[frag.level],
                  levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate,
                  expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8)),
                  pos = v.currentTime,
                  fragLoadedDelay = (expectedLen - stats.loaded) / loadRate,
                  bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
              // consider emergency switch down only if we have less than 2 frag buffered AND
              // time to finish loading current fragment is bigger than buffer starvation delay
              // ie if we risk buffer starvation if bw does not increase quickly
              if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
                var fragLevelNextLoadedDelay = void 0,
                    nextLoadLevel = void 0;
                // lets iterate through lower level and try to find the biggest one that could avoid rebuffering
                // we start from current level - 1 and we step down , until we find a matching level
                for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
                  // compute time to load next fragment at lower level
                  // 0.8 : consider only 80% of current bw to be conservative
                  // 8 = bits per byte (bps/Bps)
                  var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
                  fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
                  if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                    // we found a lower level that be rebuffering free with current estimated bw !
                    break;
                  }
                }
                // only emergency switch down if it takes less time to load new fragment at lowest level instead
                // of finishing loading current one ...
                if (fragLevelNextLoadedDelay < fragLoadedDelay) {
                  _logger.logger.warn('loading too slow, abort fragment loading and switch to level ' + nextLoadLevel + ':fragLoadedDelay[' + nextLoadLevel + ']<fragLoadedDelay[' + (frag.level - 1) + '];bufferStarvationDelay:' + fragLevelNextLoadedDelay.toFixed(1) + '<' + fragLoadedDelay.toFixed(1) + ':' + bufferStarvationDelay.toFixed(1));
                  // force next load level in auto mode
                  hls.nextLoadLevel = nextLoadLevel;
                  // update bw estimate for this fragment before cancelling load (this will help reducing the bw)
                  this._bwEstimator.sample(requestDelay, stats.loaded);
                  //abort fragment loading
                  loader.abort();
                  // stop abandon rules timer
                  this.clearTimer();
                  hls.trigger(_events2.default.FRAG_LOAD_EMERGENCY_ABORTED, { frag: frag, stats: stats });
                }
              }
            }
          }
        }
      }, {
        key: 'onFragLoaded',
        value: function onFragLoaded(data) {
          var frag = data.frag;
          if (frag.type === 'main' && !isNaN(frag.sn)) {
            // stop monitoring bw once frag loaded
            this.clearTimer();
            // store level id after successful fragment load
            this.lastLoadedFragLevel = frag.level;
            // reset forced auto level value so that next level will be selected
            this._nextAutoLevel = -1;
    
            // compute level average bitrate
            if (this.hls.config.abrMaxWithRealBitrate) {
              var level = this.hls.levels[frag.level];
              var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
              var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
              level.loaded = { bytes: loadedBytes, duration: loadedDuration };
              level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
            }
            // if fragment has been loaded to perform a bitrate test,
            if (data.frag.bitrateTest) {
              var stats = data.stats;
              stats.tparsed = stats.tbuffered = stats.tload;
              this.onFragBuffered(data);
            }
          }
        }
      }, {
        key: 'onFragBuffered',
        value: function onFragBuffered(data) {
          var stats = data.stats,
              frag = data.frag;
          // only update stats on first frag buffering
          // if same frag is loaded multiple times, it might be in browser cache, and loaded quickly
          // and leading to wrong bw estimation
          // on bitrate test, also only update stats once (if tload = tbuffered == on FRAG_LOADED)
          if (stats.aborted !== true && frag.loadCounter === 1 && frag.type === 'main' && !isNaN(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
            // use tparsed-trequest instead of tbuffered-trequest to compute fragLoadingProcessing; rationale is that  buffer appending only happens once media is attached
            // in case we use config.startFragPrefetch while media is not attached yet, fragment might be parsed while media not attached yet, but it will only be buffered on media attached
            // as a consequence it could happen really late in the process. meaning that appending duration might appears huge ... leading to underestimated throughput estimation
            var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
            _logger.logger.log('latency/loading/parsing/append/kbps:' + Math.round(stats.tfirst - stats.trequest) + '/' + Math.round(stats.tload - stats.tfirst) + '/' + Math.round(stats.tparsed - stats.tload) + '/' + Math.round(stats.tbuffered - stats.tparsed) + '/' + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
            this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
            stats.bwEstimate = this._bwEstimator.getEstimate();
            // if fragment has been loaded to perform a bitrate test, (hls.startLevel = -1), store bitrate test delay duration
            if (frag.bitrateTest) {
              this.bitrateTestDelay = fragLoadingProcessingMs / 1000;
            } else {
              this.bitrateTestDelay = 0;
            }
          }
        }
      }, {
        key: 'onError',
        value: function onError(data) {
          // stop timer in case of frag loading error
          switch (data.details) {
            case _errors.ErrorDetails.FRAG_LOAD_ERROR:
            case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
              this.clearTimer();
              break;
            default:
              break;
          }
        }
      }, {
        key: 'clearTimer',
        value: function clearTimer() {
          if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
          }
        }
    
        // return next auto level
    
      }, {
        key: '_findBestLevel',
        value: function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
          for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
            var levelInfo = levels[i],
                levelDetails = levelInfo.details,
                avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration,
                live = levelDetails ? levelDetails.live : false,
                adjustedbw = void 0;
            // follow algorithm captured from stagefright :
            // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp
            // Pick the highest bandwidth stream below or equal to estimated bandwidth.
            // consider only 80% of the available bandwidth, but if we are switching up,
            // be even more conservative (70%) to avoid overestimating and immediately
            // switching back.
            if (i <= currentLevel) {
              adjustedbw = bwFactor * currentBw;
            } else {
              adjustedbw = bwUpFactor * currentBw;
            }
            var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate,
                fetchDuration = bitrate * avgDuration / adjustedbw;
    
            _logger.logger.trace('level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ' + i + '/' + Math.round(adjustedbw) + '/' + bitrate + '/' + avgDuration + '/' + maxFetchDuration + '/' + fetchDuration);
            // if adjusted bw is greater than level bitrate AND
            if (adjustedbw > bitrate && (
            // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
            // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
            !fetchDuration || live || fetchDuration < maxFetchDuration)) {
              // as we are looping from highest to lowest, this will return the best achievable quality level
    
              return i;
            }
          }
          // not enough time budget even with quality level 0 ... rebuffering might happen
          return -1;
        }
      }, {
        key: 'nextAutoLevel',
        get: function get() {
          var forcedAutoLevel = this._nextAutoLevel;
          var bwEstimator = this._bwEstimator;
          // in case next auto level has been forced, and bw not available or not reliable, return forced value
          if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
            return forcedAutoLevel;
          }
          // compute next level using ABR logic
          var nextABRAutoLevel = this._nextABRAutoLevel;
          // if forced auto level has been defined, use it to cap ABR computed quality level
          if (forcedAutoLevel !== -1) {
            nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
          }
          return nextABRAutoLevel;
        },
        set: function set(nextLevel) {
          this._nextAutoLevel = nextLevel;
        }
      }, {
        key: '_nextABRAutoLevel',
        get: function get() {
          var hls = this.hls,
              maxAutoLevel = hls.maxAutoLevel,
              levels = hls.levels,
              config = hls.config,
              minAutoLevel = hls.minAutoLevel;
          var v = hls.media,
              currentLevel = this.lastLoadedFragLevel,
              currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0,
              pos = v ? v.currentTime : 0,
    
          // playbackRate is the absolute value of the playback rate; if v.playbackRate is 0, we use 1 to load as
          // if we're playing back at the normal rate.
          playbackRate = v && v.playbackRate !== 0 ? Math.abs(v.playbackRate) : 1.0,
              avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate,
    
          // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.
          bufferStarvationDelay = (_bufferHelper2.default.bufferInfo(v, pos, config.maxBufferHole).end - pos) / playbackRate;
    
          // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all
          var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
          if (bestLevel >= 0) {
            return bestLevel;
          } else {
            _logger.logger.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering');
            // not possible to get rid of rebuffering ... let's try to find level that will guarantee less than maxStarvationDelay of rebuffering
            // if no matching level found, logic will return 0
            var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay,
                bwFactor = config.abrBandWidthFactor,
                bwUpFactor = config.abrBandWidthUpFactor;
            if (bufferStarvationDelay === 0) {
              // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test
              var bitrateTestDelay = this.bitrateTestDelay;
              if (bitrateTestDelay) {
                // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value
                // max video loading delay used in  automatic start level selection :
                // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +
                // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )
                // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration
                var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
                maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
                _logger.logger.trace('bitrate test took ' + Math.round(1000 * bitrateTestDelay) + 'ms, set first fragment max fetchDuration to ' + Math.round(1000 * maxStarvationDelay) + ' ms');
                // don't use conservative factor on bitrate test
                bwFactor = bwUpFactor = 1;
              }
            }
            bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
            return Math.max(bestLevel, 0);
          }
        }
      }]);
    
      return AbrController;
    }(_eventHandler2.default);
    
    exports.default = AbrController;
    
    },{"31":31,"32":32,"33":33,"35":35,"49":49,"51":51}],6:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _binarySearch = _dereq_(46);
    
    var _binarySearch2 = _interopRequireDefault(_binarySearch);
    
    var _bufferHelper = _dereq_(35);
    
    var _bufferHelper2 = _interopRequireDefault(_bufferHelper);
    
    var _demuxer = _dereq_(25);
    
    var _demuxer2 = _interopRequireDefault(_demuxer);
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _levelHelper = _dereq_(36);
    
    var _levelHelper2 = _interopRequireDefault(_levelHelper);
    
    var _timeRanges = _dereq_(52);
    
    var _timeRanges2 = _interopRequireDefault(_timeRanges);
    
    var _errors = _dereq_(31);
    
    var _logger = _dereq_(51);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * Audio Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    var State = {
      STOPPED: 'STOPPED',
      STARTING: 'STARTING',
      IDLE: 'IDLE',
      PAUSED: 'PAUSED',
      KEY_LOADING: 'KEY_LOADING',
      FRAG_LOADING: 'FRAG_LOADING',
      FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
      WAITING_TRACK: 'WAITING_TRACK',
      PARSING: 'PARSING',
      PARSED: 'PARSED',
      BUFFER_FLUSHING: 'BUFFER_FLUSHING',
      ENDED: 'ENDED',
      ERROR: 'ERROR',
      WAITING_INIT_PTS: 'WAITING_INIT_PTS'
    };
    
    var AudioStreamController = function (_EventHandler) {
      _inherits(AudioStreamController, _EventHandler);
    
      function AudioStreamController(hls) {
        _classCallCheck(this, AudioStreamController);
    
        var _this = _possibleConstructorReturn(this, (AudioStreamController.__proto__ || Object.getPrototypeOf(AudioStreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.AUDIO_TRACKS_UPDATED, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED, _events2.default.INIT_PTS_FOUND));
    
        _this.config = hls.config;
        _this.audioCodecSwap = false;
        _this.ticks = 0;
        _this._state = State.STOPPED;
        _this.ontick = _this.tick.bind(_this);
        _this.initPTS = [];
        _this.waitingFragment = null;
        return _this;
      }
    
      _createClass(AudioStreamController, [{
        key: 'destroy',
        value: function destroy() {
          this.stopLoad();
          if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
          }
          _eventHandler2.default.prototype.destroy.call(this);
          this.state = State.STOPPED;
        }
    
        //Signal that video PTS was found
    
      }, {
        key: 'onInitPtsFound',
        value: function onInitPtsFound(data) {
          var demuxerId = data.id,
              cc = data.frag.cc,
              initPTS = data.initPTS;
          if (demuxerId === 'main') {
            //Always update the new INIT PTS
            //Can change due level switch
            this.initPTS[cc] = initPTS;
            _logger.logger.log('InitPTS for cc:' + cc + ' found from video track:' + initPTS);
    
            //If we are waiting we need to demux/remux the waiting frag
            //With the new initPTS
            if (this.state === State.WAITING_INIT_PTS) {
              _logger.logger.log('sending pending audio frag to demuxer');
              this.state = State.FRAG_LOADING;
              //We have audio frag waiting or video pts
              //Let process it
              this.onFragLoaded(this.waitingFragment);
              //Lets clean the waiting frag
              this.waitingFragment = null;
            }
          }
        }
      }, {
        key: 'startLoad',
        value: function startLoad(startPosition) {
          if (this.tracks) {
            var lastCurrentTime = this.lastCurrentTime;
            this.stopLoad();
            if (!this.timer) {
              this.timer = setInterval(this.ontick, 100);
            }
            this.fragLoadError = 0;
            if (lastCurrentTime > 0 && startPosition === -1) {
              _logger.logger.log('audio:override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
              this.state = State.IDLE;
            } else {
              this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
              this.state = State.STARTING;
            }
            this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
            this.tick();
          } else {
            this.startPosition = startPosition;
            this.state = State.STOPPED;
          }
        }
      }, {
        key: 'stopLoad',
        value: function stopLoad() {
          var frag = this.fragCurrent;
          if (frag) {
            if (frag.loader) {
              frag.loader.abort();
            }
            this.fragCurrent = null;
          }
          this.fragPrevious = null;
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          this.state = State.STOPPED;
        }
      }, {
        key: 'tick',
        value: function tick() {
          this.ticks++;
          if (this.ticks === 1) {
            this.doTick();
            if (this.ticks > 1) {
              setTimeout(this.tick, 1);
            }
            this.ticks = 0;
          }
        }
      }, {
        key: 'doTick',
        value: function doTick() {
          var pos,
              track,
              trackDetails,
              hls = this.hls,
              config = hls.config;
          //logger.log('audioStream:' + this.state);
          switch (this.state) {
            case State.ERROR:
            //don't do anything in error state to avoid breaking further ...
            case State.PAUSED:
            //don't do anything in paused state either ...
            case State.BUFFER_FLUSHING:
              break;
            case State.STARTING:
              this.state = State.WAITING_TRACK;
              this.loadedmetadata = false;
              break;
            case State.IDLE:
              var tracks = this.tracks;
              // audio tracks not received => exit loop
              if (!tracks) {
                break;
              }
              // if video not attached AND
              // start fragment already requested OR start frag prefetch disable
              // exit loop
              // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
              if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
                break;
              }
              // determine next candidate fragment to be loaded, based on current position and
              //  end of buffer position
              // if we have not yet loaded any fragment, start loading from start position
              if (this.loadedmetadata) {
                pos = this.media.currentTime;
              } else {
                pos = this.nextLoadPosition;
              }
              var media = this.mediaBuffer ? this.mediaBuffer : this.media,
                  bufferInfo = _bufferHelper2.default.bufferInfo(media, pos, config.maxBufferHole),
                  bufferLen = bufferInfo.len,
                  bufferEnd = bufferInfo.end,
                  fragPrevious = this.fragPrevious,
                  maxBufLen = config.maxMaxBufferLength,
                  audioSwitch = this.audioSwitch,
                  trackId = this.trackId;
    
              // if buffer length is less than maxBufLen try to load a new fragment
              if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
                trackDetails = tracks[trackId].details;
                // if track info not retrieved yet, switch state and wait for track retrieval
                if (typeof trackDetails === 'undefined') {
                  this.state = State.WAITING_TRACK;
                  break;
                }
    
                // we just got done loading the final fragment, check if we need to finalize media stream
                if (!audioSwitch && !trackDetails.live && fragPrevious && fragPrevious.sn === trackDetails.endSN) {
                  // if we are not seeking or if we are seeking but everything (almost) til the end is buffered, let's signal eos
                  // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference when switching
                  // between different renditions. using half frag duration should help cope with these cases.
                  if (!this.media.seeking || this.media.duration - bufferEnd < fragPrevious.duration / 2) {
                    // Finalize the media stream
                    this.hls.trigger(_events2.default.BUFFER_EOS, { type: 'audio' });
                    this.state = State.ENDED;
                    break;
                  }
                }
    
                // find fragment index, contiguous with end of buffer position
                var fragments = trackDetails.fragments,
                    fragLen = fragments.length,
                    start = fragments[0].start,
                    end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
                    frag = void 0;
    
                // When switching audio track, reload audio as close as possible to currentTime
                if (audioSwitch) {
                  if (trackDetails.live && !trackDetails.PTSKnown) {
                    _logger.logger.log('switching audiotrack, live stream, unknown PTS,load first fragment');
                    bufferEnd = 0;
                  } else {
                    bufferEnd = pos;
                    // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime
                    if (trackDetails.PTSKnown && pos < start) {
                      // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start
                      if (bufferInfo.end > start || bufferInfo.nextStart) {
                        _logger.logger.log('alt audio track ahead of main track, seek to start of alt audio track');
                        this.media.currentTime = start + 0.05;
                      } else {
                        return;
                      }
                    }
                  }
                }
                if (trackDetails.initSegment && !trackDetails.initSegment.data) {
                  frag = trackDetails.initSegment;
                }
                // if bufferEnd before start of playlist, load first fragment
                else if (bufferEnd <= start) {
                    frag = fragments[0];
                    if (trackDetails.live && frag.loadIdx && frag.loadIdx === this.fragLoadIdx) {
                      // we just loaded this first fragment, and we are still lagging behind the start of the live playlist
                      // let's force seek to start
                      var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                      _logger.logger.log('no alt audio available @currentTime:' + this.media.currentTime + ', seeking @' + (nextBuffered + 0.05));
                      this.media.currentTime = nextBuffered + 0.05;
                      return;
                    }
                  } else {
                    var foundFrag = void 0;
                    var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                    var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
                    var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
                      // offset should be within fragment boundary - config.maxFragLookUpTolerance
                      // this is to cope with situations like
                      // bufferEnd = 9.991
                      // frag[Ø] : [0,10]
                      // frag[1] : [10,20]
                      // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
                      //              frag start               frag start+duration
                      //                  |-----------------------------|
                      //              <--->                         <--->
                      //  ...--------><-----------------------------><---------....
                      // previous frag         matching fragment         next frag
                      //  return -1             return 0                 return 1
                      //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
                      // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
                      var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
                      if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                        return 1;
                      } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
                      else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                          return -1;
                        }
                      return 0;
                    };
    
                    if (bufferEnd < end) {
                      if (bufferEnd > end - maxFragLookUpTolerance) {
                        maxFragLookUpTolerance = 0;
                      }
                      // Prefer the next fragment if it's within tolerance
                      if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
                        foundFrag = fragNext;
                      } else {
                        foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
                      }
                    } else {
                      // reach end of playlist
                      foundFrag = fragments[fragLen - 1];
                    }
                    if (foundFrag) {
                      frag = foundFrag;
                      start = foundFrag.start;
                      //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
                      if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                        if (frag.sn < trackDetails.endSN) {
                          frag = fragments[frag.sn + 1 - trackDetails.startSN];
                          _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                        } else {
                          frag = null;
                        }
                      }
                    }
                  }
                if (frag) {
                  //logger.log('      loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
                  if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
                    _logger.logger.log('Loading key for ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId);
                    this.state = State.KEY_LOADING;
                    hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
                  } else {
                    _logger.logger.log('Loading ' + frag.sn + ' of [' + trackDetails.startSN + ' ,' + trackDetails.endSN + '],track ' + trackId + ', currentTime:' + pos + ',bufferEnd:' + bufferEnd.toFixed(3));
                    // ensure that we are not reloading the same fragments in loop ...
                    if (this.fragLoadIdx !== undefined) {
                      this.fragLoadIdx++;
                    } else {
                      this.fragLoadIdx = 0;
                    }
                    if (frag.loadCounter) {
                      frag.loadCounter++;
                      var maxThreshold = config.fragLoadingLoopThreshold;
                      // if this frag has already been loaded 3 times, and if it has been reloaded recently
                      if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
                        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
                        return;
                      }
                    } else {
                      frag.loadCounter = 1;
                    }
                    frag.loadIdx = this.fragLoadIdx;
                    this.fragCurrent = frag;
                    this.startFragRequested = true;
                    if (!isNaN(frag.sn)) {
                      this.nextLoadPosition = frag.start + frag.duration;
                    }
                    hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
                    this.state = State.FRAG_LOADING;
                  }
                }
              }
              break;
            case State.WAITING_TRACK:
              track = this.tracks[this.trackId];
              // check if playlist is already loaded
              if (track && track.details) {
                this.state = State.IDLE;
              }
              break;
            case State.FRAG_LOADING_WAITING_RETRY:
              var now = performance.now();
              var retryDate = this.retryDate;
              media = this.media;
              var isSeeking = media && media.seeking;
              // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
              if (!retryDate || now >= retryDate || isSeeking) {
                _logger.logger.log('audioStreamController: retryDate reached, switch back to IDLE state');
                this.state = State.IDLE;
              }
              break;
            case State.WAITING_INIT_PTS:
            case State.STOPPED:
            case State.FRAG_LOADING:
            case State.PARSING:
            case State.PARSED:
            case State.ENDED:
              break;
            default:
              break;
          }
        }
      }, {
        key: 'onMediaAttached',
        value: function onMediaAttached(data) {
          var media = this.media = this.mediaBuffer = data.media;
          this.onvseeking = this.onMediaSeeking.bind(this);
          this.onvended = this.onMediaEnded.bind(this);
          media.addEventListener('seeking', this.onvseeking);
          media.addEventListener('ended', this.onvended);
          var config = this.config;
          if (this.tracks && config.autoStartLoad) {
            this.startLoad(config.startPosition);
          }
        }
      }, {
        key: 'onMediaDetaching',
        value: function onMediaDetaching() {
          var media = this.media;
          if (media && media.ended) {
            _logger.logger.log('MSE detaching and video ended, reset startPosition');
            this.startPosition = this.lastCurrentTime = 0;
          }
    
          // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
          var tracks = this.tracks;
          if (tracks) {
            // reset fragment load counter
            tracks.forEach(function (track) {
              if (track.details) {
                track.details.fragments.forEach(function (fragment) {
                  fragment.loadCounter = undefined;
                });
              }
            });
          }
          // remove video listeners
          if (media) {
            media.removeEventListener('seeking', this.onvseeking);
            media.removeEventListener('ended', this.onvended);
            this.onvseeking = this.onvseeked = this.onvended = null;
          }
          this.media = this.mediaBuffer = null;
          this.loadedmetadata = false;
          this.stopLoad();
        }
      }, {
        key: 'onMediaSeeking',
        value: function onMediaSeeking() {
          if (this.state === State.ENDED) {
            // switch to IDLE state to check for potential new fragment
            this.state = State.IDLE;
          }
          if (this.media) {
            this.lastCurrentTime = this.media.currentTime;
          }
          // avoid reporting fragment loop loading error in case user is seeking several times on same position
          if (this.fragLoadIdx !== undefined) {
            this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
          }
          // tick to speed up processing
          this.tick();
        }
      }, {
        key: 'onMediaEnded',
        value: function onMediaEnded() {
          // reset startPosition and lastCurrentTime to restart playback @ stream beginning
          this.startPosition = this.lastCurrentTime = 0;
        }
      }, {
        key: 'onAudioTracksUpdated',
        value: function onAudioTracksUpdated(data) {
          _logger.logger.log('audio tracks updated');
          this.tracks = data.audioTracks;
        }
      }, {
        key: 'onAudioTrackSwitching',
        value: function onAudioTrackSwitching(data) {
          // if any URL found on new audio track, it is an alternate audio track
          var altAudio = !!data.url;
          this.trackId = data.id;
          this.state = State.IDLE;
    
          this.fragCurrent = null;
          this.state = State.PAUSED;
          this.waitingFragment = null;
          // destroy useless demuxer when switching audio to main
          if (!altAudio) {
            if (this.demuxer) {
              this.demuxer.destroy();
              this.demuxer = null;
            }
          } else {
            // switching to audio track, start timer if not already started
            if (!this.timer) {
              this.timer = setInterval(this.ontick, 100);
            }
          }
    
          //should we switch tracks ?
          if (altAudio) {
            this.audioSwitch = true;
            //main audio track are handled by stream-controller, just do something if switching to alt audio track
            this.state = State.IDLE;
            // increase fragment load Index to avoid frag loop loading error after buffer flush
            if (this.fragLoadIdx !== undefined) {
              this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
            }
          }
          this.tick();
        }
      }, {
        key: 'onAudioTrackLoaded',
        value: function onAudioTrackLoaded(data) {
          var newDetails = data.details,
              trackId = data.id,
              track = this.tracks[trackId],
              duration = newDetails.totalduration,
              sliding = 0;
    
          _logger.logger.log('track ' + trackId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);
    
          if (newDetails.live) {
            var curDetails = track.details;
            if (curDetails && newDetails.fragments.length > 0) {
              // we already have details for that level, merge them
              _levelHelper2.default.mergeDetails(curDetails, newDetails);
              sliding = newDetails.fragments[0].start;
              // TODO
              //this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
              if (newDetails.PTSKnown) {
                _logger.logger.log('live audio playlist sliding:' + sliding.toFixed(3));
              } else {
                _logger.logger.log('live audio playlist - outdated PTS, unknown sliding');
              }
            } else {
              newDetails.PTSKnown = false;
              _logger.logger.log('live audio playlist - first load, unknown sliding');
            }
          } else {
            newDetails.PTSKnown = false;
          }
          track.details = newDetails;
    
          // compute start position
          if (!this.startFragRequested) {
            // compute start position if set to -1. use it straight away if value is defined
            if (this.startPosition === -1) {
              // first, check if start time offset has been set in playlist, if yes, use this value
              var startTimeOffset = newDetails.startTimeOffset;
              if (!isNaN(startTimeOffset)) {
                _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
                this.startPosition = startTimeOffset;
              } else {
                this.startPosition = 0;
              }
            }
            this.nextLoadPosition = this.startPosition;
          }
          // only switch batck to IDLE state if we were waiting for track to start downloading a new fragment
          if (this.state === State.WAITING_TRACK) {
            this.state = State.IDLE;
          }
          //trigger handler right now
          this.tick();
        }
      }, {
        key: 'onKeyLoaded',
        value: function onKeyLoaded() {
          if (this.state === State.KEY_LOADING) {
            this.state = State.IDLE;
            this.tick();
          }
        }
      }, {
        key: 'onFragLoaded',
        value: function onFragLoaded(data) {
          var fragCurrent = this.fragCurrent,
              fragLoaded = data.frag;
          if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'audio' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
            var track = this.tracks[this.trackId],
                details = track.details,
                duration = details.totalduration,
                trackId = fragCurrent.level,
                sn = fragCurrent.sn,
                cc = fragCurrent.cc,
                audioCodec = this.config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2',
                stats = this.stats = data.stats;
            if (sn === 'initSegment') {
              this.state = State.IDLE;
    
              stats.tparsed = stats.tbuffered = performance.now();
              details.initSegment.data = data.payload;
              this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'audio' });
              this.tick();
            } else {
              this.state = State.PARSING;
              // transmux the MPEG-TS data to ISO-BMFF segments
              this.appended = false;
              if (!this.demuxer) {
                this.demuxer = new _demuxer2.default(this.hls, 'audio');
              }
              //Check if we have video initPTS
              // If not we need to wait for it
              var initPTS = this.initPTS[cc];
              var initSegmentData = details.initSegment ? details.initSegment.data : [];
              if (details.initSegment || initPTS !== undefined) {
                this.pendingBuffering = true;
                _logger.logger.log('Demuxing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
                // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)
                var accurateTimeOffset = false; //details.PTSKnown || !details.live;
                this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
              } else {
                _logger.logger.log('unknown video PTS for continuity counter ' + cc + ', waiting for video PTS before demuxing audio frag ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],track ' + trackId);
                this.waitingFragment = data;
                this.state = State.WAITING_INIT_PTS;
              }
            }
          }
          this.fragLoadError = 0;
        }
      }, {
        key: 'onFragParsingInitSegment',
        value: function onFragParsingInitSegment(data) {
          var fragCurrent = this.fragCurrent;
          var fragNew = data.frag;
          if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
            var tracks = data.tracks,
                track = void 0;
    
            // delete any video track found on audio demuxer
            if (tracks.video) {
              delete tracks.video;
            }
    
            // include levelCodec in audio and video tracks
            track = tracks.audio;
            if (track) {
              track.levelCodec = 'mp4a.40.2';
              track.id = data.id;
              this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
              _logger.logger.log('audio track:audio,container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
              var initSegment = track.initSegment;
              if (initSegment) {
                var appendObj = { type: 'audio', data: initSegment, parent: 'audio', content: 'initSegment' };
                if (this.audioSwitch) {
                  this.pendingData = [appendObj];
                } else {
                  this.appended = true;
                  // arm pending Buffering flag before appending a segment
                  this.pendingBuffering = true;
                  this.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
                }
              }
              //trigger handler right now
              this.tick();
            }
          }
        }
      }, {
        key: 'onFragParsingData',
        value: function onFragParsingData(data) {
          var _this2 = this;
    
          var fragCurrent = this.fragCurrent;
          var fragNew = data.frag;
          if (fragCurrent && data.id === 'audio' && data.type === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
            var trackId = this.trackId,
                track = this.tracks[trackId],
                hls = this.hls;
    
            if (isNaN(data.endPTS)) {
              data.endPTS = data.startPTS + fragCurrent.duration;
              data.endDTS = data.startDTS + fragCurrent.duration;
            }
    
            _logger.logger.log('parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb);
            _levelHelper2.default.updateFragPTSDTS(track.details, fragCurrent, data.startPTS, data.endPTS);
    
            var audioSwitch = this.audioSwitch,
                media = this.media,
                appendOnBufferFlush = false;
            //Only flush audio from old audio tracks when PTS is known on new audio track
            if (audioSwitch && media) {
              if (media.readyState) {
                var currentTime = media.currentTime;
                _logger.logger.log('switching audio track : currentTime:' + currentTime);
                if (currentTime >= data.startPTS) {
                  _logger.logger.log('switching audio track : flushing all audio');
                  this.state = State.BUFFER_FLUSHING;
                  hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
                  appendOnBufferFlush = true;
                  //Lets announce that the initial audio track switch flush occur
                  this.audioSwitch = false;
                  hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
                }
              } else {
                //Lets announce that the initial audio track switch flush occur
                this.audioSwitch = false;
                hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
              }
            }
    
            var pendingData = this.pendingData;
            if (!this.audioSwitch) {
              [data.data1, data.data2].forEach(function (buffer) {
                if (buffer && buffer.length) {
                  pendingData.push({ type: data.type, data: buffer, parent: 'audio', content: 'data' });
                }
              });
              if (!appendOnBufferFlush && pendingData.length) {
                pendingData.forEach(function (appendObj) {
                  // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
                  // in that case it is useless to append following segments
                  if (_this2.state === State.PARSING) {
                    // arm pending Buffering flag before appending a segment
                    _this2.pendingBuffering = true;
                    _this2.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
                  }
                });
                this.pendingData = [];
                this.appended = true;
              }
            }
            //trigger handler right now
            this.tick();
          }
        }
      }, {
        key: 'onFragParsed',
        value: function onFragParsed(data) {
          var fragCurrent = this.fragCurrent;
          var fragNew = data.frag;
          if (fragCurrent && data.id === 'audio' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
            this.stats.tparsed = performance.now();
            this.state = State.PARSED;
            this._checkAppendedParsed();
          }
        }
      }, {
        key: 'onBufferCreated',
        value: function onBufferCreated(data) {
          var audioTrack = data.tracks.audio;
          if (audioTrack) {
            this.mediaBuffer = audioTrack.buffer;
            this.loadedmetadata = true;
          }
        }
      }, {
        key: 'onBufferAppended',
        value: function onBufferAppended(data) {
          if (data.parent === 'audio') {
            var state = this.state;
            if (state === State.PARSING || state === State.PARSED) {
              // check if all buffers have been appended
              this.pendingBuffering = data.pending > 0;
              this._checkAppendedParsed();
            }
          }
        }
      }, {
        key: '_checkAppendedParsed',
        value: function _checkAppendedParsed() {
          //trigger handler right now
          if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {
            var frag = this.fragCurrent,
                stats = this.stats,
                hls = this.hls;
            if (frag) {
              this.fragPrevious = frag;
              stats.tbuffered = performance.now();
              hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'audio' });
              var media = this.mediaBuffer ? this.mediaBuffer : this.media;
              _logger.logger.log('audio buffered : ' + _timeRanges2.default.toString(media.buffered));
              if (this.audioSwitch && this.appended) {
                this.audioSwitch = false;
                hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: this.trackId });
              }
              this.state = State.IDLE;
            }
            this.tick();
          }
        }
      }, {
        key: 'onError',
        value: function onError(data) {
          var frag = data.frag;
          // don't handle frag error not related to audio fragment
          if (frag && frag.type !== 'audio') {
            return;
          }
          switch (data.details) {
            case _errors.ErrorDetails.FRAG_LOAD_ERROR:
            case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
              if (!data.fatal) {
                var loadError = this.fragLoadError;
                if (loadError) {
                  loadError++;
                } else {
                  loadError = 1;
                }
                var config = this.config;
                if (loadError <= config.fragLoadingMaxRetry) {
                  this.fragLoadError = loadError;
                  // reset load counter to avoid frag loop loading error
                  frag.loadCounter = 0;
                  // exponential backoff capped to config.fragLoadingMaxRetryTimeout
                  var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
                  _logger.logger.warn('audioStreamController: frag loading failed, retry in ' + delay + ' ms');
                  this.retryDate = performance.now() + delay;
                  // retry loading state
                  this.state = State.FRAG_LOADING_WAITING_RETRY;
                } else {
                  _logger.logger.error('audioStreamController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
                  // switch error to fatal
                  data.fatal = true;
                  this.state = State.ERROR;
                }
              }
              break;
            case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
            case _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
            case _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
            case _errors.ErrorDetails.KEY_LOAD_ERROR:
            case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
              //  when in ERROR state, don't switch back to IDLE state in case a non-fatal error is received
              if (this.state !== State.ERROR) {
                // if fatal error, stop processing, otherwise move to IDLE to retry loading
                this.state = data.fatal ? State.ERROR : State.IDLE;
                _logger.logger.warn('audioStreamController: ' + data.details + ' while loading frag,switch to ' + this.state + ' state ...');
              }
              break;
            case _errors.ErrorDetails.BUFFER_FULL_ERROR:
              // if in appending state
              if (data.parent === 'audio' && (this.state === State.PARSING || this.state === State.PARSED)) {
                var media = this.mediaBuffer,
                    currentTime = this.media.currentTime,
                    mediaBuffered = media && _bufferHelper2.default.isBuffered(media, currentTime) && _bufferHelper2.default.isBuffered(media, currentTime + 0.5);
                // reduce max buf len if current position is buffered
                if (mediaBuffered) {
                  var _config = this.config;
                  if (_config.maxMaxBufferLength >= _config.maxBufferLength) {
                    // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
                    _config.maxMaxBufferLength /= 2;
                    _logger.logger.warn('audio:reduce max buffer length to ' + _config.maxMaxBufferLength + 's');
                    // increase fragment load Index to avoid frag loop loading error after buffer flush
                    this.fragLoadIdx += 2 * _config.fragLoadingLoopThreshold;
                  }
                  this.state = State.IDLE;
                } else {
                  // current position is not buffered, but browser is still complaining about buffer full error
                  // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
                  // in that case flush the whole audio buffer to recover
                  _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush audio buffer');
                  this.fragCurrent = null;
                  // flush everything
                  this.state = State.BUFFER_FLUSHING;
                  this.hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
                }
              }
              break;
            default:
              break;
          }
        }
      }, {
        key: 'onBufferFlushed',
        value: function onBufferFlushed() {
          var _this3 = this;
    
          var pendingData = this.pendingData;
          if (pendingData && pendingData.length) {
            _logger.logger.log('appending pending audio data on Buffer Flushed');
            pendingData.forEach(function (appendObj) {
              _this3.hls.trigger(_events2.default.BUFFER_APPENDING, appendObj);
            });
            this.appended = true;
            this.pendingData = [];
            this.state = State.PARSED;
          } else {
            // move to IDLE once flush complete. this should trigger new fragment loading
            this.state = State.IDLE;
            // reset reference to frag
            this.fragPrevious = null;
            this.tick();
          }
        }
      }, {
        key: 'state',
        set: function set(nextState) {
          if (this.state !== nextState) {
            var previousState = this.state;
            this._state = nextState;
            _logger.logger.log('audio stream:' + previousState + '->' + nextState);
          }
        },
        get: function get() {
          return this._state;
        }
      }]);
    
      return AudioStreamController;
    }(_eventHandler2.default);
    
    exports.default = AudioStreamController;
    
    },{"25":25,"31":31,"32":32,"33":33,"35":35,"36":36,"46":46,"51":51,"52":52}],7:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _logger = _dereq_(51);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    var AudioTrackController = function (_EventHandler) {
      _inherits(AudioTrackController, _EventHandler);
    
      function AudioTrackController(hls) {
        _classCallCheck(this, AudioTrackController);
    
        var _this = _possibleConstructorReturn(this, (AudioTrackController.__proto__ || Object.getPrototypeOf(AudioTrackController)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.AUDIO_TRACK_LOADED));
    
        _this.ticks = 0;
        _this.ontick = _this.tick.bind(_this);
        return _this;
      }
    
      _createClass(AudioTrackController, [{
        key: 'destroy',
        value: function destroy() {
          _eventHandler2.default.prototype.destroy.call(this);
        }
      }, {
        key: 'tick',
        value: function tick() {
          this.ticks++;
          if (this.ticks === 1) {
            this.doTick();
            if (this.ticks > 1) {
              setTimeout(this.tick, 1);
            }
            this.ticks = 0;
          }
        }
      }, {
        key: 'doTick',
        value: function doTick() {
          this.updateTrack(this.trackId);
        }
      }, {
        key: 'onManifestLoading',
        value: function onManifestLoading() {
          // reset audio tracks on manifest loading
          this.tracks = [];
          this.trackId = -1;
        }
      }, {
        key: 'onManifestLoaded',
        value: function onManifestLoaded(data) {
          var _this2 = this;
    
          var tracks = data.audioTracks || [];
          var defaultFound = false;
          this.tracks = tracks;
          this.hls.trigger(_events2.default.AUDIO_TRACKS_UPDATED, { audioTracks: tracks });
          // loop through available audio tracks and autoselect default if needed
          var id = 0;
          tracks.forEach(function (track) {
            if (track.default) {
              _this2.audioTrack = id;
              defaultFound = true;
              return;
            }
            id++;
          });
          if (defaultFound === false && tracks.length) {
            _logger.logger.log('no default audio track defined, use first audio track as default');
            this.audioTrack = 0;
          }
        }
      }, {
        key: 'onAudioTrackLoaded',
        value: function onAudioTrackLoaded(data) {
          if (data.id < this.tracks.length) {
            _logger.logger.log('audioTrack ' + data.id + ' loaded');
            this.tracks[data.id].details = data.details;
            // check if current playlist is a live playlist
            if (data.details.live && !this.timer) {
              // if live playlist we will have to reload it periodically
              // set reload period to playlist target duration
              this.timer = setInterval(this.ontick, 1000 * data.details.targetduration);
            }
            if (!data.details.live && this.timer) {
              // playlist is not live and timer is armed : stopping it
              clearInterval(this.timer);
              this.timer = null;
            }
          }
        }
    
        /** get alternate audio tracks list from playlist **/
    
      }, {
        key: 'setAudioTrackInternal',
        value: function setAudioTrackInternal(newId) {
          // check if level idx is valid
          if (newId >= 0 && newId < this.tracks.length) {
            // stopping live reloading timer if any
            if (this.timer) {
              clearInterval(this.timer);
              this.timer = null;
            }
            this.trackId = newId;
            _logger.logger.log('switching to audioTrack ' + newId);
            var audioTrack = this.tracks[newId],
                hls = this.hls,
                type = audioTrack.type,
                url = audioTrack.url,
                eventObj = { id: newId, type: type, url: url };
            // keep AUDIO_TRACK_SWITCH for legacy reason
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCH, eventObj);
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHING, eventObj);
            // check if we need to load playlist for this audio Track
            var details = audioTrack.details;
            if (url && (details === undefined || details.live === true)) {
              // track not retrieved yet, or live playlist we need to (re)load it
              _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
              hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
            }
          }
        }
      }, {
        key: 'updateTrack',
        value: function updateTrack(newId) {
          // check if level idx is valid
          if (newId >= 0 && newId < this.tracks.length) {
            // stopping live reloading timer if any
            if (this.timer) {
              clearInterval(this.timer);
              this.timer = null;
            }
            this.trackId = newId;
            _logger.logger.log('updating audioTrack ' + newId);
            var audioTrack = this.tracks[newId],
                url = audioTrack.url;
            // check if we need to load playlist for this audio Track
            var details = audioTrack.details;
            if (url && (details === undefined || details.live === true)) {
              // track not retrieved yet, or live playlist we need to (re)load it
              _logger.logger.log('(re)loading playlist for audioTrack ' + newId);
              this.hls.trigger(_events2.default.AUDIO_TRACK_LOADING, { url: url, id: newId });
            }
          }
        }
      }, {
        key: 'audioTracks',
        get: function get() {
          return this.tracks;
        }
    
        /** get index of the selected audio track (index in audio track lists) **/
    
      }, {
        key: 'audioTrack',
        get: function get() {
          return this.trackId;
        }
    
        /** select an audio track, based on its index in audio track lists**/
        ,
        set: function set(audioTrackId) {
          if (this.trackId !== audioTrackId || this.tracks[audioTrackId].details === undefined) {
            this.setAudioTrackInternal(audioTrackId);
          }
        }
      }]);
    
      return AudioTrackController;
    }(_eventHandler2.default);
    
    exports.default = AudioTrackController;
    
    },{"32":32,"33":33,"51":51}],8:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _logger = _dereq_(51);
    
    var _errors = _dereq_(31);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * Buffer Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    var BufferController = function (_EventHandler) {
      _inherits(BufferController, _EventHandler);
    
      function BufferController(hls) {
        _classCallCheck(this, BufferController);
    
        // the value that we have set mediasource.duration to
        // (the actual duration may be tweaked slighly by the browser)
        var _this = _possibleConstructorReturn(this, (BufferController.__proto__ || Object.getPrototypeOf(BufferController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_PARSED, _events2.default.BUFFER_RESET, _events2.default.BUFFER_APPENDING, _events2.default.BUFFER_CODECS, _events2.default.BUFFER_EOS, _events2.default.BUFFER_FLUSHING, _events2.default.LEVEL_PTS_UPDATED, _events2.default.LEVEL_UPDATED));
    
        _this._msDuration = null;
        // the value that we want to set mediaSource.duration to
        _this._levelDuration = null;
    
        // Source Buffer listeners
        _this.onsbue = _this.onSBUpdateEnd.bind(_this);
        _this.onsbe = _this.onSBUpdateError.bind(_this);
        _this.pendingTracks = {};
        _this.tracks = {};
        return _this;
      }
    
      _createClass(BufferController, [{
        key: 'destroy',
        value: function destroy() {
          _eventHandler2.default.prototype.destroy.call(this);
        }
      }, {
        key: 'onLevelPtsUpdated',
        value: function onLevelPtsUpdated(data) {
          var type = data.type;
          var audioTrack = this.tracks.audio;
    
          // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)
          // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`
          // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos). At the time of change we issue
          // `SourceBuffer.abort()` and adjusting `SourceBuffer.timestampOffset` if `SourceBuffer.updating` is false or awaiting `updateend`
          // event if SB is in updating state.
          // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486
    
          if (type === 'audio' && audioTrack && audioTrack.container === 'audio/mpeg') {
            // Chrome audio mp3 track
            var audioBuffer = this.sourceBuffer.audio;
            var delta = Math.abs(audioBuffer.timestampOffset - data.start);
    
            // adjust timestamp offset if time delta is greater than 100ms
            if (delta > 0.1) {
              var updating = audioBuffer.updating;
    
              try {
                audioBuffer.abort();
              } catch (err) {
                updating = true;
                _logger.logger.warn('can not abort audio buffer: ' + err);
              }
    
              if (!updating) {
                _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + data.start);
                audioBuffer.timestampOffset = data.start;
              } else {
                this.audioTimestampOffset = data.start;
              }
            }
          }
        }
      }, {
        key: 'onManifestParsed',
        value: function onManifestParsed(data) {
          var audioExpected = data.audio,
              videoExpected = data.video,
              sourceBufferNb = 0;
          // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller
          // sourcebuffers will be created all at once when the expected nb of tracks will be reached
          // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller
          // it will contain the expected nb of source buffers, no need to compute it
          if (data.altAudio && (audioExpected || videoExpected)) {
            sourceBufferNb = (audioExpected ? 1 : 0) + (videoExpected ? 1 : 0);
            _logger.logger.log(sourceBufferNb + ' sourceBuffer(s) expected');
          }
          this.sourceBufferNb = sourceBufferNb;
        }
      }, {
        key: 'onMediaAttaching',
        value: function onMediaAttaching(data) {
          var media = this.media = data.media;
          if (media) {
            // setup the media source
            var ms = this.mediaSource = new MediaSource();
            //Media Source listeners
            this.onmso = this.onMediaSourceOpen.bind(this);
            this.onmse = this.onMediaSourceEnded.bind(this);
            this.onmsc = this.onMediaSourceClose.bind(this);
            ms.addEventListener('sourceopen', this.onmso);
            ms.addEventListener('sourceended', this.onmse);
            ms.addEventListener('sourceclose', this.onmsc);
            // link video and media Source
            media.src = URL.createObjectURL(ms);
          }
        }
      }, {
        key: 'onMediaDetaching',
        value: function onMediaDetaching() {
          _logger.logger.log('media source detaching');
          var ms = this.mediaSource;
          if (ms) {
            if (ms.readyState === 'open') {
              try {
                // endOfStream could trigger exception if any sourcebuffer is in updating state
                // we don't really care about checking sourcebuffer state here,
                // as we are anyway detaching the MediaSource
                // let's just avoid this exception to propagate
                ms.endOfStream();
              } catch (err) {
                _logger.logger.warn('onMediaDetaching:' + err.message + ' while calling endOfStream');
              }
            }
            ms.removeEventListener('sourceopen', this.onmso);
            ms.removeEventListener('sourceended', this.onmse);
            ms.removeEventListener('sourceclose', this.onmsc);
    
            // Detach properly the MediaSource from the HTMLMediaElement as
            // suggested in https://github.com/w3c/media-source/issues/53.
            if (this.media) {
              URL.revokeObjectURL(this.media.src);
              this.media.removeAttribute('src');
              this.media.load();
            }
    
            this.mediaSource = null;
            this.media = null;
            this.pendingTracks = {};
            this.tracks = {};
            this.sourceBuffer = {};
            this.flushRange = [];
            this.segments = [];
            this.appended = 0;
          }
          this.onmso = this.onmse = this.onmsc = null;
          this.hls.trigger(_events2.default.MEDIA_DETACHED);
        }
      }, {
        key: 'onMediaSourceOpen',
        value: function onMediaSourceOpen() {
          _logger.logger.log('media source opened');
          this.hls.trigger(_events2.default.MEDIA_ATTACHED, { media: this.media });
          var mediaSource = this.mediaSource;
          if (mediaSource) {
            // once received, don't listen anymore to sourceopen event
            mediaSource.removeEventListener('sourceopen', this.onmso);
          }
          this.checkPendingTracks();
        }
      }, {
        key: 'checkPendingTracks',
        value: function checkPendingTracks() {
          // if any buffer codecs pending, check if we have enough to create sourceBuffers
          var pendingTracks = this.pendingTracks,
              pendingTracksNb = Object.keys(pendingTracks).length;
          // if any pending tracks and (if nb of pending tracks gt or equal than expected nb or if unknown expected nb)
          if (pendingTracksNb && (this.sourceBufferNb <= pendingTracksNb || this.sourceBufferNb === 0)) {
            // ok, let's create them now !
            this.createSourceBuffers(pendingTracks);
            this.pendingTracks = {};
            // append any pending segments now !
            this.doAppending();
          }
        }
      }, {
        key: 'onMediaSourceClose',
        value: function onMediaSourceClose() {
          _logger.logger.log('media source closed');
        }
      }, {
        key: 'onMediaSourceEnded',
        value: function onMediaSourceEnded() {
          _logger.logger.log('media source ended');
        }
      }, {
        key: 'onSBUpdateEnd',
        value: function onSBUpdateEnd() {
          // update timestampOffset
          if (this.audioTimestampOffset) {
            var audioBuffer = this.sourceBuffer.audio;
            _logger.logger.warn('change mpeg audio timestamp offset from ' + audioBuffer.timestampOffset + ' to ' + this.audioTimestampOffset);
            audioBuffer.timestampOffset = this.audioTimestampOffset;
            delete this.audioTimestampOffset;
          }
    
          if (this._needsFlush) {
            this.doFlush();
          }
    
          if (this._needsEos) {
            this.checkEos();
          }
          this.appending = false;
          var parent = this.parent;
          // count nb of pending segments waiting for appending on this sourcebuffer
          var pending = this.segments.reduce(function (counter, segment) {
            return segment.parent === parent ? counter + 1 : counter;
          }, 0);
          this.hls.trigger(_events2.default.BUFFER_APPENDED, { parent: parent, pending: pending });
    
          // don't append in flushing mode
          if (!this._needsFlush) {
            this.doAppending();
          }
    
          this.updateMediaElementDuration();
        }
      }, {
        key: 'onSBUpdateError',
        value: function onSBUpdateError(event) {
          _logger.logger.error('sourceBuffer error:', event);
          // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
          // this error might not always be fatal (it is fatal if decode error is set, in that case
          // it will be followed by a mediaElement error ...)
          this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
          // we don't need to do more than that, as accordin to the spec, updateend will be fired just after
        }
      }, {
        key: 'onBufferReset',
        value: function onBufferReset() {
          var sourceBuffer = this.sourceBuffer;
          for (var type in sourceBuffer) {
            var sb = sourceBuffer[type];
            try {
              this.mediaSource.removeSourceBuffer(sb);
              sb.removeEventListener('updateend', this.onsbue);
              sb.removeEventListener('error', this.onsbe);
            } catch (err) {}
          }
          this.sourceBuffer = {};
          this.flushRange = [];
          this.segments = [];
          this.appended = 0;
        }
      }, {
        key: 'onBufferCodecs',
        value: function onBufferCodecs(tracks) {
          // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks
          // if sourcebuffers already created, do nothing ...
          if (Object.keys(this.sourceBuffer).length === 0) {
            for (var trackName in tracks) {
              this.pendingTracks[trackName] = tracks[trackName];
            }
            var mediaSource = this.mediaSource;
            if (mediaSource && mediaSource.readyState === 'open') {
              // try to create sourcebuffers if mediasource opened
              this.checkPendingTracks();
            }
          }
        }
      }, {
        key: 'createSourceBuffers',
        value: function createSourceBuffers(tracks) {
          var sourceBuffer = this.sourceBuffer,
              mediaSource = this.mediaSource;
    
          for (var trackName in tracks) {
            if (!sourceBuffer[trackName]) {
              var track = tracks[trackName];
              // use levelCodec as first priority
              var codec = track.levelCodec || track.codec;
              var mimeType = track.container + ';codecs=' + codec;
              _logger.logger.log('creating sourceBuffer(' + mimeType + ')');
              try {
                var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
                sb.addEventListener('updateend', this.onsbue);
                sb.addEventListener('error', this.onsbe);
                this.tracks[trackName] = { codec: codec, container: track.container };
                track.buffer = sb;
              } catch (err) {
                _logger.logger.error('error while trying to add sourceBuffer:' + err.message);
                this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_ADD_CODEC_ERROR, fatal: false, err: err, mimeType: mimeType });
              }
            }
          }
          this.hls.trigger(_events2.default.BUFFER_CREATED, { tracks: tracks });
        }
      }, {
        key: 'onBufferAppending',
        value: function onBufferAppending(data) {
          if (!this._needsFlush) {
            if (!this.segments) {
              this.segments = [data];
            } else {
              this.segments.push(data);
            }
            this.doAppending();
          }
        }
      }, {
        key: 'onBufferAppendFail',
        value: function onBufferAppendFail(data) {
          _logger.logger.error('sourceBuffer error:', data.event);
          // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error
          // this error might not always be fatal (it is fatal if decode error is set, in that case
          // it will be followed by a mediaElement error ...)
          this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_APPENDING_ERROR, fatal: false });
        }
    
        // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()
    
      }, {
        key: 'onBufferEos',
        value: function onBufferEos(data) {
          var sb = this.sourceBuffer;
          var dataType = data.type;
          for (var type in sb) {
            if (!dataType || type === dataType) {
              if (!sb[type].ended) {
                sb[type].ended = true;
                _logger.logger.log(type + ' sourceBuffer now EOS');
              }
            }
          }
          this.checkEos();
        }
    
        // if all source buffers are marked as ended, signal endOfStream() to MediaSource.
    
      }, {
        key: 'checkEos',
        value: function checkEos() {
          var sb = this.sourceBuffer,
              mediaSource = this.mediaSource;
          if (!mediaSource || mediaSource.readyState !== 'open') {
            this._needsEos = false;
            return;
          }
          for (var type in sb) {
            var sbobj = sb[type];
            if (!sbobj.ended) {
              return;
            }
            if (sbobj.updating) {
              this._needsEos = true;
              return;
            }
          }
          _logger.logger.log('all media data available, signal endOfStream() to MediaSource and stop loading fragment');
          //Notify the media element that it now has all of the media data
          try {
            mediaSource.endOfStream();
          } catch (e) {
            _logger.logger.warn('exception while calling mediaSource.endOfStream()');
          }
          this._needsEos = false;
        }
      }, {
        key: 'onBufferFlushing',
        value: function onBufferFlushing(data) {
          this.flushRange.push({ start: data.startOffset, end: data.endOffset, type: data.type });
          // attempt flush immediatly
          this.flushBufferCounter = 0;
          this.doFlush();
        }
      }, {
        key: 'onLevelUpdated',
        value: function onLevelUpdated(event) {
          var details = event.details;
          if (details.fragments.length === 0) {
            return;
          }
          this._levelDuration = details.totalduration + details.fragments[0].start;
          this.updateMediaElementDuration();
        }
    
        // https://github.com/video-dev/hls.js/issues/355
    
      }, {
        key: 'updateMediaElementDuration',
        value: function updateMediaElementDuration() {
          var media = this.media,
              mediaSource = this.mediaSource,
              sourceBuffer = this.sourceBuffer,
              levelDuration = this._levelDuration;
          if (levelDuration === null || !media || !mediaSource || !sourceBuffer || media.readyState === 0 || mediaSource.readyState !== 'open') {
            return;
          }
          for (var type in sourceBuffer) {
            if (sourceBuffer[type].updating) {
              // can't set duration whilst a buffer is updating
              return;
            }
          }
          if (this._msDuration === null) {
            // initialise to the value that the media source is reporting
            this._msDuration = mediaSource.duration;
          }
          var duration = media.duration;
          // levelDuration was the last value we set.
          // not using mediaSource.duration as the browser may tweak this value
          // only update mediasource duration if its value increase, this is to avoid
          // flushing already buffered portion when switching between quality level
          if (levelDuration > this._msDuration && levelDuration > duration || duration === Infinity || isNaN(duration)) {
            _logger.logger.log('Updating mediasource duration to ' + levelDuration.toFixed(3));
            this._msDuration = mediaSource.duration = levelDuration;
          }
        }
      }, {
        key: 'doFlush',
        value: function doFlush() {
          // loop through all buffer ranges to flush
          while (this.flushRange.length) {
            var range = this.flushRange[0];
            // flushBuffer will abort any buffer append in progress and flush Audio/Video Buffer
            if (this.flushBuffer(range.start, range.end, range.type)) {
              // range flushed, remove from flush array
              this.flushRange.shift();
              this.flushBufferCounter = 0;
            } else {
              this._needsFlush = true;
              // avoid looping, wait for SB update end to retrigger a flush
              return;
            }
          }
          if (this.flushRange.length === 0) {
            // everything flushed
            this._needsFlush = false;
    
            // let's recompute this.appended, which is used to avoid flush looping
            var appended = 0;
            var sourceBuffer = this.sourceBuffer;
            try {
              for (var type in sourceBuffer) {
                appended += sourceBuffer[type].buffered.length;
              }
            } catch (error) {
              // error could be thrown while accessing buffered, in case sourcebuffer has already been removed from MediaSource
              // this is harmess at this stage, catch this to avoid reporting an internal exception
              _logger.logger.error('error while accessing sourceBuffer.buffered');
            }
            this.appended = appended;
            this.hls.trigger(_events2.default.BUFFER_FLUSHED);
          }
        }
      }, {
        key: 'doAppending',
        value: function doAppending() {
          var hls = this.hls,
              sourceBuffer = this.sourceBuffer,
              segments = this.segments;
          if (Object.keys(sourceBuffer).length) {
            if (this.media.error) {
              this.segments = [];
              _logger.logger.error('trying to append although a media error occured, flush segment and abort');
              return;
            }
            if (this.appending) {
              //logger.log(`sb appending in progress`);
              return;
            }
            if (segments && segments.length) {
              var segment = segments.shift();
              try {
                var type = segment.type,
                    sb = sourceBuffer[type];
                if (sb) {
                  if (!sb.updating) {
                    // reset sourceBuffer ended flag before appending segment
                    sb.ended = false;
                    //logger.log(`appending ${segment.content} ${type} SB, size:${segment.data.length}, ${segment.parent}`);
                    this.parent = segment.parent;
                    sb.appendBuffer(segment.data);
                    this.appendError = 0;
                    this.appended++;
                    this.appending = true;
                  } else {
                    segments.unshift(segment);
                  }
                } else {
                  // in case we don't have any source buffer matching with this segment type,
                  // it means that Mediasource fails to create sourcebuffer
                  // discard this segment, and trigger update end
                  this.onSBUpdateEnd();
                }
              } catch (err) {
                // in case any error occured while appending, put back segment in segments table
                _logger.logger.error('error while trying to append buffer:' + err.message);
                segments.unshift(segment);
                var event = { type: _errors.ErrorTypes.MEDIA_ERROR, parent: segment.parent };
                if (err.code !== 22) {
                  if (this.appendError) {
                    this.appendError++;
                  } else {
                    this.appendError = 1;
                  }
                  event.details = _errors.ErrorDetails.BUFFER_APPEND_ERROR;
                  /* with UHD content, we could get loop of quota exceeded error until
                    browser is able to evict some data from sourcebuffer. retrying help recovering this
                  */
                  if (this.appendError > hls.config.appendErrorMaxRetry) {
                    _logger.logger.log('fail ' + hls.config.appendErrorMaxRetry + ' times to append segment in sourceBuffer');
                    segments = [];
                    event.fatal = true;
                    hls.trigger(_events2.default.ERROR, event);
                    return;
                  } else {
                    event.fatal = false;
                    hls.trigger(_events2.default.ERROR, event);
                  }
                } else {
                  // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror
                  // let's stop appending any segments, and report BUFFER_FULL_ERROR error
                  this.segments = [];
                  event.details = _errors.ErrorDetails.BUFFER_FULL_ERROR;
                  event.fatal = false;
                  hls.trigger(_events2.default.ERROR, event);
                  return;
                }
              }
            }
          }
        }
    
        /*
          flush specified buffered range,
          return true once range has been flushed.
          as sourceBuffer.remove() is asynchronous, flushBuffer will be retriggered on sourceBuffer update end
        */
    
      }, {
        key: 'flushBuffer',
        value: function flushBuffer(startOffset, endOffset, typeIn) {
          var sb,
              i,
              bufStart,
              bufEnd,
              flushStart,
              flushEnd,
              sourceBuffer = this.sourceBuffer;
          if (Object.keys(sourceBuffer).length) {
            _logger.logger.log('flushBuffer,pos/start/end: ' + this.media.currentTime.toFixed(3) + '/' + startOffset + '/' + endOffset);
            // safeguard to avoid infinite looping : don't try to flush more than the nb of appended segments
            if (this.flushBufferCounter < this.appended) {
              for (var type in sourceBuffer) {
                // check if sourcebuffer type is defined (typeIn): if yes, let's only flush this one
                // if no, let's flush all sourcebuffers
                if (typeIn && type !== typeIn) {
                  continue;
                }
                sb = sourceBuffer[type];
                // we are going to flush buffer, mark source buffer as 'not ended'
                sb.ended = false;
                if (!sb.updating) {
                  try {
                    for (i = 0; i < sb.buffered.length; i++) {
                      bufStart = sb.buffered.start(i);
                      bufEnd = sb.buffered.end(i);
                      // workaround firefox not able to properly flush multiple buffered range.
                      if (navigator.userAgent.toLowerCase().indexOf('firefox') !== -1 && endOffset === Number.POSITIVE_INFINITY) {
                        flushStart = startOffset;
                        flushEnd = endOffset;
                      } else {
                        flushStart = Math.max(bufStart, startOffset);
                        flushEnd = Math.min(bufEnd, endOffset);
                      }
                      /* sometimes sourcebuffer.remove() does not flush
                         the exact expected time range.
                         to avoid rounding issues/infinite loop,
                         only flush buffer range of length greater than 500ms.
                      */
                      if (Math.min(flushEnd, bufEnd) - flushStart > 0.5) {
                        this.flushBufferCounter++;
                        _logger.logger.log('flush ' + type + ' [' + flushStart + ',' + flushEnd + '], of [' + bufStart + ',' + bufEnd + '], pos:' + this.media.currentTime);
                        sb.remove(flushStart, flushEnd);
                        return false;
                      }
                    }
                  } catch (e) {
                    _logger.logger.warn('exception while accessing sourcebuffer, it might have been removed from MediaSource');
                  }
                } else {
                  //logger.log('abort ' + type + ' append in progress');
                  // this will abort any appending in progress
                  //sb.abort();
                  _logger.logger.warn('cannot flush, sb updating in progress');
                  return false;
                }
              }
            } else {
              _logger.logger.warn('abort flushing too many retries');
            }
            _logger.logger.log('buffer flushed');
          }
          // everything flushed !
          return true;
        }
      }]);
    
      return BufferController;
    }(_eventHandler2.default);
    
    exports.default = BufferController;
    
    },{"31":31,"32":32,"33":33,"51":51}],9:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * cap stream level to media size dimension controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    var CapLevelController = function (_EventHandler) {
      _inherits(CapLevelController, _EventHandler);
    
      function CapLevelController(hls) {
        _classCallCheck(this, CapLevelController);
    
        return _possibleConstructorReturn(this, (CapLevelController.__proto__ || Object.getPrototypeOf(CapLevelController)).call(this, hls, _events2.default.FPS_DROP_LEVEL_CAPPING, _events2.default.MEDIA_ATTACHING, _events2.default.MANIFEST_PARSED));
      }
    
      _createClass(CapLevelController, [{
        key: 'destroy',
        value: function destroy() {
          if (this.hls.config.capLevelToPlayerSize) {
            this.media = this.restrictedLevels = null;
            this.autoLevelCapping = Number.POSITIVE_INFINITY;
            if (this.timer) {
              this.timer = clearInterval(this.timer);
            }
          }
        }
      }, {
        key: 'onFpsDropLevelCapping',
        value: function onFpsDropLevelCapping(data) {
          if (!this.restrictedLevels) {
            this.restrictedLevels = [];
          }
          if (!this.isLevelRestricted(data.droppedLevel)) {
            this.restrictedLevels.push(data.droppedLevel);
          }
        }
      }, {
        key: 'onMediaAttaching',
        value: function onMediaAttaching(data) {
          this.media = data.media instanceof HTMLVideoElement ? data.media : null;
        }
      }, {
        key: 'onManifestParsed',
        value: function onManifestParsed(data) {
          var hls = this.hls;
          if (hls.config.capLevelToPlayerSize) {
            this.autoLevelCapping = Number.POSITIVE_INFINITY;
            this.levels = data.levels;
            hls.firstLevel = this.getMaxLevel(data.firstLevel);
            clearInterval(this.timer);
            this.timer = setInterval(this.detectPlayerSize.bind(this), 1000);
            this.detectPlayerSize();
          }
        }
      }, {
        key: 'detectPlayerSize',
        value: function detectPlayerSize() {
          if (this.media) {
            var levelsLength = this.levels ? this.levels.length : 0;
            if (levelsLength) {
              var hls = this.hls;
              hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
              if (hls.autoLevelCapping > this.autoLevelCapping) {
                // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch
                // usually happen when the user go to the fullscreen mode.
                hls.streamController.nextLevelSwitch();
              }
              this.autoLevelCapping = hls.autoLevelCapping;
            }
          }
        }
    
        /*
        * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)
        */
    
      }, {
        key: 'getMaxLevel',
        value: function getMaxLevel(capLevelIndex) {
          var result = 0,
              i = void 0,
              level = void 0,
              mWidth = this.mediaWidth,
              mHeight = this.mediaHeight,
              lWidth = 0,
              lHeight = 0;
    
          for (i = 0; i <= capLevelIndex; i++) {
            level = this.levels[i];
            if (this.isLevelRestricted(i)) {
              break;
            }
            result = i;
            lWidth = level.width;
            lHeight = level.height;
            if (mWidth <= lWidth || mHeight <= lHeight) {
              break;
            }
          }
          return result;
        }
      }, {
        key: 'isLevelRestricted',
        value: function isLevelRestricted(level) {
          return this.restrictedLevels && this.restrictedLevels.indexOf(level) !== -1 ? true : false;
        }
      }, {
        key: 'contentScaleFactor',
        get: function get() {
          var pixelRatio = 1;
          try {
            pixelRatio = window.devicePixelRatio;
          } catch (e) {}
          return pixelRatio;
        }
      }, {
        key: 'mediaWidth',
        get: function get() {
          var width = void 0;
          var media = this.media;
          if (media) {
            width = media.width || media.clientWidth || media.offsetWidth;
            width *= this.contentScaleFactor;
          }
          return width;
        }
      }, {
        key: 'mediaHeight',
        get: function get() {
          var height = void 0;
          var media = this.media;
          if (media) {
            height = media.height || media.clientHeight || media.offsetHeight;
            height *= this.contentScaleFactor;
          }
          return height;
        }
      }]);
    
      return CapLevelController;
    }(_eventHandler2.default);
    
    exports.default = CapLevelController;
    
    },{"32":32,"33":33}],10:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _logger = _dereq_(51);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * FPS Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    var FPSController = function (_EventHandler) {
      _inherits(FPSController, _EventHandler);
    
      function FPSController(hls) {
        _classCallCheck(this, FPSController);
    
        return _possibleConstructorReturn(this, (FPSController.__proto__ || Object.getPrototypeOf(FPSController)).call(this, hls, _events2.default.MEDIA_ATTACHING));
      }
    
      _createClass(FPSController, [{
        key: 'destroy',
        value: function destroy() {
          if (this.timer) {
            clearInterval(this.timer);
          }
          this.isVideoPlaybackQualityAvailable = false;
        }
      }, {
        key: 'onMediaAttaching',
        value: function onMediaAttaching(data) {
          var config = this.hls.config;
          if (config.capLevelOnFPSDrop) {
            var video = this.video = data.media instanceof HTMLVideoElement ? data.media : null;
            if (typeof video.getVideoPlaybackQuality === 'function') {
              this.isVideoPlaybackQualityAvailable = true;
            }
            clearInterval(this.timer);
            this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
          }
        }
      }, {
        key: 'checkFPS',
        value: function checkFPS(video, decodedFrames, droppedFrames) {
          var currentTime = performance.now();
          if (decodedFrames) {
            if (this.lastTime) {
              var currentPeriod = currentTime - this.lastTime,
                  currentDropped = droppedFrames - this.lastDroppedFrames,
                  currentDecoded = decodedFrames - this.lastDecodedFrames,
                  droppedFPS = 1000 * currentDropped / currentPeriod,
                  hls = this.hls;
              hls.trigger(_events2.default.FPS_DROP, { currentDropped: currentDropped, currentDecoded: currentDecoded, totalDroppedFrames: droppedFrames });
              if (droppedFPS > 0) {
                //logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));
                if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
                  var currentLevel = hls.currentLevel;
                  _logger.logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);
                  if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                    currentLevel = currentLevel - 1;
                    hls.trigger(_events2.default.FPS_DROP_LEVEL_CAPPING, { level: currentLevel, droppedLevel: hls.currentLevel });
                    hls.autoLevelCapping = currentLevel;
                    hls.streamController.nextLevelSwitch();
                  }
                }
              }
            }
            this.lastTime = currentTime;
            this.lastDroppedFrames = droppedFrames;
            this.lastDecodedFrames = decodedFrames;
          }
        }
      }, {
        key: 'checkFPSInterval',
        value: function checkFPSInterval() {
          var video = this.video;
          if (video) {
            if (this.isVideoPlaybackQualityAvailable) {
              var videoPlaybackQuality = video.getVideoPlaybackQuality();
              this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
            } else {
              this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
            }
          }
        }
      }]);
    
      return FPSController;
    }(_eventHandler2.default);
    
    exports.default = FPSController;
    
    },{"32":32,"33":33,"51":51}],11:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * id3 metadata track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    var ID3TrackController = function (_EventHandler) {
      _inherits(ID3TrackController, _EventHandler);
    
      function ID3TrackController(hls) {
        _classCallCheck(this, ID3TrackController);
    
        var _this = _possibleConstructorReturn(this, (ID3TrackController.__proto__ || Object.getPrototypeOf(ID3TrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_METADATA));
    
        _this.id3Track = undefined;
        _this.media = undefined;
        return _this;
      }
    
      _createClass(ID3TrackController, [{
        key: 'destroy',
        value: function destroy() {
          _eventHandler2.default.prototype.destroy.call(this);
        }
    
        // Add ID3 metatadata text track.
    
      }, {
        key: 'onMediaAttached',
        value: function onMediaAttached(data) {
          this.media = data.media;
          if (!this.media) {
            return;
          }
    
          this.id3Track = this.media.addTextTrack('metadata', 'id3');
          this.id3Track.mode = 'hidden';
        }
      }, {
        key: 'onMediaDetaching',
        value: function onMediaDetaching() {
          this.media = undefined;
        }
      }, {
        key: 'onFragParsingMetadata',
        value: function onFragParsingMetadata(data) {
          var fragment = data.frag;
          var samples = data.samples;
          var startTime = fragment.start;
          var endTime = fragment.start + fragment.duration;
          // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
          if (startTime === endTime) {
            endTime += 0.0001;
          }
    
          // Attempt to recreate Safari functionality by creating
          // WebKitDataCue objects when available and store the decoded
          // ID3 data in the value property of the cue
          var Cue = window.WebKitDataCue || window.VTTCue || window.TextTrackCue;
    
          for (var i = 0; i < samples.length; i++) {
            var id3Frame = this.parseID3Frame(samples[i].data);
            var frame = this.decodeID3Frame(id3Frame);
            if (frame) {
              var cue = new Cue(startTime, endTime, '');
              cue.value = frame;
              this.id3Track.addCue(cue);
            }
          }
        }
      }, {
        key: 'parseID3Frame',
        value: function parseID3Frame(data) {
          if (data.length < 21) {
            return undefined;
          }
    
          /* http://id3.org/id3v2.3.0
          [0]     = 'I'
          [1]     = 'D'
          [2]     = '3'
          [3,4]   = {Version}
          [5]     = {Flags}
          [6-9]   = {ID3 Size}
          [10-13] = {Frame ID}
          [14-17] = {Frame Size}
          [18,19] = {Frame Flags}
          */
          if (data[0] === 73 && // I
          data[1] === 68 && // D
          data[2] === 51) {
            // 3
    
            var type = String.fromCharCode(data[10], data[11], data[12], data[13]);
            data = data.subarray(20);
            return { type: type, data: data };
          }
        }
      }, {
        key: 'decodeID3Frame',
        value: function decodeID3Frame(frame) {
          if (frame.type === 'TXXX') {
            return this.decodeTxxxFrame(frame);
          } else if (frame.type === 'PRIV') {
            return this.decodePrivFrame(frame);
          } else if (frame.type[0] === 'T') {
            return this.decodeTextFrame(frame);
          } else {
            return undefined;
          }
        }
      }, {
        key: 'decodeTxxxFrame',
        value: function decodeTxxxFrame(frame) {
          /*
          Format:
          [0]   = {Text Encoding}
          [1-?] = {Description}\0{Value}
          */
    
          if (frame.size < 2) {
            return undefined;
          }
    
          if (frame.data[0] !== 3) {
            //only support UTF-8
            return undefined;
          }
    
          var index = 1;
          var description = this.utf8ArrayToStr(frame.data.subarray(index));
    
          index += description.length + 1;
          var value = this.utf8ArrayToStr(frame.data.subarray(index));
    
          return { key: 'TXXX', description: description, data: value };
        }
      }, {
        key: 'decodeTextFrame',
        value: function decodeTextFrame(frame) {
          /*
          Format:
          [0]   = {Text Encoding}
          [1-?] = {Value}
          */
    
          if (frame.size < 2) {
            return undefined;
          }
    
          if (frame.data[0] !== 3) {
            //only support UTF-8
            return undefined;
          }
    
          var data = frame.data.subarray(1);
          return { key: frame.type, data: this.utf8ArrayToStr(data) };
        }
      }, {
        key: 'decodePrivFrame',
        value: function decodePrivFrame(frame) {
          /*
          Format: <text string>\0<binary data>
          */
    
          if (frame.size < 2) {
            return undefined;
          }
    
          var owner = this.utf8ArrayToStr(frame.data);
          var privateData = frame.data.subarray(owner.length + 1);
    
          return { key: 'PRIV', info: owner, data: privateData.buffer };
        }
    
        // http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197
        // http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt
        /* utf.js - UTF-8 <=> UTF-16 convertion
         *
         * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
         * Version: 1.0
         * LastModified: Dec 25 1999
         * This library is free.  You can redistribute it and/or modify it.
         */
    
      }, {
        key: 'utf8ArrayToStr',
        value: function utf8ArrayToStr(array) {
    
          var char2 = void 0;
          var char3 = void 0;
          var out = '';
          var i = 0;
          var length = array.length;
    
          while (i < length) {
            var c = array[i++];
            switch (c >> 4) {
              case 0:
                return out;
              case 1:case 2:case 3:case 4:case 5:case 6:case 7:
                // 0xxxxxxx
                out += String.fromCharCode(c);
                break;
              case 12:case 13:
                // 110x xxxx   10xx xxxx
                char2 = array[i++];
                out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
                break;
              case 14:
                // 1110 xxxx  10xx xxxx  10xx xxxx
                char2 = array[i++];
                char3 = array[i++];
                out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 | (char3 & 0x3F) << 0);
                break;
            }
          }
    
          return out;
        }
      }]);
    
      return ID3TrackController;
    }(_eventHandler2.default);
    
    exports.default = ID3TrackController;
    
    },{"32":32,"33":33}],12:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _logger = _dereq_(51);
    
    var _errors = _dereq_(31);
    
    var _bufferHelper = _dereq_(35);
    
    var _bufferHelper2 = _interopRequireDefault(_bufferHelper);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * Level Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    var LevelController = function (_EventHandler) {
      _inherits(LevelController, _EventHandler);
    
      function LevelController(hls) {
        _classCallCheck(this, LevelController);
    
        var _this = _possibleConstructorReturn(this, (LevelController.__proto__ || Object.getPrototypeOf(LevelController)).call(this, hls, _events2.default.MANIFEST_LOADED, _events2.default.LEVEL_LOADED, _events2.default.FRAG_LOADED, _events2.default.ERROR));
    
        _this.ontick = _this.tick.bind(_this);
        _this._manualLevel = -1;
        return _this;
      }
    
      _createClass(LevelController, [{
        key: 'destroy',
        value: function destroy() {
          if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
          }
          this._manualLevel = -1;
        }
      }, {
        key: 'startLoad',
        value: function startLoad() {
          this.canload = true;
          var levels = this._levels;
          // clean up live level details to force reload them, and reset load errors
          if (levels) {
            levels.forEach(function (level) {
              level.loadError = 0;
              var levelDetails = level.details;
              if (levelDetails && levelDetails.live) {
                level.details = undefined;
              }
            });
          }
          // speed up live playlist refresh if timer exists
          if (this.timer) {
            this.tick();
          }
        }
      }, {
        key: 'stopLoad',
        value: function stopLoad() {
          this.canload = false;
        }
      }, {
        key: 'onManifestLoaded',
        value: function onManifestLoaded(data) {
          var levels0 = [],
              levels = [],
              bitrateStart,
              bitrateSet = {},
              videoCodecFound = false,
              audioCodecFound = false,
              hls = this.hls,
              brokenmp4inmp3 = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),
              checkSupported = function checkSupported(type, codec) {
            return MediaSource.isTypeSupported(type + '/mp4;codecs=' + codec);
          };
    
          // regroup redundant level together
          data.levels.forEach(function (level) {
            if (level.videoCodec) {
              videoCodecFound = true;
            }
            // erase audio codec info if browser does not support mp4a.40.34. demuxer will autodetect codec and fallback to mpeg/audio
            if (brokenmp4inmp3 && level.audioCodec && level.audioCodec.indexOf('mp4a.40.34') !== -1) {
              level.audioCodec = undefined;
            }
            if (level.audioCodec || level.attrs && level.attrs.AUDIO) {
              audioCodecFound = true;
            }
            var redundantLevelId = bitrateSet[level.bitrate];
            if (redundantLevelId === undefined) {
              bitrateSet[level.bitrate] = levels0.length;
              level.url = [level.url];
              level.urlId = 0;
              levels0.push(level);
            } else {
              levels0[redundantLevelId].url.push(level.url);
            }
          });
    
          // remove audio-only level if we also have levels with audio+video codecs signalled
          if (videoCodecFound && audioCodecFound) {
            levels0.forEach(function (level) {
              if (level.videoCodec) {
                levels.push(level);
              }
            });
          } else {
            levels = levels0;
          }
          // only keep level with supported audio/video codecs
          levels = levels.filter(function (level) {
            var audioCodec = level.audioCodec,
                videoCodec = level.videoCodec;
            return (!audioCodec || checkSupported('audio', audioCodec)) && (!videoCodec || checkSupported('video', videoCodec));
          });
    
          if (levels.length) {
            // start bitrate is the first bitrate of the manifest
            bitrateStart = levels[0].bitrate;
            // sort level on bitrate
            levels.sort(function (a, b) {
              return a.bitrate - b.bitrate;
            });
            this._levels = levels;
            // find index of first level in sorted levels
            for (var i = 0; i < levels.length; i++) {
              if (levels[i].bitrate === bitrateStart) {
                this._firstLevel = i;
                _logger.logger.log('manifest loaded,' + levels.length + ' level(s) found, first bitrate:' + bitrateStart);
                break;
              }
            }
            hls.trigger(_events2.default.MANIFEST_PARSED, { levels: levels, firstLevel: this._firstLevel, stats: data.stats, audio: audioCodecFound, video: videoCodecFound, altAudio: data.audioTracks.length > 0 });
          } else {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: true, url: hls.url, reason: 'no level with compatible codecs found in manifest' });
          }
          return;
        }
      }, {
        key: 'setLevelInternal',
        value: function setLevelInternal(newLevel) {
          var levels = this._levels;
          var hls = this.hls;
          // check if level idx is valid
          if (newLevel >= 0 && newLevel < levels.length) {
            // stopping live reloading timer if any
            if (this.timer) {
              clearTimeout(this.timer);
              this.timer = null;
            }
            if (this._level !== newLevel) {
              _logger.logger.log('switching to level ' + newLevel);
              this._level = newLevel;
              var levelProperties = levels[newLevel];
              levelProperties.level = newLevel;
              // LEVEL_SWITCH to be deprecated in next major release
              hls.trigger(_events2.default.LEVEL_SWITCH, levelProperties);
              hls.trigger(_events2.default.LEVEL_SWITCHING, levelProperties);
            }
            var level = levels[newLevel],
                levelDetails = level.details;
            // check if we need to load playlist for this level
            if (!levelDetails || levelDetails.live === true) {
              // level not retrieved yet, or live playlist we need to (re)load it
              var urlId = level.urlId;
              hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: newLevel, id: urlId });
            }
          } else {
            // invalid level id given, trigger error
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.LEVEL_SWITCH_ERROR, level: newLevel, fatal: false, reason: 'invalid level idx' });
          }
        }
      }, {
        key: 'onError',
        value: function onError(data) {
          if (data.fatal) {
            return;
          }
    
          var details = data.details,
              hls = this.hls,
              levelId = void 0,
              level = void 0,
              levelError = false;
          // try to recover not fatal errors
          switch (details) {
            case _errors.ErrorDetails.FRAG_LOAD_ERROR:
            case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
            case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
            case _errors.ErrorDetails.KEY_LOAD_ERROR:
            case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
              levelId = data.frag.level;
              break;
            case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
            case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
              levelId = data.context.level;
              levelError = true;
              break;
            case _errors.ErrorDetails.REMUX_ALLOC_ERROR:
              levelId = data.level;
              break;
            default:
              break;
          }
          /* try to switch to a redundant stream if any available.
           * if no redundant stream available, emergency switch down (if in auto mode and current level not 0)
           * otherwise, we cannot recover this network error ...
           */
          if (levelId !== undefined) {
            level = this._levels[levelId];
            if (!level.loadError) {
              level.loadError = 1;
            } else {
              level.loadError++;
            }
            // if any redundant streams available and if we haven't try them all (level.loadError is reseted on successful frag/level load.
            // if level.loadError reaches nbRedundantLevel it means that we tried them all, no hope  => let's switch down
            var nbRedundantLevel = level.url.length;
            if (nbRedundantLevel > 1 && level.loadError < nbRedundantLevel) {
              level.urlId = (level.urlId + 1) % nbRedundantLevel;
              level.details = undefined;
              _logger.logger.warn('level controller,' + details + ' for level ' + levelId + ': switching to redundant stream id ' + level.urlId);
            } else {
              // we could try to recover if in auto mode and current level not lowest level (0)
              var recoverable = this._manualLevel === -1 && levelId;
              if (recoverable) {
                _logger.logger.warn('level controller,' + details + ': switch-down for next fragment');
                hls.nextAutoLevel = Math.max(0, levelId - 1);
              } else if (level && level.details && level.details.live) {
                _logger.logger.warn('level controller,' + details + ' on live stream, discard');
                if (levelError) {
                  // reset this._level so that another call to set level() will retrigger a frag load
                  this._level = undefined;
                }
                // other errors are handled by stream controller
              } else if (details === _errors.ErrorDetails.LEVEL_LOAD_ERROR || details === _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT) {
                var media = hls.media,
    
                // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
                mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);
                if (mediaBuffered) {
                  var retryDelay = hls.config.levelLoadingRetryDelay;
                  _logger.logger.warn('level controller,' + details + ', but media buffered, retry in ' + retryDelay + 'ms');
                  this.timer = setTimeout(this.ontick, retryDelay);
                } else {
                  _logger.logger.error('cannot recover ' + details + ' error');
                  this._level = undefined;
                  // stopping live reloading timer if any
                  if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                  }
                  // switch error to fatal
                  data.fatal = true;
                }
              }
            }
          }
        }
    
        // reset level load error counter on successful frag loaded
    
      }, {
        key: 'onFragLoaded',
        value: function onFragLoaded(data) {
          var fragLoaded = data.frag;
          if (fragLoaded && fragLoaded.type === 'main') {
            var level = this._levels[fragLoaded.level];
            if (level) {
              level.loadError = 0;
            }
          }
        }
      }, {
        key: 'onLevelLoaded',
        value: function onLevelLoaded(data) {
          var levelId = data.level;
          // only process level loaded events matching with expected level
          if (levelId === this._level) {
            var curLevel = this._levels[levelId];
            // reset level load error counter on successful level loaded
            curLevel.loadError = 0;
            var newDetails = data.details;
            // if current playlist is a live playlist, arm a timer to reload it
            if (newDetails.live) {
              var reloadInterval = 1000 * (newDetails.averagetargetduration ? newDetails.averagetargetduration : newDetails.targetduration),
                  curDetails = curLevel.details;
              if (curDetails && newDetails.endSN === curDetails.endSN) {
                // follow HLS Spec, If the client reloads a Playlist file and finds that it has not
                // changed then it MUST wait for a period of one-half the target
                // duration before retrying.
                reloadInterval /= 2;
                _logger.logger.log('same live playlist, reload twice faster');
              }
              // decrement reloadInterval with level loading delay
              reloadInterval -= performance.now() - data.stats.trequest;
              // in any case, don't reload more than every second
              reloadInterval = Math.max(1000, Math.round(reloadInterval));
              _logger.logger.log('live playlist, reload in ' + reloadInterval + ' ms');
              this.timer = setTimeout(this.ontick, reloadInterval);
            } else {
              this.timer = null;
            }
          }
        }
      }, {
        key: 'tick',
        value: function tick() {
          var levelId = this._level;
          if (levelId !== undefined && this.canload) {
            var level = this._levels[levelId];
            if (level && level.url) {
              var urlId = level.urlId;
              this.hls.trigger(_events2.default.LEVEL_LOADING, { url: level.url[urlId], level: levelId, id: urlId });
            }
          }
        }
      }, {
        key: 'levels',
        get: function get() {
          return this._levels;
        }
      }, {
        key: 'level',
        get: function get() {
          return this._level;
        },
        set: function set(newLevel) {
          var levels = this._levels;
          if (levels && levels.length > newLevel) {
            if (this._level !== newLevel || levels[newLevel].details === undefined) {
              this.setLevelInternal(newLevel);
            }
          }
        }
      }, {
        key: 'manualLevel',
        get: function get() {
          return this._manualLevel;
        },
        set: function set(newLevel) {
          this._manualLevel = newLevel;
          if (this._startLevel === undefined) {
            this._startLevel = newLevel;
          }
          if (newLevel !== -1) {
            this.level = newLevel;
          }
        }
      }, {
        key: 'firstLevel',
        get: function get() {
          return this._firstLevel;
        },
        set: function set(newLevel) {
          this._firstLevel = newLevel;
        }
      }, {
        key: 'startLevel',
        get: function get() {
          // hls.startLevel takes precedence over config.startLevel
          // if none of these values are defined, fallback on this._firstLevel (first quality level appearing in variant manifest)
          if (this._startLevel === undefined) {
            var configStartLevel = this.hls.config.startLevel;
            if (configStartLevel !== undefined) {
              return configStartLevel;
            } else {
              return this._firstLevel;
            }
          } else {
            return this._startLevel;
          }
        },
        set: function set(newLevel) {
          this._startLevel = newLevel;
        }
      }, {
        key: 'nextLoadLevel',
        get: function get() {
          if (this._manualLevel !== -1) {
            return this._manualLevel;
          } else {
            return this.hls.nextAutoLevel;
          }
        },
        set: function set(nextLevel) {
          this.level = nextLevel;
          if (this._manualLevel === -1) {
            this.hls.nextAutoLevel = nextLevel;
          }
        }
      }]);
    
      return LevelController;
    }(_eventHandler2.default);
    
    exports.default = LevelController;
    
    },{"31":31,"32":32,"33":33,"35":35,"51":51}],13:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _binarySearch = _dereq_(46);
    
    var _binarySearch2 = _interopRequireDefault(_binarySearch);
    
    var _bufferHelper = _dereq_(35);
    
    var _bufferHelper2 = _interopRequireDefault(_bufferHelper);
    
    var _demuxer = _dereq_(25);
    
    var _demuxer2 = _interopRequireDefault(_demuxer);
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _levelHelper = _dereq_(36);
    
    var _levelHelper2 = _interopRequireDefault(_levelHelper);
    
    var _timeRanges = _dereq_(52);
    
    var _timeRanges2 = _interopRequireDefault(_timeRanges);
    
    var _errors = _dereq_(31);
    
    var _logger = _dereq_(51);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    var State = {
      STOPPED: 'STOPPED',
      IDLE: 'IDLE',
      KEY_LOADING: 'KEY_LOADING',
      FRAG_LOADING: 'FRAG_LOADING',
      FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',
      WAITING_LEVEL: 'WAITING_LEVEL',
      PARSING: 'PARSING',
      PARSED: 'PARSED',
      BUFFER_FLUSHING: 'BUFFER_FLUSHING',
      ENDED: 'ENDED',
      ERROR: 'ERROR'
    };
    
    var StreamController = function (_EventHandler) {
      _inherits(StreamController, _EventHandler);
    
      function StreamController(hls) {
        _classCallCheck(this, StreamController);
    
        var _this = _possibleConstructorReturn(this, (StreamController.__proto__ || Object.getPrototypeOf(StreamController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_PARSED, _events2.default.LEVEL_LOADED, _events2.default.KEY_LOADED, _events2.default.FRAG_LOADED, _events2.default.FRAG_LOAD_EMERGENCY_ABORTED, _events2.default.FRAG_PARSING_INIT_SEGMENT, _events2.default.FRAG_PARSING_DATA, _events2.default.FRAG_PARSED, _events2.default.ERROR, _events2.default.AUDIO_TRACK_SWITCHING, _events2.default.AUDIO_TRACK_SWITCHED, _events2.default.BUFFER_CREATED, _events2.default.BUFFER_APPENDED, _events2.default.BUFFER_FLUSHED));
    
        _this.config = hls.config;
        _this.audioCodecSwap = false;
        _this.ticks = 0;
        _this._state = State.STOPPED;
        _this.ontick = _this.tick.bind(_this);
        return _this;
      }
    
      _createClass(StreamController, [{
        key: 'destroy',
        value: function destroy() {
          this.stopLoad();
          if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
          }
          _eventHandler2.default.prototype.destroy.call(this);
          this.state = State.STOPPED;
        }
      }, {
        key: 'startLoad',
        value: function startLoad(startPosition) {
          if (this.levels) {
            var lastCurrentTime = this.lastCurrentTime,
                hls = this.hls;
            this.stopLoad();
            if (!this.timer) {
              this.timer = setInterval(this.ontick, 100);
            }
            this.level = -1;
            this.fragLoadError = 0;
            if (!this.startFragRequested) {
              // determine load level
              var startLevel = hls.startLevel;
              if (startLevel === -1) {
                // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level
                startLevel = 0;
                this.bitrateTest = true;
              }
              // set new level to playlist loader : this will trigger start level load
              // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded
              this.level = hls.nextLoadLevel = startLevel;
              this.loadedmetadata = false;
            }
            // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime
            if (lastCurrentTime > 0 && startPosition === -1) {
              _logger.logger.log('override startPosition with lastCurrentTime @' + lastCurrentTime.toFixed(3));
              startPosition = lastCurrentTime;
            }
            this.state = State.IDLE;
            this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
            this.tick();
          } else {
            this.forceStartLoad = true;
            this.state = State.STOPPED;
          }
        }
      }, {
        key: 'stopLoad',
        value: function stopLoad() {
          var frag = this.fragCurrent;
          if (frag) {
            if (frag.loader) {
              frag.loader.abort();
            }
            this.fragCurrent = null;
          }
          this.fragPrevious = null;
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = null;
          }
          this.state = State.STOPPED;
          this.forceStartLoad = false;
        }
      }, {
        key: 'tick',
        value: function tick() {
          this.ticks++;
          if (this.ticks === 1) {
            this.doTick();
            if (this.ticks > 1) {
              setTimeout(this.tick, 1);
            }
            this.ticks = 0;
          }
        }
      }, {
        key: 'doTick',
        value: function doTick() {
          switch (this.state) {
            case State.ERROR:
              //don't do anything in error state to avoid breaking further ...
              break;
            case State.BUFFER_FLUSHING:
              // in buffer flushing state, reset fragLoadError counter
              this.fragLoadError = 0;
              break;
            case State.IDLE:
              this._doTickIdle();
              break;
            case State.WAITING_LEVEL:
              var level = this.levels[this.level];
              // check if playlist is already loaded
              if (level && level.details) {
                this.state = State.IDLE;
              }
              break;
            case State.FRAG_LOADING_WAITING_RETRY:
              var now = performance.now();
              var retryDate = this.retryDate;
              // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading
              if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
                _logger.logger.log('mediaController: retryDate reached, switch back to IDLE state');
                this.state = State.IDLE;
              }
              break;
            case State.ERROR:
            case State.STOPPED:
            case State.FRAG_LOADING:
            case State.PARSING:
            case State.PARSED:
            case State.ENDED:
              break;
            default:
              break;
          }
          // check buffer
          this._checkBuffer();
          // check/update current fragment
          this._checkFragmentChanged();
        }
    
        // Ironically the "idle" state is the on we do the most logic in it seems ....
        // NOTE: Maybe we could rather schedule a check for buffer length after half of the currently
        //       played segment, or on pause/play/seek instead of naively checking every 100ms?
    
      }, {
        key: '_doTickIdle',
        value: function _doTickIdle() {
          var hls = this.hls,
              config = hls.config,
              media = this.media;
    
          // if video not attached AND
          // start fragment already requested OR start frag prefetch disable
          // exit loop
          // => if start level loaded and media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop
          if (this.levelLastLoaded !== undefined && !media && (this.startFragRequested || !config.startFragPrefetch)) {
            return;
          }
    
          // if we have not yet loaded any fragment, start loading from start position
          var pos = void 0;
          if (this.loadedmetadata) {
            pos = media.currentTime;
          } else {
            pos = this.nextLoadPosition;
          }
          // determine next load level
          var level = hls.nextLoadLevel,
              levelInfo = this.levels[level],
              levelBitrate = levelInfo.bitrate,
              maxBufLen = void 0;
    
          // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s
          if (levelBitrate) {
            maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
          } else {
            maxBufLen = config.maxBufferLength;
          }
          maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);
    
          // determine next candidate fragment to be loaded, based on current position and end of buffer position
          // ensure up to `config.maxMaxBufferLength` of buffer upfront
    
          var bufferInfo = _bufferHelper2.default.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, config.maxBufferHole),
              bufferLen = bufferInfo.len;
          // Stay idle if we are still with buffer margins
          if (bufferLen >= maxBufLen) {
            return;
          }
    
          // if buffer length is less than maxBufLen try to load a new fragment ...
          _logger.logger.trace('buffer length of ' + bufferLen.toFixed(3) + ' is below max of ' + maxBufLen.toFixed(3) + '. checking for more payload ...');
    
          // set next load level : this will trigger a playlist load if needed
          this.level = hls.nextLoadLevel = level;
    
          var levelDetails = levelInfo.details;
          // if level info not retrieved yet, switch state and wait for level retrieval
          // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load
          // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)
          if (typeof levelDetails === 'undefined' || levelDetails.live && this.levelLastLoaded !== level) {
            this.state = State.WAITING_LEVEL;
            return;
          }
    
          // we just got done loading the final fragment, check if we need to finalize media stream
          var fragPrevious = this.fragPrevious;
          if (!levelDetails.live && fragPrevious && fragPrevious.sn === levelDetails.endSN) {
            // fragPrevious is last fragment. retrieve level duration using last frag start offset + duration
            // real duration might be lower than initial duration if there are drifts between real frag duration and playlist signaling
            var duration = Math.min(media.duration, fragPrevious.start + fragPrevious.duration);
            // if everything (almost) til the end is buffered, let's signal eos
            // we don't compare exactly media.duration === bufferInfo.end as there could be some subtle media duration difference
            // using half frag duration should help cope with these cases.
            // also cope with almost zero last frag duration (max last frag duration with 200ms) refer to https://github.com/video-dev/hls.js/pull/657
            if (duration - Math.max(bufferInfo.end, fragPrevious.start) <= Math.max(0.2, fragPrevious.duration / 2)) {
              // Finalize the media stream
              var data = {};
              if (this.altAudio) {
                data.type = 'video';
              }
              this.hls.trigger(_events2.default.BUFFER_EOS, data);
              this.state = State.ENDED;
              return;
            }
          }
    
          // if we have the levelDetails for the selected variant, lets continue enrichen our stream (load keys/fragments or trigger EOS, etc..)
          this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
        }
      }, {
        key: '_fetchPayloadOrEos',
        value: function _fetchPayloadOrEos(pos, bufferInfo, levelDetails) {
          var fragPrevious = this.fragPrevious,
              level = this.level,
              fragments = levelDetails.fragments,
              fragLen = fragments.length;
    
          // empty playlist
          if (fragLen === 0) {
            return;
          }
    
          // find fragment index, contiguous with end of buffer position
          var start = fragments[0].start,
              end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration,
              bufferEnd = bufferInfo.end,
              frag = void 0;
    
          if (levelDetails.initSegment && !levelDetails.initSegment.data) {
            frag = levelDetails.initSegment;
          } else {
            // in case of live playlist we need to ensure that requested position is not located before playlist start
            if (levelDetails.live) {
              var initialLiveManifestSize = this.config.initialLiveManifestSize;
              if (fragLen < initialLiveManifestSize) {
                _logger.logger.warn('Can not start playback of a level, reason: not enough fragments ' + fragLen + ' < ' + initialLiveManifestSize);
                return;
              }
    
              frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen);
              // if it explicitely returns null don't load any fragment and exit function now
              if (frag === null) {
                return;
              }
            } else {
              // VoD playlist: if bufferEnd before start of playlist, load first fragment
              if (bufferEnd < start) {
                frag = fragments[0];
              }
            }
          }
          if (!frag) {
            frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);
          }
          if (frag) {
            this._loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd);
          }
          return;
        }
      }, {
        key: '_ensureFragmentAtLivePoint',
        value: function _ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments, fragLen) {
          var config = this.hls.config,
              media = this.media;
    
          var frag = void 0;
    
          // check if requested position is within seekable boundaries :
          //logger.log(`start/pos/bufEnd/seeking:${start.toFixed(3)}/${pos.toFixed(3)}/${bufferEnd.toFixed(3)}/${this.media.seeking}`);
          var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
    
          if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
            var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
            _logger.logger.log('buffer end: ' + bufferEnd.toFixed(3) + ' is located too far from the end of live sliding playlist, reset currentTime to : ' + liveSyncPosition.toFixed(3));
            bufferEnd = liveSyncPosition;
            if (media && media.readyState && media.duration > liveSyncPosition) {
              media.currentTime = liveSyncPosition;
            }
          }
    
          // if end of buffer greater than live edge, don't load any fragment
          // this could happen if live playlist intermittently slides in the past.
          // level 1 loaded [182580161,182580167]
          // level 1 loaded [182580162,182580169]
          // Loading 182580168 of [182580162 ,182580169],level 1 ..
          // Loading 182580169 of [182580162 ,182580169],level 1 ..
          // level 1 loaded [182580162,182580168] <============= here we should have bufferEnd > end. in that case break to avoid reloading 182580168
          // level 1 loaded [182580164,182580171]
          //
          // don't return null in case media not loaded yet (readystate === 0)
          if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
            return null;
          }
    
          if (this.startFragRequested && !levelDetails.PTSKnown) {
            /* we are switching level on live playlist, but we don't have any PTS info for that quality level ...
               try to load frag matching with next SN.
               even if SN are not synchronized between playlists, loading this frag will help us
               compute playlist sliding and find the right one after in case it was not the right consecutive one */
            if (fragPrevious) {
              var targetSN = fragPrevious.sn + 1;
              if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
                frag = fragments[targetSN - levelDetails.startSN];
                _logger.logger.log('live playlist, switching playlist, load frag with next SN: ' + frag.sn);
              }
            }
            if (!frag) {
              /* we have no idea about which fragment should be loaded.
                 so let's load mid fragment. it will help computing playlist sliding and find the right one
              */
              frag = fragments[Math.min(fragLen - 1, Math.round(fragLen / 2))];
              _logger.logger.log('live playlist, switching playlist, unknown, load middle frag : ' + frag.sn);
            }
          }
          return frag;
        }
      }, {
        key: '_findFragment',
        value: function _findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails) {
          var config = this.hls.config;
          var frag = void 0;
          var foundFrag = void 0;
          var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
          var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : undefined;
          var fragmentWithinToleranceTest = function fragmentWithinToleranceTest(candidate) {
            // offset should be within fragment boundary - config.maxFragLookUpTolerance
            // this is to cope with situations like
            // bufferEnd = 9.991
            // frag[Ø] : [0,10]
            // frag[1] : [10,20]
            // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here
            //              frag start               frag start+duration
            //                  |-----------------------------|
            //              <--->                         <--->
            //  ...--------><-----------------------------><---------....
            // previous frag         matching fragment         next frag
            //  return -1             return 0                 return 1
            //logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);
            // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments
            var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration);
            if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
              return 1;
            } // if maxFragLookUpTolerance will have negative value then don't return -1 for first element
            else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                return -1;
              }
            return 0;
          };
    
          if (bufferEnd < end) {
            if (bufferEnd > end - maxFragLookUpTolerance) {
              maxFragLookUpTolerance = 0;
            }
            // Prefer the next fragment if it's within tolerance
            if (fragNext && !fragmentWithinToleranceTest(fragNext)) {
              foundFrag = fragNext;
            } else {
              foundFrag = _binarySearch2.default.search(fragments, fragmentWithinToleranceTest);
            }
          } else {
            // reach end of playlist
            foundFrag = fragments[fragLen - 1];
          }
          if (foundFrag) {
            frag = foundFrag;
            var curSNIdx = frag.sn - levelDetails.startSN;
            var sameLevel = fragPrevious && frag.level === fragPrevious.level;
            var prevFrag = fragments[curSNIdx - 1];
            var nextFrag = fragments[curSNIdx + 1];
            //logger.log('find SN matching with pos:' +  bufferEnd + ':' + frag.sn);
            if (sameLevel && frag.sn === fragPrevious.sn) {
              if (frag.sn < levelDetails.endSN) {
                var deltaPTS = fragPrevious.deltaPTS;
                // if there is a significant delta between audio and video, larger than max allowed hole,
                // and if previous remuxed fragment did not start with a keyframe. (fragPrevious.dropped)
                // let's try to load previous fragment again to get last keyframe
                // then we will reload again current fragment (that way we should be able to fill the buffer hole ...)
                if (deltaPTS && deltaPTS > config.maxBufferHole && fragPrevious.dropped && curSNIdx) {
                  frag = prevFrag;
                  _logger.logger.warn('SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this');
                  // decrement previous frag load counter to avoid frag loop loading error when next fragment will get reloaded
                  fragPrevious.loadCounter--;
                } else {
                  frag = nextFrag;
                  _logger.logger.log('SN just loaded, load next one: ' + frag.sn);
                }
              } else {
                frag = null;
              }
            } else if (frag.dropped && !sameLevel) {
              // Only backtrack a max of 1 consecutive fragment to prevent sliding back too far when little or no frags start with keyframes
              if (nextFrag && nextFrag.backtracked) {
                _logger.logger.warn('Already backtracked from fragment ' + (curSNIdx + 1) + ', will not backtrack to fragment ' + curSNIdx + '. Loading fragment ' + (curSNIdx + 1));
                frag = nextFrag;
              } else {
                // If a fragment has dropped frames and it's in a different level/sequence, load the previous fragment to try and find the keyframe
                // Reset the dropped count now since it won't be reset until we parse the fragment again, which prevents infinite backtracking on the same segment
                _logger.logger.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe');
                frag.dropped = 0;
                if (prevFrag) {
                  if (prevFrag.loadCounter) {
                    prevFrag.loadCounter--;
                  }
                  frag = prevFrag;
                } else {
                  frag = null;
                }
              }
            }
          }
          return frag;
        }
      }, {
        key: '_loadFragmentOrKey',
        value: function _loadFragmentOrKey(frag, level, levelDetails, pos, bufferEnd) {
          var hls = this.hls,
              config = hls.config;
    
          //logger.log('loading frag ' + i +',pos/bufEnd:' + pos.toFixed(3) + '/' + bufferEnd.toFixed(3));
          if (frag.decryptdata && frag.decryptdata.uri != null && frag.decryptdata.key == null) {
            _logger.logger.log('Loading key for ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level);
            this.state = State.KEY_LOADING;
            hls.trigger(_events2.default.KEY_LOADING, { frag: frag });
          } else {
            _logger.logger.log('Loading ' + frag.sn + ' of [' + levelDetails.startSN + ' ,' + levelDetails.endSN + '],level ' + level + ', currentTime:' + pos.toFixed(3) + ',bufferEnd:' + bufferEnd.toFixed(3));
            // ensure that we are not reloading the same fragments in loop ...
            if (this.fragLoadIdx !== undefined) {
              this.fragLoadIdx++;
            } else {
              this.fragLoadIdx = 0;
            }
            if (frag.loadCounter) {
              frag.loadCounter++;
              var maxThreshold = config.fragLoadingLoopThreshold;
              // if this frag has already been loaded 3 times, and if it has been reloaded recently
              if (frag.loadCounter > maxThreshold && Math.abs(this.fragLoadIdx - frag.loadIdx) < maxThreshold) {
                hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR, fatal: false, frag: frag });
                return;
              }
            } else {
              frag.loadCounter = 1;
            }
            frag.loadIdx = this.fragLoadIdx;
            this.fragCurrent = frag;
            this.startFragRequested = true;
            if (!isNaN(frag.sn)) {
              this.nextLoadPosition = frag.start + frag.duration;
            }
            frag.autoLevel = hls.autoLevelEnabled;
            frag.bitrateTest = this.bitrateTest;
            hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
            // lazy demuxer init, as this could take some time ... do it during frag loading
            if (!this.demuxer) {
              this.demuxer = new _demuxer2.default(hls, 'main');
            }
            this.state = State.FRAG_LOADING;
            return;
          }
        }
      }, {
        key: 'getBufferedFrag',
        value: function getBufferedFrag(position) {
          return _binarySearch2.default.search(this._bufferedFrags, function (frag) {
            if (position < frag.startPTS) {
              return -1;
            } else if (position > frag.endPTS) {
              return 1;
            }
            return 0;
          });
        }
      }, {
        key: 'followingBufferedFrag',
        value: function followingBufferedFrag(frag) {
          if (frag) {
            // try to get range of next fragment (500ms after this range)
            return this.getBufferedFrag(frag.endPTS + 0.5);
          }
          return null;
        }
      }, {
        key: '_checkFragmentChanged',
        value: function _checkFragmentChanged() {
          var fragPlayingCurrent,
              currentTime,
              video = this.media;
          if (video && video.readyState && video.seeking === false) {
            currentTime = video.currentTime;
            /* if video element is in seeked state, currentTime can only increase.
              (assuming that playback rate is positive ...)
              As sometimes currentTime jumps back to zero after a
              media decode error, check this, to avoid seeking back to
              wrong position after a media decode error
            */
            if (currentTime > video.playbackRate * this.lastCurrentTime) {
              this.lastCurrentTime = currentTime;
            }
            if (_bufferHelper2.default.isBuffered(video, currentTime)) {
              fragPlayingCurrent = this.getBufferedFrag(currentTime);
            } else if (_bufferHelper2.default.isBuffered(video, currentTime + 0.1)) {
              /* ensure that FRAG_CHANGED event is triggered at startup,
                when first video frame is displayed and playback is paused.
                add a tolerance of 100ms, in case current position is not buffered,
                check if current pos+100ms is buffered and use that buffer range
                for FRAG_CHANGED event reporting */
              fragPlayingCurrent = this.getBufferedFrag(currentTime + 0.1);
            }
            if (fragPlayingCurrent) {
              var fragPlaying = fragPlayingCurrent;
              if (fragPlaying !== this.fragPlaying) {
                this.hls.trigger(_events2.default.FRAG_CHANGED, { frag: fragPlaying });
                var fragPlayingLevel = fragPlaying.level;
                if (!this.fragPlaying || this.fragPlaying.level !== fragPlayingLevel) {
                  this.hls.trigger(_events2.default.LEVEL_SWITCHED, { level: fragPlayingLevel });
                }
                this.fragPlaying = fragPlaying;
              }
            }
          }
        }
    
        /*
          on immediate level switch :
           - pause playback if playing
           - cancel any pending load request
           - and trigger a buffer flush
        */
    
      }, {
        key: 'immediateLevelSwitch',
        value: function immediateLevelSwitch() {
          _logger.logger.log('immediateLevelSwitch');
          if (!this.immediateSwitch) {
            this.immediateSwitch = true;
            var media = this.media,
                previouslyPaused = void 0;
            if (media) {
              previouslyPaused = media.paused;
              media.pause();
            } else {
              // don't restart playback after instant level switch in case media not attached
              previouslyPaused = true;
            }
            this.previouslyPaused = previouslyPaused;
          }
          var fragCurrent = this.fragCurrent;
          if (fragCurrent && fragCurrent.loader) {
            fragCurrent.loader.abort();
          }
          this.fragCurrent = null;
          // increase fragment load Index to avoid frag loop loading error after buffer flush
          this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
          // flush everything
          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
        }
    
        /*
           on immediate level switch end, after new fragment has been buffered :
            - nudge video decoder by slightly adjusting video currentTime (if currentTime buffered)
            - resume the playback if needed
        */
    
      }, {
        key: 'immediateLevelSwitchEnd',
        value: function immediateLevelSwitchEnd() {
          var media = this.media;
          if (media && media.buffered.length) {
            this.immediateSwitch = false;
            if (_bufferHelper2.default.isBuffered(media, media.currentTime)) {
              // only nudge if currentTime is buffered
              media.currentTime -= 0.0001;
            }
            if (!this.previouslyPaused) {
              media.play();
            }
          }
        }
      }, {
        key: 'nextLevelSwitch',
        value: function nextLevelSwitch() {
          /* try to switch ASAP without breaking video playback :
             in order to ensure smooth but quick level switching,
            we need to find the next flushable buffer range
            we should take into account new segment fetch time
          */
          var media = this.media;
          // ensure that media is defined and that metadata are available (to retrieve currentTime)
          if (media && media.readyState) {
            var fetchdelay = void 0,
                fragPlayingCurrent = void 0,
                nextBufferedFrag = void 0;
            // increase fragment load Index to avoid frag loop loading error after buffer flush
            this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
            fragPlayingCurrent = this.getBufferedFrag(media.currentTime);
            if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
              // flush buffer preceding current fragment (flush until current fragment start offset)
              // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...
              this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
            }
            if (!media.paused) {
              // add a safety delay of 1s
              var nextLevelId = this.hls.nextLoadLevel,
                  nextLevel = this.levels[nextLevelId],
                  fragLastKbps = this.fragLastKbps;
              if (fragLastKbps && this.fragCurrent) {
                fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1000 * fragLastKbps) + 1;
              } else {
                fetchdelay = 0;
              }
            } else {
              fetchdelay = 0;
            }
            //logger.log('fetchdelay:'+fetchdelay);
            // find buffer range that will be reached once new fragment will be fetched
            nextBufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
            if (nextBufferedFrag) {
              // we can flush buffer range following this one without stalling playback
              nextBufferedFrag = this.followingBufferedFrag(nextBufferedFrag);
              if (nextBufferedFrag) {
                // if we are here, we can also cancel any loading/demuxing in progress, as they are useless
                var fragCurrent = this.fragCurrent;
                if (fragCurrent && fragCurrent.loader) {
                  fragCurrent.loader.abort();
                }
                this.fragCurrent = null;
                // flush position is the start position of this new buffer
                this.flushMainBuffer(nextBufferedFrag.startPTS, Number.POSITIVE_INFINITY);
              }
            }
          }
        }
      }, {
        key: 'flushMainBuffer',
        value: function flushMainBuffer(startOffset, endOffset) {
          this.state = State.BUFFER_FLUSHING;
          var flushScope = { startOffset: startOffset, endOffset: endOffset };
          // if alternate audio tracks are used, only flush video, otherwise flush everything
          if (this.altAudio) {
            flushScope.type = 'video';
          }
          this.hls.trigger(_events2.default.BUFFER_FLUSHING, flushScope);
        }
      }, {
        key: 'onMediaAttached',
        value: function onMediaAttached(data) {
          var media = this.media = this.mediaBuffer = data.media;
          this.onvseeking = this.onMediaSeeking.bind(this);
          this.onvseeked = this.onMediaSeeked.bind(this);
          this.onvended = this.onMediaEnded.bind(this);
          media.addEventListener('seeking', this.onvseeking);
          media.addEventListener('seeked', this.onvseeked);
          media.addEventListener('ended', this.onvended);
          var config = this.config;
          if (this.levels && config.autoStartLoad) {
            this.hls.startLoad(config.startPosition);
          }
        }
      }, {
        key: 'onMediaDetaching',
        value: function onMediaDetaching() {
          var media = this.media;
          if (media && media.ended) {
            _logger.logger.log('MSE detaching and video ended, reset startPosition');
            this.startPosition = this.lastCurrentTime = 0;
          }
    
          // reset fragment loading counter on MSE detaching to avoid reporting FRAG_LOOP_LOADING_ERROR after error recovery
          var levels = this.levels;
          if (levels) {
            // reset fragment load counter
            levels.forEach(function (level) {
              if (level.details) {
                level.details.fragments.forEach(function (fragment) {
                  fragment.loadCounter = undefined;
                  fragment.backtracked = undefined;
                });
              }
            });
          }
          // remove video listeners
          if (media) {
            media.removeEventListener('seeking', this.onvseeking);
            media.removeEventListener('seeked', this.onvseeked);
            media.removeEventListener('ended', this.onvended);
            this.onvseeking = this.onvseeked = this.onvended = null;
          }
          this.media = this.mediaBuffer = null;
          this.loadedmetadata = false;
          this.stopLoad();
        }
      }, {
        key: 'onMediaSeeking',
        value: function onMediaSeeking() {
          var media = this.media,
              currentTime = media ? media.currentTime : undefined,
              config = this.config;
          _logger.logger.log('media seeking to ' + currentTime.toFixed(3));
          if (this.state === State.FRAG_LOADING) {
            var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
            var bufferInfo = _bufferHelper2.default.bufferInfo(mediaBuffer, currentTime, this.config.maxBufferHole),
                fragCurrent = this.fragCurrent;
            // check if we are seeking to a unbuffered area AND if frag loading is in progress
            if (bufferInfo.len === 0 && fragCurrent) {
              var tolerance = config.maxFragLookUpTolerance,
                  fragStartOffset = fragCurrent.start - tolerance,
                  fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
              // check if we seek position will be out of currently loaded frag range : if out cancel frag load, if in, don't do anything
              if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
                if (fragCurrent.loader) {
                  _logger.logger.log('seeking outside of buffer while fragment load in progress, cancel fragment load');
                  fragCurrent.loader.abort();
                }
                this.fragCurrent = null;
                this.fragPrevious = null;
                // switch to IDLE state to load new fragment
                this.state = State.IDLE;
              } else {
                _logger.logger.log('seeking outside of buffer but within currently loaded fragment range');
              }
            }
          } else if (this.state === State.ENDED) {
            // switch to IDLE state to check for potential new fragment
            this.state = State.IDLE;
          }
          if (media) {
            this.lastCurrentTime = currentTime;
          }
          // avoid reporting fragment loop loading error in case user is seeking several times on same position
          if (this.state !== State.FRAG_LOADING && this.fragLoadIdx !== undefined) {
            this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
          }
          // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target
          if (!this.loadedmetadata) {
            this.nextLoadPosition = this.startPosition = currentTime;
          }
          // tick to speed up processing
          this.tick();
        }
      }, {
        key: 'onMediaSeeked',
        value: function onMediaSeeked() {
          _logger.logger.log('media seeked to ' + this.media.currentTime.toFixed(3));
          // tick to speed up FRAGMENT_PLAYING triggering
          this.tick();
        }
      }, {
        key: 'onMediaEnded',
        value: function onMediaEnded() {
          _logger.logger.log('media ended');
          // reset startPosition and lastCurrentTime to restart playback @ stream beginning
          this.startPosition = this.lastCurrentTime = 0;
        }
      }, {
        key: 'onManifestLoading',
        value: function onManifestLoading() {
          // reset buffer on manifest loading
          _logger.logger.log('trigger BUFFER_RESET');
          this.hls.trigger(_events2.default.BUFFER_RESET);
          this._bufferedFrags = [];
          this.stalled = false;
          this.startPosition = this.lastCurrentTime = 0;
        }
      }, {
        key: 'onManifestParsed',
        value: function onManifestParsed(data) {
          var aac = false,
              heaac = false,
              codec;
          data.levels.forEach(function (level) {
            // detect if we have different kind of audio codecs used amongst playlists
            codec = level.audioCodec;
            if (codec) {
              if (codec.indexOf('mp4a.40.2') !== -1) {
                aac = true;
              }
              if (codec.indexOf('mp4a.40.5') !== -1) {
                heaac = true;
              }
            }
          });
          this.audioCodecSwitch = aac && heaac;
          if (this.audioCodecSwitch) {
            _logger.logger.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');
          }
          this.levels = data.levels;
          this.startLevelLoaded = false;
          this.startFragRequested = false;
          var config = this.config;
          if (config.autoStartLoad || this.forceStartLoad) {
            this.hls.startLoad(config.startPosition);
          }
        }
      }, {
        key: 'onLevelLoaded',
        value: function onLevelLoaded(data) {
          var newDetails = data.details,
              newLevelId = data.level,
              curLevel = this.levels[newLevelId],
              duration = newDetails.totalduration,
              sliding = 0;
    
          _logger.logger.log('level ' + newLevelId + ' loaded [' + newDetails.startSN + ',' + newDetails.endSN + '],duration:' + duration);
          this.levelLastLoaded = newLevelId;
    
          if (newDetails.live) {
            var curDetails = curLevel.details;
            if (curDetails && newDetails.fragments.length > 0) {
              // we already have details for that level, merge them
              _levelHelper2.default.mergeDetails(curDetails, newDetails);
              sliding = newDetails.fragments[0].start;
              this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
              if (newDetails.PTSKnown) {
                _logger.logger.log('live playlist sliding:' + sliding.toFixed(3));
              } else {
                _logger.logger.log('live playlist - outdated PTS, unknown sliding');
              }
            } else {
              newDetails.PTSKnown = false;
              _logger.logger.log('live playlist - first load, unknown sliding');
            }
          } else {
            newDetails.PTSKnown = false;
          }
          // override level info
          curLevel.details = newDetails;
          this.hls.trigger(_events2.default.LEVEL_UPDATED, { details: newDetails, level: newLevelId });
    
          if (this.startFragRequested === false) {
            // compute start position if set to -1. use it straight away if value is defined
            if (this.startPosition === -1 || this.lastCurrentTime === -1) {
              // first, check if start time offset has been set in playlist, if yes, use this value
              var startTimeOffset = newDetails.startTimeOffset;
              if (!isNaN(startTimeOffset)) {
                if (startTimeOffset < 0) {
                  _logger.logger.log('negative start time offset ' + startTimeOffset + ', count from end of last fragment');
                  startTimeOffset = sliding + duration + startTimeOffset;
                }
                _logger.logger.log('start time offset found in playlist, adjust startPosition to ' + startTimeOffset);
                this.startPosition = startTimeOffset;
              } else {
                // if live playlist, set start position to be fragment N-this.config.liveSyncDurationCount (usually 3)
                if (newDetails.live) {
                  this.startPosition = this.computeLivePosition(sliding, newDetails);
                  _logger.logger.log('configure startPosition to ' + this.startPosition);
                } else {
                  this.startPosition = 0;
                }
              }
              this.lastCurrentTime = this.startPosition;
            }
            this.nextLoadPosition = this.startPosition;
          }
          // only switch batck to IDLE state if we were waiting for level to start downloading a new fragment
          if (this.state === State.WAITING_LEVEL) {
            this.state = State.IDLE;
          }
          //trigger handler right now
          this.tick();
        }
      }, {
        key: 'onKeyLoaded',
        value: function onKeyLoaded() {
          if (this.state === State.KEY_LOADING) {
            this.state = State.IDLE;
            this.tick();
          }
        }
      }, {
        key: 'onFragLoaded',
        value: function onFragLoaded(data) {
          var fragCurrent = this.fragCurrent,
              fragLoaded = data.frag;
          if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === 'main' && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
            var stats = data.stats,
                currentLevel = this.levels[fragCurrent.level],
                details = currentLevel.details;
            _logger.logger.log('Loaded  ' + fragCurrent.sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + fragCurrent.level);
            // reset frag bitrate test in any case after frag loaded event
            this.bitrateTest = false;
            this.stats = stats;
            // if this frag was loaded to perform a bitrate test AND if hls.nextLoadLevel is greater than 0
            // then this means that we should be able to load a fragment at a higher quality level
            if (fragLoaded.bitrateTest === true && this.hls.nextLoadLevel) {
              // switch back to IDLE state ... we just loaded a fragment to determine adequate start bitrate and initialize autoswitch algo
              this.state = State.IDLE;
              this.startFragRequested = false;
              stats.tparsed = stats.tbuffered = performance.now();
              this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
              this.tick();
            } else if (fragLoaded.sn === 'initSegment') {
              this.state = State.IDLE;
              stats.tparsed = stats.tbuffered = performance.now();
              details.initSegment.data = data.payload;
              this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: fragCurrent, id: 'main' });
              this.tick();
            } else {
              this.state = State.PARSING;
              // transmux the MPEG-TS data to ISO-BMFF segments
              var duration = details.totalduration,
                  level = fragCurrent.level,
                  sn = fragCurrent.sn,
                  audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
              if (this.audioCodecSwap) {
                _logger.logger.log('swapping playlist audio codec');
                if (audioCodec === undefined) {
                  audioCodec = this.lastAudioCodec;
                }
                if (audioCodec) {
                  if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                    audioCodec = 'mp4a.40.2';
                  } else {
                    audioCodec = 'mp4a.40.5';
                  }
                }
              }
              this.pendingBuffering = true;
              this.appended = false;
              _logger.logger.log('Parsing ' + sn + ' of [' + details.startSN + ' ,' + details.endSN + '],level ' + level + ', cc ' + fragCurrent.cc);
              var demuxer = this.demuxer;
              if (!demuxer) {
                demuxer = this.demuxer = new _demuxer2.default(this.hls, 'main');
              }
              // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live) and if media is not seeking (this is to overcome potential timestamp drifts between playlists and fragments)
              var media = this.media;
              var mediaSeeking = media && media.seeking;
              var accurateTimeOffset = !mediaSeeking && (details.PTSKnown || !details.live);
              var initSegmentData = details.initSegment ? details.initSegment.data : [];
              demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, duration, accurateTimeOffset, undefined);
            }
          }
          this.fragLoadError = 0;
        }
      }, {
        key: 'onFragParsingInitSegment',
        value: function onFragParsingInitSegment(data) {
          var fragCurrent = this.fragCurrent;
          var fragNew = data.frag;
          if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
            var tracks = data.tracks,
                trackName,
                track;
    
            // if audio track is expected to come from audio stream controller, discard any coming from main
            if (tracks.audio && this.altAudio) {
              delete tracks.audio;
            }
            // include levelCodec in audio and video tracks
            track = tracks.audio;
            if (track) {
              var audioCodec = this.levels[this.level].audioCodec,
                  ua = navigator.userAgent.toLowerCase();
              if (audioCodec && this.audioCodecSwap) {
                _logger.logger.log('swapping playlist audio codec');
                if (audioCodec.indexOf('mp4a.40.5') !== -1) {
                  audioCodec = 'mp4a.40.2';
                } else {
                  audioCodec = 'mp4a.40.5';
                }
              }
              // in case AAC and HE-AAC audio codecs are signalled in manifest
              // force HE-AAC , as it seems that most browsers prefers that way,
              // except for mono streams OR on FF
              // these conditions might need to be reviewed ...
              if (this.audioCodecSwitch) {
                // don't force HE-AAC if mono stream
                if (track.metadata.channelCount !== 1 &&
                // don't force HE-AAC if firefox
                ua.indexOf('firefox') === -1) {
                  audioCodec = 'mp4a.40.5';
                }
              }
              // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise
              if (ua.indexOf('android') !== -1 && track.container !== 'audio/mpeg') {
                // Exclude mpeg audio
                audioCodec = 'mp4a.40.2';
                _logger.logger.log('Android: force audio codec to ' + audioCodec);
              }
              track.levelCodec = audioCodec;
              track.id = data.id;
            }
            track = tracks.video;
            if (track) {
              track.levelCodec = this.levels[this.level].videoCodec;
              track.id = data.id;
            }
            this.hls.trigger(_events2.default.BUFFER_CODECS, tracks);
            // loop through tracks that are going to be provided to bufferController
            for (trackName in tracks) {
              track = tracks[trackName];
              _logger.logger.log('main track:' + trackName + ',container:' + track.container + ',codecs[level/parsed]=[' + track.levelCodec + '/' + track.codec + ']');
              var initSegment = track.initSegment;
              if (initSegment) {
                this.appended = true;
                // arm pending Buffering flag before appending a segment
                this.pendingBuffering = true;
                this.hls.trigger(_events2.default.BUFFER_APPENDING, { type: trackName, data: initSegment, parent: 'main', content: 'initSegment' });
              }
            }
            //trigger handler right now
            this.tick();
          }
        }
      }, {
        key: 'onFragParsingData',
        value: function onFragParsingData(data) {
          var _this2 = this;
    
          var fragCurrent = this.fragCurrent;
          var fragNew = data.frag;
          if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && !(data.type === 'audio' && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
          this.state === State.PARSING) {
            var level = this.levels[this.level],
                frag = fragCurrent;
            if (isNaN(data.endPTS)) {
              data.endPTS = data.startPTS + fragCurrent.duration;
              data.endDTS = data.startDTS + fragCurrent.duration;
            }
    
            _logger.logger.log('Parsed ' + data.type + ',PTS:[' + data.startPTS.toFixed(3) + ',' + data.endPTS.toFixed(3) + '],DTS:[' + data.startDTS.toFixed(3) + '/' + data.endDTS.toFixed(3) + '],nb:' + data.nb + ',dropped:' + (data.dropped || 0));
    
            // Detect gaps in a fragment  and try to fix it by finding a keyframe in the previous fragment (see _findFragments)
            if (data.type === 'video') {
              frag.dropped = data.dropped;
              if (frag.dropped) {
                if (!frag.backtracked) {
                  // Return back to the IDLE state without appending to buffer
                  // Causes findFragments to backtrack a segment and find the keyframe
                  // Audio fragments arriving before video sets the nextLoadPosition, causing _findFragments to skip the backtracked fragment
                  frag.backtracked = true;
                  this.nextLoadPosition = data.startPTS;
                  this.state = State.IDLE;
                  this.tick();
                  return;
                } else {
                  _logger.logger.warn('Already backtracked on this fragment, appending with the gap');
                }
              } else {
                // Only reset the backtracked flag if we've loaded the frag without any dropped frames
                frag.backtracked = false;
              }
            }
    
            var drift = _levelHelper2.default.updateFragPTSDTS(level.details, frag, data.startPTS, data.endPTS, data.startDTS, data.endDTS),
                hls = this.hls;
            hls.trigger(_events2.default.LEVEL_PTS_UPDATED, { details: level.details, level: this.level, drift: drift, type: data.type, start: data.startPTS, end: data.endPTS });
    
            // has remuxer dropped video frames located before first keyframe ?
            [data.data1, data.data2].forEach(function (buffer) {
              // only append in PARSING state (rationale is that an appending error could happen synchronously on first segment appending)
              // in that case it is useless to append following segments
              if (buffer && buffer.length && _this2.state === State.PARSING) {
                _this2.appended = true;
                // arm pending Buffering flag before appending a segment
                _this2.pendingBuffering = true;
                hls.trigger(_events2.default.BUFFER_APPENDING, { type: data.type, data: buffer, parent: 'main', content: 'data' });
              }
            });
            //trigger handler right now
            this.tick();
          }
        }
      }, {
        key: 'onFragParsed',
        value: function onFragParsed(data) {
          var fragCurrent = this.fragCurrent;
          var fragNew = data.frag;
          if (fragCurrent && data.id === 'main' && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
            this.stats.tparsed = performance.now();
            this.state = State.PARSED;
            this._checkAppendedParsed();
          }
        }
      }, {
        key: 'onAudioTrackSwitching',
        value: function onAudioTrackSwitching(data) {
          // if any URL found on new audio track, it is an alternate audio track
          var altAudio = !!data.url,
              trackId = data.id;
          // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered
          // don't do anything if we switch to alt audio: audio stream controller is handling it.
          // we will just have to change buffer scheduling on audioTrackSwitched
          if (!altAudio) {
            if (this.mediaBuffer !== this.media) {
              _logger.logger.log('switching on main audio, use media.buffered to schedule main fragment loading');
              this.mediaBuffer = this.media;
              var fragCurrent = this.fragCurrent;
              // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch
              if (fragCurrent.loader) {
                _logger.logger.log('switching to main audio track, cancel main fragment load');
                fragCurrent.loader.abort();
              }
              this.fragCurrent = null;
              this.fragPrevious = null;
              // destroy demuxer to force init segment generation (following audio switch)
              if (this.demuxer) {
                this.demuxer.destroy();
                this.demuxer = null;
              }
              // switch to IDLE state to load new fragment
              this.state = State.IDLE;
            }
            var hls = this.hls;
            // switching to main audio, flush all audio and trigger track switched
            hls.trigger(_events2.default.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' });
            hls.trigger(_events2.default.AUDIO_TRACK_SWITCHED, { id: trackId });
            this.altAudio = false;
          }
        }
      }, {
        key: 'onAudioTrackSwitched',
        value: function onAudioTrackSwitched(data) {
          var trackId = data.id,
              altAudio = !!this.hls.audioTracks[trackId].url;
          if (altAudio) {
            var videoBuffer = this.videoBuffer;
            // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered
            if (videoBuffer && this.mediaBuffer !== videoBuffer) {
              _logger.logger.log('switching on alternate audio, use video.buffered to schedule main fragment loading');
              this.mediaBuffer = videoBuffer;
            }
          }
          this.altAudio = altAudio;
          this.tick();
        }
      }, {
        key: 'onBufferCreated',
        value: function onBufferCreated(data) {
          var tracks = data.tracks,
              mediaTrack = void 0,
              name = void 0,
              alternate = false;
          for (var type in tracks) {
            var track = tracks[type];
            if (track.id === 'main') {
              name = type;
              mediaTrack = track;
              // keep video source buffer reference
              if (type === 'video') {
                this.videoBuffer = tracks[type].buffer;
              }
            } else {
              alternate = true;
            }
          }
          if (alternate && mediaTrack) {
            _logger.logger.log('alternate track found, use ' + name + '.buffered to schedule main fragment loading');
            this.mediaBuffer = mediaTrack.buffer;
          } else {
            this.mediaBuffer = this.media;
          }
        }
      }, {
        key: 'onBufferAppended',
        value: function onBufferAppended(data) {
          if (data.parent === 'main') {
            var state = this.state;
            if (state === State.PARSING || state === State.PARSED) {
              // check if all buffers have been appended
              this.pendingBuffering = data.pending > 0;
              this._checkAppendedParsed();
            }
          }
        }
      }, {
        key: '_checkAppendedParsed',
        value: function _checkAppendedParsed() {
          //trigger handler right now
          if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {
            var frag = this.fragCurrent;
            if (frag) {
              var media = this.mediaBuffer ? this.mediaBuffer : this.media;
              _logger.logger.log('main buffered : ' + _timeRanges2.default.toString(media.buffered));
              // filter fragments potentially evicted from buffer. this is to avoid memleak on live streams
              var bufferedFrags = this._bufferedFrags.filter(function (frag) {
                return _bufferHelper2.default.isBuffered(media, (frag.startPTS + frag.endPTS) / 2);
              });
              // push new range
              bufferedFrags.push(frag);
              // sort frags, as we use BinarySearch for lookup in getBufferedFrag ...
              this._bufferedFrags = bufferedFrags.sort(function (a, b) {
                return a.startPTS - b.startPTS;
              });
              this.fragPrevious = frag;
              var stats = this.stats;
              stats.tbuffered = performance.now();
              // we should get rid of this.fragLastKbps
              this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
              this.hls.trigger(_events2.default.FRAG_BUFFERED, { stats: stats, frag: frag, id: 'main' });
              this.state = State.IDLE;
            }
            this.tick();
          }
        }
      }, {
        key: 'onError',
        value: function onError(data) {
          var frag = data.frag || this.fragCurrent;
          // don't handle frag error not related to main fragment
          if (frag && frag.type !== 'main') {
            return;
          }
          var media = this.media,
    
          // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end
          mediaBuffered = media && _bufferHelper2.default.isBuffered(media, media.currentTime) && _bufferHelper2.default.isBuffered(media, media.currentTime + 0.5);
          switch (data.details) {
            case _errors.ErrorDetails.FRAG_LOAD_ERROR:
            case _errors.ErrorDetails.FRAG_LOAD_TIMEOUT:
            case _errors.ErrorDetails.KEY_LOAD_ERROR:
            case _errors.ErrorDetails.KEY_LOAD_TIMEOUT:
              if (!data.fatal) {
                var loadError = this.fragLoadError;
                if (loadError) {
                  loadError++;
                } else {
                  loadError = 1;
                }
                var config = this.config;
                // keep retrying / don't raise fatal network error if current position is buffered or if in automode with current level not 0
                if (loadError <= config.fragLoadingMaxRetry || mediaBuffered || frag.autoLevel && frag.level) {
                  this.fragLoadError = loadError;
                  // reset load counter to avoid frag loop loading error
                  frag.loadCounter = 0;
                  // exponential backoff capped to config.fragLoadingMaxRetryTimeout
                  var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
                  _logger.logger.warn('mediaController: frag loading failed, retry in ' + delay + ' ms');
                  this.retryDate = performance.now() + delay;
                  // retry loading state
                  // if loadedmetadata is not set, it means that we are emergency switch down on first frag
                  // in that case, reset startFragRequested flag
                  if (!this.loadedmetadata) {
                    this.startFragRequested = false;
                    this.nextLoadPosition = this.startPosition;
                  }
                  this.state = State.FRAG_LOADING_WAITING_RETRY;
                } else {
                  _logger.logger.error('mediaController: ' + data.details + ' reaches max retry, redispatch as fatal ...');
                  // switch error to fatal
                  data.fatal = true;
                  this.state = State.ERROR;
                }
              }
              break;
            case _errors.ErrorDetails.FRAG_LOOP_LOADING_ERROR:
              if (!data.fatal) {
                // if buffer is not empty
                if (mediaBuffered) {
                  // try to reduce max buffer length : rationale is that we could get
                  // frag loop loading error because of buffer eviction
                  this._reduceMaxBufferLength(frag.duration);
                  this.state = State.IDLE;
                } else {
                  // buffer empty. report as fatal if in manual mode or if lowest level.
                  // level controller takes care of emergency switch down logic
                  if (!frag.autoLevel || frag.level === 0) {
                    // switch error to fatal
                    data.fatal = true;
                    this.state = State.ERROR;
                  }
                }
              }
              break;
            case _errors.ErrorDetails.LEVEL_LOAD_ERROR:
            case _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT:
              if (this.state !== State.ERROR) {
                if (data.fatal) {
                  // if fatal error, stop processing
                  this.state = State.ERROR;
                  _logger.logger.warn('streamController: ' + data.details + ',switch to ' + this.state + ' state ...');
                } else {
                  // in cas of non fatal error while waiting level load to be completed, switch back to IDLE
                  if (this.state === State.WAITING_LEVEL) {
                    this.state = State.IDLE;
                  }
                }
              }
              break;
            case _errors.ErrorDetails.BUFFER_FULL_ERROR:
              // if in appending state
              if (data.parent === 'main' && (this.state === State.PARSING || this.state === State.PARSED)) {
                // reduce max buf len if current position is buffered
                if (mediaBuffered) {
                  this._reduceMaxBufferLength(this.config.maxBufferLength);
                  this.state = State.IDLE;
                } else {
                  // current position is not buffered, but browser is still complaining about buffer full error
                  // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708
                  // in that case flush the whole buffer to recover
                  _logger.logger.warn('buffer full error also media.currentTime is not buffered, flush everything');
                  this.fragCurrent = null;
                  // flush everything
                  this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                }
              }
              break;
            default:
              break;
          }
        }
      }, {
        key: '_reduceMaxBufferLength',
        value: function _reduceMaxBufferLength(minLength) {
          var config = this.config;
          if (config.maxMaxBufferLength >= minLength) {
            // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...
            config.maxMaxBufferLength /= 2;
            _logger.logger.warn('main:reduce max buffer length to ' + config.maxMaxBufferLength + 's');
            // increase fragment load Index to avoid frag loop loading error after buffer flush
            this.fragLoadIdx += 2 * config.fragLoadingLoopThreshold;
          }
        }
      }, {
        key: '_checkBuffer',
        value: function _checkBuffer() {
          var media = this.media;
          // if ready state different from HAVE_NOTHING (numeric value 0), we are allowed to seek
          if (media && media.readyState) {
            var currentTime = media.currentTime,
                mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media,
                buffered = mediaBuffer.buffered;
            // adjust currentTime to start position on loaded metadata
            if (!this.loadedmetadata && buffered.length) {
              this.loadedmetadata = true;
              // only adjust currentTime if different from startPosition or if startPosition not buffered
              // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered
              var startPosition = media.seeking ? currentTime : this.startPosition,
                  startPositionBuffered = _bufferHelper2.default.isBuffered(mediaBuffer, startPosition);
              // if currentTime not matching with expected startPosition or startPosition not buffered
              if (currentTime !== startPosition || !startPositionBuffered) {
                _logger.logger.log('target start position:' + startPosition);
                // if startPosition not buffered, let's seek to buffered.start(0)
                if (!startPositionBuffered) {
                  startPosition = buffered.start(0);
                  _logger.logger.log('target start position not buffered, seek to buffered.start(0) ' + startPosition);
                }
                _logger.logger.log('adjust currentTime from ' + currentTime + ' to ' + startPosition);
                media.currentTime = startPosition;
              }
            } else if (this.immediateSwitch) {
              this.immediateLevelSwitchEnd();
            } else {
              var bufferInfo = _bufferHelper2.default.bufferInfo(media, currentTime, 0),
                  expectedPlaying = !(media.paused || // not playing when media is paused
              media.ended || // not playing when media is ended
              media.buffered.length === 0),
                  // not playing if nothing buffered
              jumpThreshold = 0.5,
                  // tolerance needed as some browsers stalls playback before reaching buffered range end
              playheadMoving = currentTime !== this.lastCurrentTime,
                  config = this.config;
    
              if (playheadMoving) {
                // played moving, but was previously stalled => now not stuck anymore
                if (this.stallReported) {
                  _logger.logger.warn('playback not stuck anymore @' + currentTime + ', after ' + Math.round(performance.now() - this.stalled) + 'ms');
                  this.stallReported = false;
                }
                this.stalled = undefined;
                this.nudgeRetry = 0;
              } else {
                // playhead not moving
                if (expectedPlaying) {
                  // playhead not moving BUT media expected to play
                  var tnow = performance.now();
                  var hls = this.hls;
                  if (!this.stalled) {
                    // stall just detected, store current time
                    this.stalled = tnow;
                    this.stallReported = false;
                  } else {
                    // playback already stalled, check stalling duration
                    // if stalling for more than a given threshold, let's try to recover
                    var stalledDuration = tnow - this.stalled;
                    var bufferLen = bufferInfo.len;
                    var nudgeRetry = this.nudgeRetry || 0;
                    // have we reached stall deadline ?
                    if (bufferLen <= jumpThreshold && stalledDuration > config.lowBufferWatchdogPeriod * 1000) {
                      // report stalled error once
                      if (!this.stallReported) {
                        this.stallReported = true;
                        _logger.logger.warn('playback stalling in low buffer @' + currentTime);
                        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });
                      }
                      // if buffer len is below threshold, try to jump to start of next buffer range if close
                      // no buffer available @ currentTime, check if next buffer is close (within a config.maxSeekHole second range)
                      var nextBufferStart = bufferInfo.nextStart,
                          delta = nextBufferStart - currentTime;
                      if (nextBufferStart && delta < config.maxSeekHole && delta > 0) {
                        this.nudgeRetry = ++nudgeRetry;
                        var nudgeOffset = nudgeRetry * config.nudgeOffset;
                        // next buffer is close ! adjust currentTime to nextBufferStart
                        // this will ensure effective video decoding
                        _logger.logger.log('adjust currentTime from ' + media.currentTime + ' to next buffered @ ' + nextBufferStart + ' + nudge ' + nudgeOffset);
                        media.currentTime = nextBufferStart + nudgeOffset;
                        // reset stalled so to rearm watchdog timer
                        this.stalled = undefined;
                        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_SEEK_OVER_HOLE, fatal: false, hole: nextBufferStart + nudgeOffset - currentTime });
                      }
                    } else if (bufferLen > jumpThreshold && stalledDuration > config.highBufferWatchdogPeriod * 1000) {
                      // report stalled error once
                      if (!this.stallReported) {
                        this.stallReported = true;
                        _logger.logger.warn('playback stalling in high buffer @' + currentTime);
                        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: false, buffer: bufferLen });
                      }
                      // reset stalled so to rearm watchdog timer
                      this.stalled = undefined;
                      this.nudgeRetry = ++nudgeRetry;
                      if (nudgeRetry < config.nudgeMaxRetry) {
                        var _currentTime = media.currentTime;
                        var targetTime = _currentTime + nudgeRetry * config.nudgeOffset;
                        _logger.logger.log('adjust currentTime from ' + _currentTime + ' to ' + targetTime);
                        // playback stalled in buffered area ... let's nudge currentTime to try to overcome this
                        media.currentTime = targetTime;
                        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_NUDGE_ON_STALL, fatal: false });
                      } else {
                        _logger.logger.error('still stuck in high buffer @' + currentTime + ' after ' + config.nudgeMaxRetry + ', raise fatal error');
                        hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.BUFFER_STALLED_ERROR, fatal: true });
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }, {
        key: 'onFragLoadEmergencyAborted',
        value: function onFragLoadEmergencyAborted() {
          this.state = State.IDLE;
          // if loadedmetadata is not set, it means that we are emergency switch down on first frag
          // in that case, reset startFragRequested flag
          if (!this.loadedmetadata) {
            this.startFragRequested = false;
            this.nextLoadPosition = this.startPosition;
          }
          this.tick();
        }
      }, {
        key: 'onBufferFlushed',
        value: function onBufferFlushed() {
          /* after successful buffer flushing, filter flushed fragments from bufferedFrags
            use mediaBuffered instead of media (so that we will check against video.buffered ranges in case of alt audio track)
          */
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          this._bufferedFrags = this._bufferedFrags.filter(function (frag) {
            return _bufferHelper2.default.isBuffered(media, (frag.startPTS + frag.endPTS) / 2);
          });
    
          // increase fragment load Index to avoid frag loop loading error after buffer flush
          this.fragLoadIdx += 2 * this.config.fragLoadingLoopThreshold;
          // move to IDLE once flush complete. this should trigger new fragment loading
          this.state = State.IDLE;
          // reset reference to frag
          this.fragPrevious = null;
        }
      }, {
        key: 'swapAudioCodec',
        value: function swapAudioCodec() {
          this.audioCodecSwap = !this.audioCodecSwap;
        }
      }, {
        key: 'computeLivePosition',
        value: function computeLivePosition(sliding, levelDetails) {
          var targetLatency = this.config.liveSyncDuration !== undefined ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
          return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
        }
      }, {
        key: 'state',
        set: function set(nextState) {
          if (this.state !== nextState) {
            var previousState = this.state;
            this._state = nextState;
            _logger.logger.log('main stream:' + previousState + '->' + nextState);
            this.hls.trigger(_events2.default.STREAM_STATE_TRANSITION, { previousState: previousState, nextState: nextState });
          }
        },
        get: function get() {
          return this._state;
        }
      }, {
        key: 'currentLevel',
        get: function get() {
          var media = this.media;
          if (media) {
            var frag = this.getBufferedFrag(media.currentTime);
            if (frag) {
              return frag.level;
            }
          }
          return -1;
        }
      }, {
        key: 'nextBufferedFrag',
        get: function get() {
          var media = this.media;
          if (media) {
            // first get end range of current fragment
            return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));
          } else {
            return null;
          }
        }
      }, {
        key: 'nextLevel',
        get: function get() {
          var frag = this.nextBufferedFrag;
          if (frag) {
            return frag.level;
          } else {
            return -1;
          }
        }
      }, {
        key: 'liveSyncPosition',
        get: function get() {
          return this._liveSyncPosition;
        },
        set: function set(value) {
          this._liveSyncPosition = value;
        }
      }]);
    
      return StreamController;
    }(_eventHandler2.default);
    
    exports.default = StreamController;
    
    },{"25":25,"31":31,"32":32,"33":33,"35":35,"36":36,"46":46,"51":51,"52":52}],14:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _logger = _dereq_(51);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * Subtitle Stream Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    var SubtitleStreamController = function (_EventHandler) {
      _inherits(SubtitleStreamController, _EventHandler);
    
      function SubtitleStreamController(hls) {
        _classCallCheck(this, SubtitleStreamController);
    
        var _this = _possibleConstructorReturn(this, (SubtitleStreamController.__proto__ || Object.getPrototypeOf(SubtitleStreamController)).call(this, hls, _events2.default.ERROR, _events2.default.SUBTITLE_TRACKS_UPDATED, _events2.default.SUBTITLE_TRACK_SWITCH, _events2.default.SUBTITLE_TRACK_LOADED, _events2.default.SUBTITLE_FRAG_PROCESSED));
    
        _this.config = hls.config;
        _this.vttFragSNsProcessed = {};
        _this.vttFragQueues = undefined;
        _this.currentlyProcessing = null;
        _this.currentTrackId = -1;
        return _this;
      }
    
      _createClass(SubtitleStreamController, [{
        key: 'destroy',
        value: function destroy() {
          _eventHandler2.default.prototype.destroy.call(this);
        }
    
        // Remove all queued items and create a new, empty queue for each track.
    
      }, {
        key: 'clearVttFragQueues',
        value: function clearVttFragQueues() {
          var _this2 = this;
    
          this.vttFragQueues = {};
          this.tracks.forEach(function (track) {
            _this2.vttFragQueues[track.id] = [];
          });
        }
    
        // If no frag is being processed and queue isn't empty, initiate processing of next frag in line.
    
      }, {
        key: 'nextFrag',
        value: function nextFrag() {
          if (this.currentlyProcessing === null && this.currentTrackId > -1 && this.vttFragQueues[this.currentTrackId].length) {
            var frag = this.currentlyProcessing = this.vttFragQueues[this.currentTrackId].shift();
            this.hls.trigger(_events2.default.FRAG_LOADING, { frag: frag });
          }
        }
    
        // When fragment has finished processing, add sn to list of completed if successful.
    
      }, {
        key: 'onSubtitleFragProcessed',
        value: function onSubtitleFragProcessed(data) {
          if (data.success) {
            this.vttFragSNsProcessed[data.frag.trackId].push(data.frag.sn);
          }
          this.currentlyProcessing = null;
          this.nextFrag();
        }
    
        // If something goes wrong, procede to next frag, if we were processing one.
    
      }, {
        key: 'onError',
        value: function onError(data) {
          var frag = data.frag;
          // don't handle frag error not related to subtitle fragment
          if (frag && frag.type !== 'subtitle') {
            return;
          }
          if (this.currentlyProcessing) {
            this.currentlyProcessing = null;
            this.nextFrag();
          }
        }
    
        // Got all new subtitle tracks.
    
      }, {
        key: 'onSubtitleTracksUpdated',
        value: function onSubtitleTracksUpdated(data) {
          var _this3 = this;
    
          _logger.logger.log('subtitle tracks updated');
          this.tracks = data.subtitleTracks;
          this.clearVttFragQueues();
          this.vttFragSNsProcessed = {};
          this.tracks.forEach(function (track) {
            _this3.vttFragSNsProcessed[track.id] = [];
          });
        }
      }, {
        key: 'onSubtitleTrackSwitch',
        value: function onSubtitleTrackSwitch(data) {
          this.currentTrackId = data.id;
          this.clearVttFragQueues();
        }
    
        // Got a new set of subtitle fragments.
    
      }, {
        key: 'onSubtitleTrackLoaded',
        value: function onSubtitleTrackLoaded(data) {
          var processedFragSNs = this.vttFragSNsProcessed[data.id],
              fragQueue = this.vttFragQueues[data.id],
              currentFragSN = !!this.currentlyProcessing ? this.currentlyProcessing.sn : -1;
    
          var alreadyProcessed = function alreadyProcessed(frag) {
            return processedFragSNs.indexOf(frag.sn) > -1;
          };
    
          var alreadyInQueue = function alreadyInQueue(frag) {
            return fragQueue.some(function (fragInQueue) {
              return fragInQueue.sn === frag.sn;
            });
          };
    
          // Add all fragments that haven't been, aren't currently being and aren't waiting to be processed, to queue.
          data.details.fragments.forEach(function (frag) {
            if (!(alreadyProcessed(frag) || frag.sn === currentFragSN || alreadyInQueue(frag))) {
              // Frags don't know their subtitle track ID, so let's just add that...
              frag.trackId = data.id;
              fragQueue.push(frag);
            }
          });
    
          this.nextFrag();
        }
      }]);
    
      return SubtitleStreamController;
    }(_eventHandler2.default);
    
    exports.default = SubtitleStreamController;
    
    },{"32":32,"33":33,"51":51}],15:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _logger = _dereq_(51);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * audio track controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    function filterSubtitleTracks(textTrackList) {
      var tracks = [];
      for (var i = 0; i < textTrackList.length; i++) {
        if (textTrackList[i].kind === 'subtitles') {
          tracks.push(textTrackList[i]);
        }
      }
      return tracks;
    }
    
    var SubtitleTrackController = function (_EventHandler) {
      _inherits(SubtitleTrackController, _EventHandler);
    
      function SubtitleTrackController(hls) {
        _classCallCheck(this, SubtitleTrackController);
    
        var _this = _possibleConstructorReturn(this, (SubtitleTrackController.__proto__ || Object.getPrototypeOf(SubtitleTrackController)).call(this, hls, _events2.default.MEDIA_ATTACHED, _events2.default.MEDIA_DETACHING, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.SUBTITLE_TRACK_LOADED));
    
        _this.tracks = [];
        _this.trackId = -1;
        _this.media = undefined;
        return _this;
      }
    
      _createClass(SubtitleTrackController, [{
        key: 'destroy',
        value: function destroy() {
          _eventHandler2.default.prototype.destroy.call(this);
        }
    
        // Listen for subtitle track change, then extract the current track ID.
    
      }, {
        key: 'onMediaAttached',
        value: function onMediaAttached(data) {
          var _this2 = this;
    
          this.media = data.media;
          if (!this.media) {
            return;
          }
    
          this.media.textTracks.addEventListener('change', function () {
            // Media is undefined when switching streams via loadSource()
            if (!_this2.media) {
              return;
            }
    
            var trackId = -1;
            var tracks = filterSubtitleTracks(_this2.media.textTracks);
            for (var id = 0; id < tracks.length; id++) {
              if (tracks[id].mode === 'showing') {
                trackId = id;
              }
            }
            // Setting current subtitleTrack will invoke code.
            _this2.subtitleTrack = trackId;
          });
        }
      }, {
        key: 'onMediaDetaching',
        value: function onMediaDetaching() {
          // TODO: Remove event listeners.
          this.media = undefined;
        }
    
        // Reset subtitle tracks on manifest loading
    
      }, {
        key: 'onManifestLoading',
        value: function onManifestLoading() {
          this.tracks = [];
          this.trackId = -1;
        }
    
        // Fired whenever a new manifest is loaded.
    
      }, {
        key: 'onManifestLoaded',
        value: function onManifestLoaded(data) {
          var _this3 = this;
    
          var tracks = data.subtitles || [];
          var defaultFound = false;
          this.tracks = tracks;
          this.trackId = -1;
          this.hls.trigger(_events2.default.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: tracks });
    
          // loop through available subtitle tracks and autoselect default if needed
          // TODO: improve selection logic to handle forced, etc
          tracks.forEach(function (track) {
            if (track.default) {
              _this3.subtitleTrack = track.id;
              defaultFound = true;
            }
          });
        }
    
        // Trigger subtitle track playlist reload.
    
      }, {
        key: 'onTick',
        value: function onTick() {
          var trackId = this.trackId;
          var subtitleTrack = this.tracks[trackId];
          if (!subtitleTrack) {
            return;
          }
    
          var details = subtitleTrack.details;
          // check if we need to load playlist for this subtitle Track
          if (details === undefined || details.live === true) {
            // track not retrieved yet, or live playlist we need to (re)load it
            _logger.logger.log('(re)loading playlist for subtitle track ' + trackId);
            this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: trackId });
          }
        }
      }, {
        key: 'onSubtitleTrackLoaded',
        value: function onSubtitleTrackLoaded(data) {
          var _this4 = this;
    
          if (data.id < this.tracks.length) {
            _logger.logger.log('subtitle track ' + data.id + ' loaded');
            this.tracks[data.id].details = data.details;
            // check if current playlist is a live playlist
            if (data.details.live && !this.timer) {
              // if live playlist we will have to reload it periodically
              // set reload period to playlist target duration
              this.timer = setInterval(function () {
                _this4.onTick();
              }, 1000 * data.details.targetduration, this);
            }
            if (!data.details.live && this.timer) {
              // playlist is not live and timer is armed : stopping it
              clearInterval(this.timer);
              this.timer = null;
            }
          }
        }
    
        /** get alternate subtitle tracks list from playlist **/
    
      }, {
        key: 'setSubtitleTrackInternal',
        value: function setSubtitleTrackInternal(newId) {
          // check if level idx is valid
          if (newId >= 0 && newId < this.tracks.length) {
            // stopping live reloading timer if any
            if (this.timer) {
              clearInterval(this.timer);
              this.timer = null;
            }
            this.trackId = newId;
            _logger.logger.log('switching to subtitle track ' + newId);
            var subtitleTrack = this.tracks[newId];
            this.hls.trigger(_events2.default.SUBTITLE_TRACK_SWITCH, { id: newId });
            // check if we need to load playlist for this subtitle Track
            var details = subtitleTrack.details;
            if (details === undefined || details.live === true) {
              // track not retrieved yet, or live playlist we need to (re)load it
              _logger.logger.log('(re)loading playlist for subtitle track ' + newId);
              this.hls.trigger(_events2.default.SUBTITLE_TRACK_LOADING, { url: subtitleTrack.url, id: newId });
            }
          }
        }
      }, {
        key: 'subtitleTracks',
        get: function get() {
          return this.tracks;
        }
    
        /** get index of the selected subtitle track (index in subtitle track lists) **/
    
      }, {
        key: 'subtitleTrack',
        get: function get() {
          return this.trackId;
        }
    
        /** select a subtitle track, based on its index in subtitle track lists**/
        ,
        set: function set(subtitleTrackId) {
          if (this.trackId !== subtitleTrackId) {
            // || this.tracks[subtitleTrackId].details === undefined) {
            this.setSubtitleTrackInternal(subtitleTrackId);
          }
        }
      }]);
    
      return SubtitleTrackController;
    }(_eventHandler2.default);
    
    exports.default = SubtitleTrackController;
    
    },{"32":32,"33":33,"51":51}],16:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _cea608Parser = _dereq_(47);
    
    var _cea608Parser2 = _interopRequireDefault(_cea608Parser);
    
    var _webvttParser = _dereq_(55);
    
    var _webvttParser2 = _interopRequireDefault(_webvttParser);
    
    var _logger = _dereq_(51);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * Timeline Controller
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    function clearCurrentCues(track) {
      if (track && track.cues) {
        while (track.cues.length > 0) {
          track.removeCue(track.cues[0]);
        }
      }
    }
    
    function reuseVttTextTrack(inUseTrack, manifestTrack) {
      return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
    }
    
    function intersection(x1, x2, y1, y2) {
      return Math.min(x2, y2) - Math.max(x1, y1);
    }
    
    var TimelineController = function (_EventHandler) {
      _inherits(TimelineController, _EventHandler);
    
      function TimelineController(hls) {
        _classCallCheck(this, TimelineController);
    
        var _this = _possibleConstructorReturn(this, (TimelineController.__proto__ || Object.getPrototypeOf(TimelineController)).call(this, hls, _events2.default.MEDIA_ATTACHING, _events2.default.MEDIA_DETACHING, _events2.default.FRAG_PARSING_USERDATA, _events2.default.MANIFEST_LOADING, _events2.default.MANIFEST_LOADED, _events2.default.FRAG_LOADED, _events2.default.LEVEL_SWITCHING, _events2.default.INIT_PTS_FOUND));
    
        _this.hls = hls;
        _this.config = hls.config;
        _this.enabled = true;
        _this.Cues = hls.config.cueHandler;
        _this.textTracks = [];
        _this.tracks = [];
        _this.unparsedVttFrags = [];
        _this.initPTS = undefined;
        _this.cueRanges = [];
    
        if (_this.config.enableCEA708Captions) {
          var self = _this;
          var sendAddTrackEvent = function sendAddTrackEvent(track, media) {
            var e = null;
            try {
              e = new window.Event('addtrack');
            } catch (err) {
              //for IE11
              e = document.createEvent('Event');
              e.initEvent('addtrack', false, false);
            }
            e.track = track;
            media.dispatchEvent(e);
          };
    
          var channel1 = {
            'newCue': function newCue(startTime, endTime, screen) {
              if (!self.textTrack1) {
                //Enable reuse of existing text track.
                var existingTrack1 = self.getExistingTrack('1');
                if (!existingTrack1) {
                  var textTrack1 = self.createTextTrack('captions', self.config.captionsTextTrack1Label, self.config.captionsTextTrack1LanguageCode);
                  if (textTrack1) {
                    textTrack1.textTrack1 = true;
                    self.textTrack1 = textTrack1;
                  }
                } else {
                  self.textTrack1 = existingTrack1;
                  clearCurrentCues(self.textTrack1);
    
                  sendAddTrackEvent(self.textTrack1, self.media);
                }
              }
              self.addCues('textTrack1', startTime, endTime, screen);
            }
          };
    
          var channel2 = {
            'newCue': function newCue(startTime, endTime, screen) {
              if (!self.textTrack2) {
                //Enable reuse of existing text track.
                var existingTrack2 = self.getExistingTrack('2');
                if (!existingTrack2) {
                  var textTrack2 = self.createTextTrack('captions', self.config.captionsTextTrack2Label, self.config.captionsTextTrack1LanguageCode);
                  if (textTrack2) {
                    textTrack2.textTrack2 = true;
                    self.textTrack2 = textTrack2;
                  }
                } else {
                  self.textTrack2 = existingTrack2;
                  clearCurrentCues(self.textTrack2);
    
                  sendAddTrackEvent(self.textTrack2, self.media);
                }
              }
              self.addCues('textTrack2', startTime, endTime, screen);
            }
          };
    
          _this.cea608Parser = new _cea608Parser2.default(0, channel1, channel2);
        }
        return _this;
      }
    
      _createClass(TimelineController, [{
        key: 'addCues',
        value: function addCues(channel, startTime, endTime, screen) {
          // skip cues which overlap more than 50% with previously parsed time ranges
          var ranges = this.cueRanges;
          var merged = false;
          for (var i = ranges.length; i--;) {
            var cueRange = ranges[i];
            var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
            if (overlap >= 0) {
              cueRange[0] = Math.min(cueRange[0], startTime);
              cueRange[1] = Math.max(cueRange[1], endTime);
              merged = true;
              if (overlap / (endTime - startTime) > 0.5) {
                return;
              }
            }
          }
          if (!merged) {
            ranges.push([startTime, endTime]);
          }
          this.Cues.newCue(this[channel], startTime, endTime, screen);
        }
    
        // Triggered when an initial PTS is found; used for synchronisation of WebVTT.
    
      }, {
        key: 'onInitPtsFound',
        value: function onInitPtsFound(data) {
          var _this2 = this;
    
          if (typeof this.initPTS === 'undefined') {
            this.initPTS = data.initPTS;
          }
    
          // Due to asynchrony, initial PTS may arrive later than the first VTT fragments are loaded.
          // Parse any unparsed fragments upon receiving the initial PTS.
          if (this.unparsedVttFrags.length) {
            this.unparsedVttFrags.forEach(function (frag) {
              _this2.onFragLoaded(frag);
            });
            this.unparsedVttFrags = [];
          }
        }
      }, {
        key: 'getExistingTrack',
        value: function getExistingTrack(channelNumber) {
          var media = this.media;
          if (media) {
            for (var i = 0; i < media.textTracks.length; i++) {
              var textTrack = media.textTracks[i];
              var propName = 'textTrack' + channelNumber;
              if (textTrack[propName] === true) {
                return textTrack;
              }
            }
          }
          return null;
        }
      }, {
        key: 'createTextTrack',
        value: function createTextTrack(kind, label, lang) {
          var media = this.media;
          if (media) {
            return media.addTextTrack(kind, label, lang);
          }
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          _eventHandler2.default.prototype.destroy.call(this);
        }
      }, {
        key: 'onMediaAttaching',
        value: function onMediaAttaching(data) {
          this.media = data.media;
        }
      }, {
        key: 'onMediaDetaching',
        value: function onMediaDetaching() {
          clearCurrentCues(this.textTrack1);
          clearCurrentCues(this.textTrack2);
        }
      }, {
        key: 'onManifestLoading',
        value: function onManifestLoading() {
          this.lastSn = -1; // Detect discontiguity in fragment parsing
          this.prevCC = -1;
          this.vttCCs = { ccOffset: 0, presentationOffset: 0 }; // Detect discontinuity in subtitle manifests
    
          // clear outdated subtitles
          var media = this.media;
          if (media) {
            var textTracks = media.textTracks;
            if (textTracks) {
              for (var i = 0; i < textTracks.length; i++) {
                clearCurrentCues(textTracks[i]);
              }
            }
          }
        }
      }, {
        key: 'onManifestLoaded',
        value: function onManifestLoaded(data) {
          var _this3 = this;
    
          this.textTracks = [];
          this.unparsedVttFrags = this.unparsedVttFrags || [];
          this.initPTS = undefined;
          this.cueRanges = [];
    
          if (this.config.enableWebVTT) {
            this.tracks = data.subtitles || [];
            var inUseTracks = this.media ? this.media.textTracks : [];
    
            this.tracks.forEach(function (track, index) {
              var textTrack = void 0;
              if (index < inUseTracks.length) {
                var inUseTrack = inUseTracks[index];
                // Reuse tracks with the same label, but do not reuse 608/708 tracks
                if (reuseVttTextTrack(inUseTrack, track)) {
                  textTrack = inUseTrack;
                }
              }
              if (!textTrack) {
                textTrack = _this3.createTextTrack('subtitles', track.name, track.lang);
              }
              textTrack.mode = track.default ? 'showing' : 'hidden';
              _this3.textTracks.push(textTrack);
            });
          }
        }
      }, {
        key: 'onLevelSwitching',
        value: function onLevelSwitching() {
          this.enabled = this.hls.currentLevel.closedCaptions !== 'NONE';
        }
      }, {
        key: 'onFragLoaded',
        value: function onFragLoaded(data) {
          var frag = data.frag,
              payload = data.payload;
          if (frag.type === 'main') {
            var sn = frag.sn;
            // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack
            if (sn !== this.lastSn + 1) {
              this.cea608Parser.reset();
            }
            this.lastSn = sn;
          }
          // If fragment is subtitle type, parse as WebVTT.
          else if (frag.type === 'subtitle') {
              if (payload.byteLength) {
                // We need an initial synchronisation PTS. Store fragments as long as none has arrived.
                if (typeof this.initPTS === 'undefined') {
                  this.unparsedVttFrags.push(data);
                  return;
                }
                var vttCCs = this.vttCCs;
                if (!vttCCs[frag.cc]) {
                  vttCCs[frag.cc] = { start: frag.start, prevCC: this.prevCC, new: true };
                  this.prevCC = frag.cc;
                }
                var textTracks = this.textTracks,
                    hls = this.hls;
    
                // Parse the WebVTT file contents.
                _webvttParser2.default.parse(payload, this.initPTS, vttCCs, frag.cc, function (cues) {
                  // Add cues and trigger event with success true.
                  cues.forEach(function (cue) {
                    textTracks[frag.trackId].addCue(cue);
                  });
                  hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: true, frag: frag });
                }, function (e) {
                  // Something went wrong while parsing. Trigger event with success false.
                  _logger.logger.log('Failed to parse VTT cue: ' + e);
                  hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
                });
              } else {
                // In case there is no payload, finish unsuccessfully.
                this.hls.trigger(_events2.default.SUBTITLE_FRAG_PROCESSED, { success: false, frag: frag });
              }
            }
        }
      }, {
        key: 'onFragParsingUserdata',
        value: function onFragParsingUserdata(data) {
          // push all of the CEA-708 messages into the interpreter
          // immediately. It will create the proper timestamps based on our PTS value
          if (this.enabled && this.config.enableCEA708Captions) {
            for (var i = 0; i < data.samples.length; i++) {
              var ccdatas = this.extractCea608Data(data.samples[i].bytes);
              this.cea608Parser.addData(data.samples[i].pts, ccdatas);
            }
          }
        }
      }, {
        key: 'extractCea608Data',
        value: function extractCea608Data(byteArray) {
          var count = byteArray[0] & 31;
          var position = 2;
          var tmpByte, ccbyte1, ccbyte2, ccValid, ccType;
          var actualCCBytes = [];
    
          for (var j = 0; j < count; j++) {
            tmpByte = byteArray[position++];
            ccbyte1 = 0x7F & byteArray[position++];
            ccbyte2 = 0x7F & byteArray[position++];
            ccValid = (4 & tmpByte) !== 0;
            ccType = 3 & tmpByte;
    
            if (ccbyte1 === 0 && ccbyte2 === 0) {
              continue;
            }
    
            if (ccValid) {
              if (ccType === 0) // || ccType === 1
                {
                  actualCCBytes.push(ccbyte1);
                  actualCCBytes.push(ccbyte2);
                }
            }
          }
          return actualCCBytes;
        }
      }]);
    
      return TimelineController;
    }(_eventHandler2.default);
    
    exports.default = TimelineController;
    
    },{"32":32,"33":33,"47":47,"51":51,"55":55}],17:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var AESCrypto = function () {
      function AESCrypto(subtle, iv) {
        _classCallCheck(this, AESCrypto);
    
        this.subtle = subtle;
        this.aesIV = iv;
      }
    
      _createClass(AESCrypto, [{
        key: 'decrypt',
        value: function decrypt(data, key) {
          return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, key, data);
        }
      }]);
    
      return AESCrypto;
    }();
    
    exports.default = AESCrypto;
    
    },{}],18:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var AESDecryptor = function () {
      function AESDecryptor() {
        _classCallCheck(this, AESDecryptor);
    
        // Static after running initTable
        this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
        this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
        this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
        this.sBox = new Uint32Array(256);
        this.invSBox = new Uint32Array(256);
    
        // Changes during runtime
        this.key = new Uint32Array(0);
    
        this.initTable();
      }
    
      // Using view.getUint32() also swaps the byte order.
    
    
      _createClass(AESDecryptor, [{
        key: 'uint8ArrayToUint32Array_',
        value: function uint8ArrayToUint32Array_(arrayBuffer) {
          var view = new DataView(arrayBuffer);
          var newArray = new Uint32Array(4);
          for (var i = 0; i < 4; i++) {
            newArray[i] = view.getUint32(i * 4);
          }
          return newArray;
        }
      }, {
        key: 'initTable',
        value: function initTable() {
          var sBox = this.sBox;
          var invSBox = this.invSBox;
          var subMix = this.subMix;
          var subMix0 = subMix[0];
          var subMix1 = subMix[1];
          var subMix2 = subMix[2];
          var subMix3 = subMix[3];
          var invSubMix = this.invSubMix;
          var invSubMix0 = invSubMix[0];
          var invSubMix1 = invSubMix[1];
          var invSubMix2 = invSubMix[2];
          var invSubMix3 = invSubMix[3];
    
          var d = new Uint32Array(256);
          var x = 0;
          var xi = 0;
          var i = 0;
          for (i = 0; i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 0x11b;
            }
          }
    
          for (i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
            sBox[x] = sx;
            invSBox[sx] = x;
    
            // Compute multiplication
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
    
            // Compute sub/invSub bytes, mix columns tables
            var t = d[sx] * 0x101 ^ sx * 0x1010100;
            subMix0[x] = t << 24 | t >>> 8;
            subMix1[x] = t << 16 | t >>> 16;
            subMix2[x] = t << 8 | t >>> 24;
            subMix3[x] = t;
    
            // Compute inv sub bytes, inv mix columns tables
            t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
            invSubMix0[sx] = t << 24 | t >>> 8;
            invSubMix1[sx] = t << 16 | t >>> 16;
            invSubMix2[sx] = t << 8 | t >>> 24;
            invSubMix3[sx] = t;
    
            // Compute next counter
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        }
      }, {
        key: 'expandKey',
        value: function expandKey(keyBuffer) {
          // convert keyBuffer to Uint32Array
          var key = this.uint8ArrayToUint32Array_(keyBuffer);
          var sameKey = true;
          var offset = 0;
    
          while (offset < key.length && sameKey) {
            sameKey = key[offset] === this.key[offset];
            offset++;
          }
    
          if (sameKey) {
            return;
          }
    
          this.key = key;
          var keySize = this.keySize = key.length;
    
          if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
            throw new Error('Invalid aes key size=' + keySize);
          }
    
          var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
          var ksRow = void 0;
          var invKsRow = void 0;
    
          var keySchedule = this.keySchedule = new Uint32Array(ksRows);
          var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
          var sbox = this.sBox;
          var rcon = this.rcon;
    
          var invSubMix = this.invSubMix;
          var invSubMix0 = invSubMix[0];
          var invSubMix1 = invSubMix[1];
          var invSubMix2 = invSubMix[2];
          var invSubMix3 = invSubMix[3];
    
          var prev = void 0;
          var t = void 0;
    
          for (ksRow = 0; ksRow < ksRows; ksRow++) {
            if (ksRow < keySize) {
              prev = keySchedule[ksRow] = key[ksRow];
              continue;
            }
            t = prev;
    
            if (ksRow % keySize === 0) {
              // Rot word
              t = t << 8 | t >>> 24;
    
              // Sub word
              t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
    
              // Mix Rcon
              t ^= rcon[ksRow / keySize | 0] << 24;
            } else if (keySize > 6 && ksRow % keySize === 4) {
              // Sub word
              t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];
            }
    
            keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
          }
    
          for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
            ksRow = ksRows - invKsRow;
            if (invKsRow & 3) {
              t = keySchedule[ksRow];
            } else {
              t = keySchedule[ksRow - 4];
            }
    
            if (invKsRow < 4 || ksRow <= 4) {
              invKeySchedule[invKsRow] = t;
            } else {
              invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];
            }
    
            invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
          }
        }
    
        // Adding this as a method greatly improves performance.
    
      }, {
        key: 'networkToHostOrderSwap',
        value: function networkToHostOrderSwap(word) {
          return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;
        }
      }, {
        key: 'decrypt',
        value: function decrypt(inputArrayBuffer, offset, aesIV) {
          var nRounds = this.keySize + 6;
          var invKeySchedule = this.invKeySchedule;
          var invSBOX = this.invSBox;
    
          var invSubMix = this.invSubMix;
          var invSubMix0 = invSubMix[0];
          var invSubMix1 = invSubMix[1];
          var invSubMix2 = invSubMix[2];
          var invSubMix3 = invSubMix[3];
    
          var initVector = this.uint8ArrayToUint32Array_(aesIV);
          var initVector0 = initVector[0];
          var initVector1 = initVector[1];
          var initVector2 = initVector[2];
          var initVector3 = initVector[3];
    
          var inputInt32 = new Int32Array(inputArrayBuffer);
          var outputInt32 = new Int32Array(inputInt32.length);
    
          var t0 = void 0,
              t1 = void 0,
              t2 = void 0,
              t3 = void 0;
          var s0 = void 0,
              s1 = void 0,
              s2 = void 0,
              s3 = void 0;
          var inputWords0 = void 0,
              inputWords1 = void 0,
              inputWords2 = void 0,
              inputWords3 = void 0;
    
          var ksRow, i;
          var swapWord = this.networkToHostOrderSwap;
    
          while (offset < inputInt32.length) {
            inputWords0 = swapWord(inputInt32[offset]);
            inputWords1 = swapWord(inputInt32[offset + 1]);
            inputWords2 = swapWord(inputInt32[offset + 2]);
            inputWords3 = swapWord(inputInt32[offset + 3]);
    
            s0 = inputWords0 ^ invKeySchedule[0];
            s1 = inputWords3 ^ invKeySchedule[1];
            s2 = inputWords2 ^ invKeySchedule[2];
            s3 = inputWords1 ^ invKeySchedule[3];
    
            ksRow = 4;
    
            // Iterate through the rounds of decryption
            for (i = 1; i < nRounds; i++) {
              t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];
              t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
              t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
              t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
              // Update state
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
    
              ksRow = ksRow + 4;
            }
    
            // Shift rows, sub bytes, add round key
            t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];
            t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];
            t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];
            t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];
            ksRow = ksRow + 3;
    
            // Write
            outputInt32[offset] = swapWord(t0 ^ initVector0);
            outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
            outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
            outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
    
            // reset initVector to last 4 unsigned int
            initVector0 = inputWords0;
            initVector1 = inputWords1;
            initVector2 = inputWords2;
            initVector3 = inputWords3;
    
            offset = offset + 4;
          }
    
          return outputInt32.buffer;
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          this.key = undefined;
          this.keySize = undefined;
          this.ksRows = undefined;
    
          this.sBox = undefined;
          this.invSBox = undefined;
          this.subMix = undefined;
          this.invSubMix = undefined;
          this.keySchedule = undefined;
          this.invKeySchedule = undefined;
    
          this.rcon = undefined;
        }
      }]);
    
      return AESDecryptor;
    }();
    
    exports.default = AESDecryptor;
    
    },{}],19:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _aesCrypto = _dereq_(17);
    
    var _aesCrypto2 = _interopRequireDefault(_aesCrypto);
    
    var _fastAesKey = _dereq_(20);
    
    var _fastAesKey2 = _interopRequireDefault(_fastAesKey);
    
    var _aesDecryptor = _dereq_(18);
    
    var _aesDecryptor2 = _interopRequireDefault(_aesDecryptor);
    
    var _errors = _dereq_(31);
    
    var _logger = _dereq_(51);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /*globals self: false */
    
    var Decrypter = function () {
      function Decrypter(observer, config) {
        _classCallCheck(this, Decrypter);
    
        this.observer = observer;
        this.config = config;
        this.logEnabled = true;
        try {
          var browserCrypto = crypto ? crypto : self.crypto;
          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
        } catch (e) {}
        this.disableWebCrypto = !this.subtle;
      }
    
      _createClass(Decrypter, [{
        key: 'isSync',
        value: function isSync() {
          return this.disableWebCrypto && this.config.enableSoftwareAES;
        }
      }, {
        key: 'decrypt',
        value: function decrypt(data, key, iv, callback) {
          var _this = this;
    
          if (this.disableWebCrypto && this.config.enableSoftwareAES) {
            if (this.logEnabled) {
              _logger.logger.log('JS AES decrypt');
              this.logEnabled = false;
            }
            var decryptor = this.decryptor;
            if (!decryptor) {
              this.decryptor = decryptor = new _aesDecryptor2.default();
            }
            decryptor.expandKey(key);
            callback(decryptor.decrypt(data, 0, iv));
          } else {
            if (this.logEnabled) {
              _logger.logger.log('WebCrypto AES decrypt');
              this.logEnabled = false;
            }
            var subtle = this.subtle;
            if (this.key !== key) {
              this.key = key;
              this.fastAesKey = new _fastAesKey2.default(subtle, key);
            }
    
            this.fastAesKey.expandKey().then(function (aesKey) {
              // decrypt using web crypto
              var crypto = new _aesCrypto2.default(subtle, iv);
              crypto.decrypt(data, aesKey).catch(function (err) {
                _this.onWebCryptoError(err, data, key, iv, callback);
              }).then(function (result) {
                callback(result);
              });
            }).catch(function (err) {
              _this.onWebCryptoError(err, data, key, iv, callback);
            });
          }
        }
      }, {
        key: 'onWebCryptoError',
        value: function onWebCryptoError(err, data, key, iv, callback) {
          if (this.config.enableSoftwareAES) {
            _logger.logger.log('WebCrypto Error, disable WebCrypto API');
            this.disableWebCrypto = true;
            this.logEnabled = true;
            this.decrypt(data, key, iv, callback);
          } else {
            _logger.logger.error('decrypting error : ' + err.message);
            this.observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_DECRYPT_ERROR, fatal: true, reason: err.message });
          }
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          var decryptor = this.decryptor;
          if (decryptor) {
            decryptor.destroy();
            this.decryptor = undefined;
          }
        }
      }]);
    
      return Decrypter;
    }();
    
    exports.default = Decrypter;
    
    },{"17":17,"18":18,"20":20,"31":31,"51":51}],20:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var FastAESKey = function () {
      function FastAESKey(subtle, key) {
        _classCallCheck(this, FastAESKey);
    
        this.subtle = subtle;
        this.key = key;
      }
    
      _createClass(FastAESKey, [{
        key: 'expandKey',
        value: function expandKey() {
          return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, false, ['encrypt', 'decrypt']);
        }
      }]);
    
      return FastAESKey;
    }();
    
    exports.default = FastAESKey;
    
    },{}],21:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * AAC demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */
    
    
    var _adts = _dereq_(22);
    
    var _adts2 = _interopRequireDefault(_adts);
    
    var _logger = _dereq_(51);
    
    var _id = _dereq_(27);
    
    var _id2 = _interopRequireDefault(_id);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var AACDemuxer = function () {
      function AACDemuxer(observer, remuxer, config) {
        _classCallCheck(this, AACDemuxer);
    
        this.observer = observer;
        this.config = config;
        this.remuxer = remuxer;
      }
    
      _createClass(AACDemuxer, [{
        key: 'resetInitSegment',
        value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
          this._aacTrack = { container: 'audio/adts', type: 'audio', id: -1, sequenceNumber: 0, isAAC: true, samples: [], len: 0, manifestCodec: audioCodec, duration: duration, inputTimeScale: 90000 };
        }
      }, {
        key: 'resetTimeStamp',
        value: function resetTimeStamp() {}
      }, {
        key: 'append',
    
    
        // feed incoming data to the front of the parsing pipeline
        value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
          var track,
              id3 = new _id2.default(data),
              pts = 90 * id3.timeStamp,
              config,
              frameLength,
              frameDuration,
              frameIndex,
              offset,
              headerLength,
              stamp,
              len,
              aacSample;
    
          track = this._aacTrack;
    
          // look for ADTS header (0xFFFx)
          for (offset = id3.length, len = data.length; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
    
          if (!track.samplerate) {
            config = _adts2.default.getAudioConfig(this.observer, data, offset, track.manifestCodec);
            track.config = config.config;
            track.samplerate = config.samplerate;
            track.channelCount = config.channelCount;
            track.codec = config.codec;
            _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
          }
          frameIndex = 0;
          frameDuration = 1024 * 90000 / track.samplerate;
          while (offset + 5 < len) {
            // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
            headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
            // retrieve frame size
            frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
            frameLength -= headerLength;
            //stamp = pes.pts;
    
            if (frameLength > 0 && offset + headerLength + frameLength <= len) {
              stamp = pts + frameIndex * frameDuration;
              //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
              aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
              track.samples.push(aacSample);
              track.len += frameLength;
              offset += frameLength + headerLength;
              frameIndex++;
              // look for ADTS header (0xFFFx)
              for (; offset < len - 1; offset++) {
                if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
                  break;
                }
              }
            } else {
              break;
            }
          }
          this.remuxer.remux(track, { samples: [] }, { samples: [{ pts: pts, dts: pts, unit: id3.payload }], inputTimeScale: 90000 }, { samples: [] }, timeOffset, contiguous, accurateTimeOffset);
        }
      }, {
        key: 'destroy',
        value: function destroy() {}
      }], [{
        key: 'probe',
        value: function probe(data) {
          // check if data contains ID3 timestamp and ADTS sync worc
          var id3 = new _id2.default(data),
              offset,
              len;
          if (id3.hasTimeStamp) {
            // look for ADTS header (0xFFFx)
            for (offset = id3.length, len = data.length; offset < len - 1; offset++) {
              if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
                //logger.log('ADTS sync word found !');
                return true;
              }
            }
          }
          return false;
        }
      }]);
    
      return AACDemuxer;
    }();
    
    exports.default = AACDemuxer;
    
    },{"22":22,"27":27,"51":51}],22:[function(_dereq_,module,exports){
    'use strict';
    
    var _logger = _dereq_(51);
    
    var _errors = _dereq_(31);
    
    /**
     *  ADTS parser helper
     */
    var ADTS = {
      getAudioConfig: function getAudioConfig(observer, data, offset, audioCodec) {
        var adtsObjectType,
            // :int
        adtsSampleingIndex,
            // :int
        adtsExtensionSampleingIndex,
            // :int
        adtsChanelConfig,
            // :int
        config,
            userAgent = navigator.userAgent.toLowerCase(),
            manifestCodec = audioCodec,
            adtsSampleingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
        // byte 2
        adtsObjectType = ((data[offset + 2] & 0xC0) >>> 6) + 1;
        adtsSampleingIndex = (data[offset + 2] & 0x3C) >>> 2;
        if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
          observer.trigger(Event.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'invalid ADTS sampling index:' + adtsSampleingIndex });
          return;
        }
        adtsChanelConfig = (data[offset + 2] & 0x01) << 2;
        // byte 3
        adtsChanelConfig |= (data[offset + 3] & 0xC0) >>> 6;
        _logger.logger.log('manifest codec:' + audioCodec + ',ADTS data:type:' + adtsObjectType + ',sampleingIndex:' + adtsSampleingIndex + '[' + adtsSampleingRates[adtsSampleingIndex] + 'Hz],channelConfig:' + adtsChanelConfig);
        // firefox: freq less than 24kHz = AAC SBR (HE-AAC)
        if (/firefox/i.test(userAgent)) {
          if (adtsSampleingIndex >= 6) {
            adtsObjectType = 5;
            config = new Array(4);
            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
            // there is a factor 2 between frame sample rate and output sample rate
            // multiply frequency by 2 (see table below, equivalent to substract 3)
            adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
          } else {
            adtsObjectType = 2;
            config = new Array(2);
            adtsExtensionSampleingIndex = adtsSampleingIndex;
          }
          // Android : always use AAC
        } else if (userAgent.indexOf('android') !== -1) {
          adtsObjectType = 2;
          config = new Array(2);
          adtsExtensionSampleingIndex = adtsSampleingIndex;
        } else {
          /*  for other browsers (Chrome/Vivaldi/Opera ...)
              always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)
          */
          adtsObjectType = 5;
          config = new Array(4);
          // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)
          if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies
            // there is a factor 2 between frame sample rate and output sample rate
            // multiply frequency by 2 (see table below, equivalent to substract 3)
            adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
          } else {
            // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)
            // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.
            if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || !audioCodec && adtsChanelConfig === 1) {
              adtsObjectType = 2;
              config = new Array(2);
            }
            adtsExtensionSampleingIndex = adtsSampleingIndex;
          }
        }
        /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config
            ISO 14496-3 (AAC).pdf - Table 1.13 — Syntax of AudioSpecificConfig()
          Audio Profile / Audio Object Type
          0: Null
          1: AAC Main
          2: AAC LC (Low Complexity)
          3: AAC SSR (Scalable Sample Rate)
          4: AAC LTP (Long Term Prediction)
          5: SBR (Spectral Band Replication)
          6: AAC Scalable
         sampling freq
          0: 96000 Hz
          1: 88200 Hz
          2: 64000 Hz
          3: 48000 Hz
          4: 44100 Hz
          5: 32000 Hz
          6: 24000 Hz
          7: 22050 Hz
          8: 16000 Hz
          9: 12000 Hz
          10: 11025 Hz
          11: 8000 Hz
          12: 7350 Hz
          13: Reserved
          14: Reserved
          15: frequency is written explictly
          Channel Configurations
          These are the channel configurations:
          0: Defined in AOT Specifc Config
          1: 1 channel: front-center
          2: 2 channels: front-left, front-right
        */
        // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1
        config[0] = adtsObjectType << 3;
        // samplingFrequencyIndex
        config[0] |= (adtsSampleingIndex & 0x0E) >> 1;
        config[1] |= (adtsSampleingIndex & 0x01) << 7;
        // channelConfiguration
        config[1] |= adtsChanelConfig << 3;
        if (adtsObjectType === 5) {
          // adtsExtensionSampleingIndex
          config[1] |= (adtsExtensionSampleingIndex & 0x0E) >> 1;
          config[2] = (adtsExtensionSampleingIndex & 0x01) << 7;
          // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???
          //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc
          config[2] |= 2 << 2;
          config[3] = 0;
        }
        return { config: config, samplerate: adtsSampleingRates[adtsSampleingIndex], channelCount: adtsChanelConfig, codec: 'mp4a.40.' + adtsObjectType, manifestCodec: manifestCodec };
      }
    };
    
    module.exports = ADTS;
    
    },{"31":31,"51":51}],23:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*  inline demuxer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *   probe fragments and instantiate appropriate demuxer depending on content type (TSDemuxer, AACDemuxer, ...)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _errors = _dereq_(31);
    
    var _decrypter = _dereq_(19);
    
    var _decrypter2 = _interopRequireDefault(_decrypter);
    
    var _aacdemuxer = _dereq_(21);
    
    var _aacdemuxer2 = _interopRequireDefault(_aacdemuxer);
    
    var _mp4demuxer = _dereq_(28);
    
    var _mp4demuxer2 = _interopRequireDefault(_mp4demuxer);
    
    var _tsdemuxer = _dereq_(30);
    
    var _tsdemuxer2 = _interopRequireDefault(_tsdemuxer);
    
    var _mp4Remuxer = _dereq_(43);
    
    var _mp4Remuxer2 = _interopRequireDefault(_mp4Remuxer);
    
    var _passthroughRemuxer = _dereq_(44);
    
    var _passthroughRemuxer2 = _interopRequireDefault(_passthroughRemuxer);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var DemuxerInline = function () {
      function DemuxerInline(observer, typeSupported, config, vendor) {
        _classCallCheck(this, DemuxerInline);
    
        this.observer = observer;
        this.typeSupported = typeSupported;
        this.config = config;
        this.vendor = vendor;
      }
    
      _createClass(DemuxerInline, [{
        key: 'destroy',
        value: function destroy() {
          var demuxer = this.demuxer;
          if (demuxer) {
            demuxer.destroy();
          }
        }
      }, {
        key: 'push',
        value: function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
          if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === 'AES-128') {
            var decrypter = this.decrypter;
            if (decrypter == null) {
              decrypter = this.decrypter = new _decrypter2.default(this.observer, this.config);
            }
            var localthis = this;
            // performance.now() not available on WebWorker, at least on Safari Desktop
            var startTime;
            try {
              startTime = performance.now();
            } catch (error) {
              startTime = Date.now();
            }
            decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function (decryptedData) {
              var endTime;
              try {
                endTime = performance.now();
              } catch (error) {
                endTime = Date.now();
              }
              localthis.observer.trigger(_events2.default.FRAG_DECRYPTED, { stats: { tstart: startTime, tdecrypt: endTime } });
              localthis.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
            });
          } else {
            this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
          }
        }
      }, {
        key: 'pushDecrypted',
        value: function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
          var demuxer = this.demuxer;
          if (!demuxer ||
          // in case of continuity change, we might switch from content type (AAC container to TS container for example)
          // so let's check that current demuxer is still valid
          discontinuity && !this.probe(data)) {
            var observer = this.observer;
            var typeSupported = this.typeSupported;
            var config = this.config;
            var muxConfig = [{ demux: _tsdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _aacdemuxer2.default, remux: _mp4Remuxer2.default }, { demux: _mp4demuxer2.default, remux: _passthroughRemuxer2.default }];
    
            // probe for content type
            for (var i in muxConfig) {
              var mux = muxConfig[i];
              var probe = mux.demux.probe;
              if (probe(data)) {
                var _remuxer = this.remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
                demuxer = new mux.demux(observer, _remuxer, config, typeSupported);
                this.probe = probe;
                break;
              }
            }
            if (!demuxer) {
              observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: true, reason: 'no demux matching with content found' });
              return;
            }
            this.demuxer = demuxer;
          }
          var remuxer = this.remuxer;
    
          if (discontinuity || trackSwitch) {
            demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
            remuxer.resetInitSegment();
          }
          if (discontinuity) {
            demuxer.resetTimeStamp();
            remuxer.resetTimeStamp(defaultInitPTS);
          }
          if (typeof demuxer.setDecryptData === 'function') {
            demuxer.setDecryptData(decryptdata);
          }
          demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
        }
      }]);
    
      return DemuxerInline;
    }();
    
    exports.default = DemuxerInline;
    
    },{"19":19,"21":21,"28":28,"30":30,"31":31,"33":33,"43":43,"44":44}],24:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _demuxerInline = _dereq_(23);
    
    var _demuxerInline2 = _interopRequireDefault(_demuxerInline);
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _logger = _dereq_(51);
    
    var _events3 = _dereq_(1);
    
    var _events4 = _interopRequireDefault(_events3);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    /* demuxer web worker.
     *  - listen to worker message, and trigger DemuxerInline upon reception of Fragments.
     *  - provides MP4 Boxes back to main thread using [transferable objects](https://developers.google.com/web/updates/2011/12/Transferable-Objects-Lightning-Fast) in order to minimize message passing overhead.
     */
    
    var DemuxerWorker = function DemuxerWorker(self) {
      // observer setup
      var observer = new _events4.default();
      observer.trigger = function trigger(event) {
        for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          data[_key - 1] = arguments[_key];
        }
    
        observer.emit.apply(observer, [event, event].concat(data));
      };
    
      observer.off = function off(event) {
        for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          data[_key2 - 1] = arguments[_key2];
        }
    
        observer.removeListener.apply(observer, [event].concat(data));
      };
    
      var forwardMessage = function forwardMessage(ev, data) {
        self.postMessage({ event: ev, data: data });
      };
    
      self.addEventListener('message', function (ev) {
        var data = ev.data;
        //console.log('demuxer cmd:' + data.cmd);
        switch (data.cmd) {
          case 'init':
            var config = JSON.parse(data.config);
            self.demuxer = new _demuxerInline2.default(observer, data.typeSupported, config, data.vendor);
            try {
              (0, _logger.enableLogs)(config.debug === true);
            } catch (err) {
              console.warn('demuxerWorker: unable to enable logs');
            }
            // signal end of worker init
            forwardMessage('init', null);
            break;
          case 'demux':
            self.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
            break;
          default:
            break;
        }
      });
    
      // forward events to main thread
      observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
      observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
      observer.on(_events2.default.FRAG_PARSED, forwardMessage);
      observer.on(_events2.default.ERROR, forwardMessage);
      observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
      observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
      observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);
    
      // special case for FRAG_PARSING_DATA: pass data1/data2 as transferable object (no copy)
      observer.on(_events2.default.FRAG_PARSING_DATA, function (ev, data) {
        var transferable = [];
        var message = { event: ev, data: data };
        if (data.data1) {
          message.data1 = data.data1.buffer;
          transferable.push(data.data1.buffer);
          delete data.data1;
        }
        if (data.data2) {
          message.data2 = data.data2.buffer;
          transferable.push(data.data2.buffer);
          delete data.data2;
        }
        self.postMessage(message, transferable);
      });
    };
    
    exports.default = DemuxerWorker;
    
    },{"1":1,"23":23,"33":33,"51":51}],25:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _demuxerInline = _dereq_(23);
    
    var _demuxerInline2 = _interopRequireDefault(_demuxerInline);
    
    var _demuxerWorker = _dereq_(24);
    
    var _demuxerWorker2 = _interopRequireDefault(_demuxerWorker);
    
    var _logger = _dereq_(51);
    
    var _errors = _dereq_(31);
    
    var _events3 = _dereq_(1);
    
    var _events4 = _interopRequireDefault(_events3);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var Demuxer = function () {
      function Demuxer(hls, id) {
        _classCallCheck(this, Demuxer);
    
        this.hls = hls;
        this.id = id;
        // observer setup
        var observer = this.observer = new _events4.default();
        var config = hls.config;
        observer.trigger = function trigger(event) {
          for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            data[_key - 1] = arguments[_key];
          }
    
          observer.emit.apply(observer, [event, event].concat(data));
        };
    
        observer.off = function off(event) {
          for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            data[_key2 - 1] = arguments[_key2];
          }
    
          observer.removeListener.apply(observer, [event].concat(data));
        };
    
        var forwardMessage = function (ev, data) {
          data = data || {};
          data.frag = this.frag;
          data.id = this.id;
          hls.trigger(ev, data);
        }.bind(this);
    
        // forward events to main thread
        observer.on(_events2.default.FRAG_DECRYPTED, forwardMessage);
        observer.on(_events2.default.FRAG_PARSING_INIT_SEGMENT, forwardMessage);
        observer.on(_events2.default.FRAG_PARSING_DATA, forwardMessage);
        observer.on(_events2.default.FRAG_PARSED, forwardMessage);
        observer.on(_events2.default.ERROR, forwardMessage);
        observer.on(_events2.default.FRAG_PARSING_METADATA, forwardMessage);
        observer.on(_events2.default.FRAG_PARSING_USERDATA, forwardMessage);
        observer.on(_events2.default.INIT_PTS_FOUND, forwardMessage);
    
        var typeSupported = {
          mp4: MediaSource.isTypeSupported('video/mp4'),
          mpeg: MediaSource.isTypeSupported('audio/mpeg'),
          mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
        };
        // navigator.vendor is not always available in Web Worker
        // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator
        var vendor = navigator.vendor;
        if (config.enableWorker && typeof Worker !== 'undefined') {
          _logger.logger.log('demuxing in webworker');
          var w = void 0;
          try {
            var work = _dereq_(3);
            w = this.w = work(_demuxerWorker2.default);
            this.onwmsg = this.onWorkerMessage.bind(this);
            w.addEventListener('message', this.onwmsg);
            w.onerror = function (event) {
              hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: true, event: 'demuxerWorker', err: { message: event.message + ' (' + event.filename + ':' + event.lineno + ')' } });
            };
            w.postMessage({ cmd: 'init', typeSupported: typeSupported, vendor: vendor, id: id, config: JSON.stringify(config) });
          } catch (err) {
            _logger.logger.error('error while initializing DemuxerWorker, fallback on DemuxerInline');
            if (w) {
              // revoke the Object URL that was used to create demuxer worker, so as not to leak it
              URL.revokeObjectURL(w.objectURL);
            }
            this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
            this.w = undefined;
          }
        } else {
          this.demuxer = new _demuxerInline2.default(observer, typeSupported, config, vendor);
        }
      }
    
      _createClass(Demuxer, [{
        key: 'destroy',
        value: function destroy() {
          var w = this.w;
          if (w) {
            w.removeEventListener('message', this.onwmsg);
            w.terminate();
            this.w = null;
          } else {
            var demuxer = this.demuxer;
            if (demuxer) {
              demuxer.destroy();
              this.demuxer = null;
            }
          }
          var observer = this.observer;
          if (observer) {
            observer.removeAllListeners();
            this.observer = null;
          }
        }
      }, {
        key: 'push',
        value: function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
          var w = this.w;
          var timeOffset = !isNaN(frag.startDTS) ? frag.startDTS : frag.start;
          var decryptdata = frag.decryptdata;
          var lastFrag = this.frag;
          var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
          var trackSwitch = !(lastFrag && frag.level === lastFrag.level);
          var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
          var contiguous = !trackSwitch && nextSN;
          if (discontinuity) {
            _logger.logger.log(this.id + ':discontinuity detected');
          }
          if (trackSwitch) {
            _logger.logger.log(this.id + ':switch detected');
          }
          this.frag = frag;
          if (w) {
            // post fragment payload as transferable objects (no copy)
            w.postMessage({ cmd: 'demux', data: data, decryptdata: decryptdata, initSegment: initSegment, audioCodec: audioCodec, videoCodec: videoCodec, timeOffset: timeOffset, discontinuity: discontinuity, trackSwitch: trackSwitch, contiguous: contiguous, duration: duration, accurateTimeOffset: accurateTimeOffset, defaultInitPTS: defaultInitPTS }, [data]);
          } else {
            var demuxer = this.demuxer;
            if (demuxer) {
              demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
            }
          }
        }
      }, {
        key: 'onWorkerMessage',
        value: function onWorkerMessage(ev) {
          var data = ev.data,
              hls = this.hls;
          //console.log('onWorkerMessage:' + data.event);
          switch (data.event) {
            case 'init':
              // revoke the Object URL that was used to create demuxer worker, so as not to leak it
              URL.revokeObjectURL(this.w.objectURL);
              break;
            // special case for FRAG_PARSING_DATA: data1 and data2 are transferable objects
            case _events2.default.FRAG_PARSING_DATA:
              data.data.data1 = new Uint8Array(data.data1);
              if (data.data2) {
                data.data.data2 = new Uint8Array(data.data2);
              }
            /* falls through */
            default:
              data.data = data.data || {};
              data.data.frag = this.frag;
              data.data.id = this.id;
              hls.trigger(data.event, data.data);
              break;
          }
        }
      }]);
    
      return Demuxer;
    }();
    
    exports.default = Demuxer;
    
    },{"1":1,"23":23,"24":24,"3":3,"31":31,"33":33,"51":51}],26:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         */
    
    var _logger = _dereq_(51);
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var ExpGolomb = function () {
      function ExpGolomb(data) {
        _classCallCheck(this, ExpGolomb);
    
        this.data = data;
        // the number of bytes left to examine in this.data
        this.bytesAvailable = data.byteLength;
        // the current word being examined
        this.word = 0; // :uint
        // the number of bits left to examine in the current word
        this.bitsAvailable = 0; // :uint
      }
    
      // ():void
    
    
      _createClass(ExpGolomb, [{
        key: 'loadWord',
        value: function loadWord() {
          var data = this.data,
              bytesAvailable = this.bytesAvailable,
              position = data.byteLength - bytesAvailable,
              workingBytes = new Uint8Array(4),
              availableBytes = Math.min(4, bytesAvailable);
          if (availableBytes === 0) {
            throw new Error('no bytes available');
          }
          workingBytes.set(data.subarray(position, position + availableBytes));
          this.word = new DataView(workingBytes.buffer).getUint32(0);
          // track the amount of this.data that has been processed
          this.bitsAvailable = availableBytes * 8;
          this.bytesAvailable -= availableBytes;
        }
    
        // (count:int):void
    
      }, {
        key: 'skipBits',
        value: function skipBits(count) {
          var skipBytes; // :int
          if (this.bitsAvailable > count) {
            this.word <<= count;
            this.bitsAvailable -= count;
          } else {
            count -= this.bitsAvailable;
            skipBytes = count >> 3;
            count -= skipBytes >> 3;
            this.bytesAvailable -= skipBytes;
            this.loadWord();
            this.word <<= count;
            this.bitsAvailable -= count;
          }
        }
    
        // (size:int):uint
    
      }, {
        key: 'readBits',
        value: function readBits(size) {
          var bits = Math.min(this.bitsAvailable, size),
              // :uint
          valu = this.word >>> 32 - bits; // :uint
          if (size > 32) {
            _logger.logger.error('Cannot read more than 32 bits at a time');
          }
          this.bitsAvailable -= bits;
          if (this.bitsAvailable > 0) {
            this.word <<= bits;
          } else if (this.bytesAvailable > 0) {
            this.loadWord();
          }
          bits = size - bits;
          if (bits > 0 && this.bitsAvailable) {
            return valu << bits | this.readBits(bits);
          } else {
            return valu;
          }
        }
    
        // ():uint
    
      }, {
        key: 'skipLZ',
        value: function skipLZ() {
          var leadingZeroCount; // :uint
          for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
            if (0 !== (this.word & 0x80000000 >>> leadingZeroCount)) {
              // the first bit of working word is 1
              this.word <<= leadingZeroCount;
              this.bitsAvailable -= leadingZeroCount;
              return leadingZeroCount;
            }
          }
          // we exhausted word and still have not found a 1
          this.loadWord();
          return leadingZeroCount + this.skipLZ();
        }
    
        // ():void
    
      }, {
        key: 'skipUEG',
        value: function skipUEG() {
          this.skipBits(1 + this.skipLZ());
        }
    
        // ():void
    
      }, {
        key: 'skipEG',
        value: function skipEG() {
          this.skipBits(1 + this.skipLZ());
        }
    
        // ():uint
    
      }, {
        key: 'readUEG',
        value: function readUEG() {
          var clz = this.skipLZ(); // :uint
          return this.readBits(clz + 1) - 1;
        }
    
        // ():int
    
      }, {
        key: 'readEG',
        value: function readEG() {
          var valu = this.readUEG(); // :int
          if (0x01 & valu) {
            // the number is odd if the low order bit is set
            return 1 + valu >>> 1; // add 1 to make it even, and divide by 2
          } else {
            return -1 * (valu >>> 1); // divide by two then make it negative
          }
        }
    
        // Some convenience functions
        // :Boolean
    
      }, {
        key: 'readBoolean',
        value: function readBoolean() {
          return 1 === this.readBits(1);
        }
    
        // ():int
    
      }, {
        key: 'readUByte',
        value: function readUByte() {
          return this.readBits(8);
        }
    
        // ():int
    
      }, {
        key: 'readUShort',
        value: function readUShort() {
          return this.readBits(16);
        }
        // ():int
    
      }, {
        key: 'readUInt',
        value: function readUInt() {
          return this.readBits(32);
        }
    
        /**
         * Advance the ExpGolomb decoder past a scaling list. The scaling
         * list is optionally transmitted as part of a sequence parameter
         * set and is not relevant to transmuxing.
         * @param count {number} the number of entries in this scaling list
         * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1
         */
    
      }, {
        key: 'skipScalingList',
        value: function skipScalingList(count) {
          var lastScale = 8,
              nextScale = 8,
              j,
              deltaScale;
          for (j = 0; j < count; j++) {
            if (nextScale !== 0) {
              deltaScale = this.readEG();
              nextScale = (lastScale + deltaScale + 256) % 256;
            }
            lastScale = nextScale === 0 ? lastScale : nextScale;
          }
        }
    
        /**
         * Read a sequence parameter set and return some interesting video
         * properties. A sequence parameter set is the H264 metadata that
         * describes the properties of upcoming video frames.
         * @param data {Uint8Array} the bytes of a sequence parameter set
         * @return {object} an object with configuration parsed from the
         * sequence parameter set, including the dimensions of the
         * associated video frames.
         */
    
      }, {
        key: 'readSPS',
        value: function readSPS() {
          var frameCropLeftOffset = 0,
              frameCropRightOffset = 0,
              frameCropTopOffset = 0,
              frameCropBottomOffset = 0,
              profileIdc,
              profileCompat,
              levelIdc,
              numRefFramesInPicOrderCntCycle,
              picWidthInMbsMinus1,
              picHeightInMapUnitsMinus1,
              frameMbsOnlyFlag,
              scalingListCount,
              i,
              readUByte = this.readUByte.bind(this),
              readBits = this.readBits.bind(this),
              readUEG = this.readUEG.bind(this),
              readBoolean = this.readBoolean.bind(this),
              skipBits = this.skipBits.bind(this),
              skipEG = this.skipEG.bind(this),
              skipUEG = this.skipUEG.bind(this),
              skipScalingList = this.skipScalingList.bind(this);
    
          readUByte();
          profileIdc = readUByte(); // profile_idc
          profileCompat = readBits(5); // constraint_set[0-4]_flag, u(5)
          skipBits(3); // reserved_zero_3bits u(3),
          levelIdc = readUByte(); //level_idc u(8)
          skipUEG(); // seq_parameter_set_id
          // some profiles have more optional data we don't need
          if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
            var chromaFormatIdc = readUEG();
            if (chromaFormatIdc === 3) {
              skipBits(1); // separate_colour_plane_flag
            }
            skipUEG(); // bit_depth_luma_minus8
            skipUEG(); // bit_depth_chroma_minus8
            skipBits(1); // qpprime_y_zero_transform_bypass_flag
            if (readBoolean()) {
              // seq_scaling_matrix_present_flag
              scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
              for (i = 0; i < scalingListCount; i++) {
                if (readBoolean()) {
                  // seq_scaling_list_present_flag[ i ]
                  if (i < 6) {
                    skipScalingList(16);
                  } else {
                    skipScalingList(64);
                  }
                }
              }
            }
          }
          skipUEG(); // log2_max_frame_num_minus4
          var picOrderCntType = readUEG();
          if (picOrderCntType === 0) {
            readUEG(); //log2_max_pic_order_cnt_lsb_minus4
          } else if (picOrderCntType === 1) {
            skipBits(1); // delta_pic_order_always_zero_flag
            skipEG(); // offset_for_non_ref_pic
            skipEG(); // offset_for_top_to_bottom_field
            numRefFramesInPicOrderCntCycle = readUEG();
            for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
              skipEG(); // offset_for_ref_frame[ i ]
            }
          }
          skipUEG(); // max_num_ref_frames
          skipBits(1); // gaps_in_frame_num_value_allowed_flag
          picWidthInMbsMinus1 = readUEG();
          picHeightInMapUnitsMinus1 = readUEG();
          frameMbsOnlyFlag = readBits(1);
          if (frameMbsOnlyFlag === 0) {
            skipBits(1); // mb_adaptive_frame_field_flag
          }
          skipBits(1); // direct_8x8_inference_flag
          if (readBoolean()) {
            // frame_cropping_flag
            frameCropLeftOffset = readUEG();
            frameCropRightOffset = readUEG();
            frameCropTopOffset = readUEG();
            frameCropBottomOffset = readUEG();
          }
          var pixelRatio = [1, 1];
          if (readBoolean()) {
            // vui_parameters_present_flag
            if (readBoolean()) {
              // aspect_ratio_info_present_flag
              var aspectRatioIdc = readUByte();
              switch (aspectRatioIdc) {
                case 1:
                  pixelRatio = [1, 1];break;
                case 2:
                  pixelRatio = [12, 11];break;
                case 3:
                  pixelRatio = [10, 11];break;
                case 4:
                  pixelRatio = [16, 11];break;
                case 5:
                  pixelRatio = [40, 33];break;
                case 6:
                  pixelRatio = [24, 11];break;
                case 7:
                  pixelRatio = [20, 11];break;
                case 8:
                  pixelRatio = [32, 11];break;
                case 9:
                  pixelRatio = [80, 33];break;
                case 10:
                  pixelRatio = [18, 11];break;
                case 11:
                  pixelRatio = [15, 11];break;
                case 12:
                  pixelRatio = [64, 33];break;
                case 13:
                  pixelRatio = [160, 99];break;
                case 14:
                  pixelRatio = [4, 3];break;
                case 15:
                  pixelRatio = [3, 2];break;
                case 16:
                  pixelRatio = [2, 1];break;
                case 255:
                  {
                    pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                    break;
                  }
              }
            }
          }
          return {
            width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
            height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
            pixelRatio: pixelRatio
          };
        }
      }, {
        key: 'readSliceType',
        value: function readSliceType() {
          // skip NALu type
          this.readUByte();
          // discard first_mb_in_slice
          this.readUEG();
          // return slice_type
          return this.readUEG();
        }
      }]);
    
      return ExpGolomb;
    }();
    
    exports.default = ExpGolomb;
    
    },{"51":51}],27:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * ID3 parser
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */
    
    
    var _logger = _dereq_(51);
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    //import Hex from '../utils/hex';
    
    var ID3 = function () {
      function ID3(data) {
        _classCallCheck(this, ID3);
    
        this._hasTimeStamp = false;
        var offset = 0,
            byte1,
            byte2,
            byte3,
            byte4,
            tagSize,
            endPos,
            header,
            len;
        do {
          header = this.readUTF(data, offset, 3);
          offset += 3;
          // first check for ID3 header
          if (header === 'ID3') {
            // skip 24 bits
            offset += 3;
            // retrieve tag(s) length
            byte1 = data[offset++] & 0x7f;
            byte2 = data[offset++] & 0x7f;
            byte3 = data[offset++] & 0x7f;
            byte4 = data[offset++] & 0x7f;
            tagSize = (byte1 << 21) + (byte2 << 14) + (byte3 << 7) + byte4;
            endPos = offset + tagSize;
            //logger.log(`ID3 tag found, size/end: ${tagSize}/${endPos}`);
    
            // read ID3 tags
            this._parseID3Frames(data, offset, endPos);
            offset = endPos;
          } else if (header === '3DI') {
            // http://id3.org/id3v2.4.0-structure chapter 3.4.   ID3v2 footer
            offset += 7;
            _logger.logger.log('3DI footer found, end: ' + offset);
          } else {
            offset -= 3;
            len = offset;
            if (len) {
              //logger.log(`ID3 len: ${len}`);
              if (!this.hasTimeStamp) {
                _logger.logger.warn('ID3 tag found, but no timestamp');
              }
              this._length = len;
              this._payload = data.subarray(0, len);
            }
            return;
          }
        } while (true);
      }
    
      _createClass(ID3, [{
        key: 'readUTF',
        value: function readUTF(data, start, len) {
    
          var result = '',
              offset = start,
              end = start + len;
          do {
            result += String.fromCharCode(data[offset++]);
          } while (offset < end);
          return result;
        }
      }, {
        key: '_parseID3Frames',
        value: function _parseID3Frames(data, offset, endPos) {
          var tagId, tagLen, tagStart, tagFlags, timestamp;
          while (offset + 8 <= endPos) {
            tagId = this.readUTF(data, offset, 4);
            offset += 4;
    
            tagLen = data[offset++] << 24 + data[offset++] << 16 + data[offset++] << 8 + data[offset++];
    
            tagFlags = data[offset++] << 8 + data[offset++];
    
            tagStart = offset;
            //logger.log("ID3 tag id:" + tagId);
            switch (tagId) {
              case 'PRIV':
                //logger.log('parse frame:' + Hex.hexDump(data.subarray(offset,endPos)));
                // owner should be "com.apple.streaming.transportStreamTimestamp"
                if (this.readUTF(data, offset, 44) === 'com.apple.streaming.transportStreamTimestamp') {
                  offset += 44;
                  // smelling even better ! we found the right descriptor
                  // skip null character (string end) + 3 first bytes
                  offset += 4;
    
                  // timestamp is 33 bit expressed as a big-endian eight-octet number, with the upper 31 bits set to zero.
                  var pts33Bit = data[offset++] & 0x1;
                  this._hasTimeStamp = true;
    
                  timestamp = ((data[offset++] << 23) + (data[offset++] << 15) + (data[offset++] << 7) + data[offset++]) / 45;
    
                  if (pts33Bit) {
                    timestamp += 47721858.84; // 2^32 / 90
                  }
                  timestamp = Math.round(timestamp);
                  _logger.logger.trace('ID3 timestamp found: ' + timestamp);
                  this._timeStamp = timestamp;
                }
                break;
              default:
                break;
            }
          }
        }
      }, {
        key: 'hasTimeStamp',
        get: function get() {
          return this._hasTimeStamp;
        }
      }, {
        key: 'timeStamp',
        get: function get() {
          return this._timeStamp;
        }
      }, {
        key: 'length',
        get: function get() {
          return this._length;
        }
      }, {
        key: 'payload',
        get: function get() {
          return this._payload;
        }
      }]);
    
      return ID3;
    }();
    
    exports.default = ID3;
    
    },{"51":51}],28:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * MP4 demuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */
    //import {logger} from '../utils/logger';
    
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var MP4Demuxer = function () {
      function MP4Demuxer(observer, remuxer) {
        _classCallCheck(this, MP4Demuxer);
    
        this.observer = observer;
        this.remuxer = remuxer;
      }
    
      _createClass(MP4Demuxer, [{
        key: 'resetTimeStamp',
        value: function resetTimeStamp() {}
      }, {
        key: 'resetInitSegment',
        value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
          //jshint unused:false
          var initData = this.initData = MP4Demuxer.parseInitSegment(initSegment);
          var tracks = {};
          if (initData.audio) {
            tracks.audio = { container: 'audio/mp4', codec: audioCodec, initSegment: initSegment };
          }
          if (initData.video) {
            tracks.video = { container: 'video/mp4', codec: videoCodec, initSegment: initSegment };
          }
          this.observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, { tracks: tracks });
        }
      }, {
        key: 'append',
    
    
        // feed incoming data to the front of the parsing pipeline
        value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
          var initData = this.initData;
          var startDTS = MP4Demuxer.startDTS(initData, data);
          this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
        }
      }, {
        key: 'destroy',
        value: function destroy() {}
      }], [{
        key: 'probe',
        value: function probe(data) {
          if (data.length >= 8) {
            var dataType = MP4Demuxer.bin2str(data.subarray(4, 8));
            return ['moof', 'ftyp', 'styp'].indexOf(dataType) >= 0;
          }
          return false;
        }
      }, {
        key: 'bin2str',
        value: function bin2str(buffer) {
          return String.fromCharCode.apply(null, buffer);
        }
    
        // Find the data for a box specified by its path
    
      }, {
        key: 'findBox',
        value: function findBox(data, path) {
          var results = [],
              i,
              size,
              type,
              end,
              subresults;
    
          if (!path.length) {
            // short-circuit the search for empty paths
            return null;
          }
    
          for (i = 0; i < data.byteLength;) {
            size = data[i] << 24;
            size |= data[i + 1] << 16;
            size |= data[i + 2] << 8;
            size |= data[i + 3];
    
            type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));
    
            end = size > 1 ? i + size : data.byteLength;
    
            if (type === path[0]) {
              if (path.length === 1) {
                // this is the end of the path and we've found the box we were
                // looking for
                results.push(data.subarray(i + 8, end));
              } else {
                // recursively search for the next box along the path
                subresults = MP4Demuxer.findBox(data.subarray(i + 8, end), path.slice(1));
                if (subresults.length) {
                  results = results.concat(subresults);
                }
              }
            }
            i = end;
          }
    
          // we've finished searching all of data
          return results;
        }
    
        /**
         * Parses an MP4 initialization segment and extracts stream type and
         * timescale values for any declared tracks. Timescale values indicate the
         * number of clock ticks per second to assume for time-based values
         * elsewhere in the MP4.
         *
         * To determine the start time of an MP4, you need two pieces of
         * information: the timescale unit and the earliest base media decode
         * time. Multiple timescales can be specified within an MP4 but the
         * base media decode time is always expressed in the timescale from
         * the media header box for the track:
         * ```
         * moov > trak > mdia > mdhd.timescale
         * moov > trak > mdia > hdlr
         * ```
         * @param init {Uint8Array} the bytes of the init segment
         * @return {object} a hash of track type to timescale values or null if
         * the init segment is malformed.
         */
    
      }, {
        key: 'parseInitSegment',
        value: function parseInitSegment(initSegment) {
          var result = [];
          var traks = MP4Demuxer.findBox(initSegment, ['moov', 'trak']);
    
          traks.forEach(function (trak) {
            var tkhd = MP4Demuxer.findBox(trak, ['tkhd'])[0];
            if (tkhd) {
              var version = tkhd[0];
              var index = version === 0 ? 12 : 20;
              var trackId = tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3];
    
              trackId = trackId < 0 ? 4294967296 + trackId : trackId;
    
              var mdhd = MP4Demuxer.findBox(trak, ['mdia', 'mdhd'])[0];
              if (mdhd) {
                version = mdhd[0];
                index = version === 0 ? 12 : 20;
                var timescale = mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3];
    
                var hdlr = MP4Demuxer.findBox(trak, ['mdia', 'hdlr'])[0];
                if (hdlr) {
                  var hdlrType = MP4Demuxer.bin2str(hdlr.subarray(8, 12));
                  var type = { 'soun': 'audio', 'vide': 'video' }[hdlrType];
                  if (type) {
                    result[trackId] = { timescale: timescale, type: type };
                    result[type] = { timescale: timescale, id: trackId };
                  }
                }
              }
            }
          });
          return result;
        }
    
        /**
         * Determine the base media decode start time, in seconds, for an MP4
         * fragment. If multiple fragments are specified, the earliest time is
         * returned.
         *
         * The base media decode time can be parsed from track fragment
         * metadata:
         * ```
         * moof > traf > tfdt.baseMediaDecodeTime
         * ```
         * It requires the timescale value from the mdhd to interpret.
         *
         * @param timescale {object} a hash of track ids to timescale values.
         * @return {number} the earliest base media decode start time for the
         * fragment, in seconds
         */
    
      }, {
        key: 'startDTS',
        value: function startDTS(initData, fragment) {
          var trafs, baseTimes, result;
    
          // we need info from two childrend of each track fragment box
          trafs = MP4Demuxer.findBox(fragment, ['moof', 'traf']);
    
          // determine the start times for each track
          baseTimes = [].concat.apply([], trafs.map(function (traf) {
            return MP4Demuxer.findBox(traf, ['tfhd']).map(function (tfhd) {
              var id, scale, baseTime;
    
              // get the track id from the tfhd
              id = tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7];
              // assume a 90kHz clock if no timescale was specified
              scale = initData[id].timescale || 90e3;
    
              // get the base media decode time from the tfdt
              baseTime = MP4Demuxer.findBox(traf, ['tfdt']).map(function (tfdt) {
                var version, result;
    
                version = tfdt[0];
                result = tfdt[4] << 24 | tfdt[5] << 16 | tfdt[6] << 8 | tfdt[7];
                if (version === 1) {
                  result *= Math.pow(2, 32);
                  result += tfdt[8] << 24 | tfdt[9] << 16 | tfdt[10] << 8 | tfdt[11];
                }
                return result;
              })[0];
              baseTime = baseTime || Infinity;
    
              // convert base time to seconds
              return baseTime / scale;
            });
          }));
    
          // return the minimum
          result = Math.min.apply(null, baseTimes);
          return isFinite(result) ? result : 0;
        }
      }]);
    
      return MP4Demuxer;
    }();
    
    exports.default = MP4Demuxer;
    
    },{"33":33}],29:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * SAMPLE-AES decrypter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         */
    
    var _decrypter = _dereq_(19);
    
    var _decrypter2 = _interopRequireDefault(_decrypter);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var SampleAesDecrypter = function () {
      function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
        _classCallCheck(this, SampleAesDecrypter);
    
        this.decryptdata = decryptdata;
        this.discardEPB = discardEPB;
        this.decrypter = new _decrypter2.default(observer, config);
      }
    
      _createClass(SampleAesDecrypter, [{
        key: 'decryptBuffer',
        value: function decryptBuffer(encryptedData, callback) {
          this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
        }
    
        // AAC - encrypt all full 16 bytes blocks starting from offset 16
    
      }, {
        key: 'decryptAacSample',
        value: function decryptAacSample(samples, sampleIndex, callback, sync) {
          var curUnit = samples[sampleIndex].unit;
          var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
          var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
    
          var localthis = this;
          this.decryptBuffer(encryptedBuffer, function (decryptedData) {
            decryptedData = new Uint8Array(decryptedData);
            curUnit.set(decryptedData, 16);
    
            if (!sync) {
              localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
            }
          });
        }
      }, {
        key: 'decryptAacSamples',
        value: function decryptAacSamples(samples, sampleIndex, callback) {
          for (;; sampleIndex++) {
            if (sampleIndex >= samples.length) {
              callback();
              return;
            }
    
            if (samples[sampleIndex].unit.length < 32) {
              continue;
            }
    
            var sync = this.decrypter.isSync();
    
            this.decryptAacSample(samples, sampleIndex, callback, sync);
    
            if (!sync) {
              return;
            }
          }
        }
    
        // AVC - encrypt one 16 bytes block out of ten, starting from offset 32
    
      }, {
        key: 'getAvcEncryptedData',
        value: function getAvcEncryptedData(decodedData) {
          var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
          var encryptedData = new Int8Array(encryptedDataLen);
          var outputPos = 0;
          for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
            encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
          }
          return encryptedData;
        }
      }, {
        key: 'getAvcDecryptedUnit',
        value: function getAvcDecryptedUnit(decodedData, decryptedData) {
          decryptedData = new Uint8Array(decryptedData);
          var inputPos = 0;
          for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
            decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
          }
          return decodedData;
        }
      }, {
        key: 'decryptAvcSample',
        value: function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
          var decodedData = this.discardEPB(curUnit.data);
          var encryptedData = this.getAvcEncryptedData(decodedData);
          var localthis = this;
    
          this.decryptBuffer(encryptedData.buffer, function (decryptedData) {
            curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);
    
            if (!sync) {
              localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
            }
          });
        }
      }, {
        key: 'decryptAvcSamples',
        value: function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
          for (;; sampleIndex++, unitIndex = 0) {
            if (sampleIndex >= samples.length) {
              callback();
              return;
            }
    
            var curUnits = samples[sampleIndex].units;
            for (;; unitIndex++) {
              if (unitIndex >= curUnits.length) {
                break;
              }
    
              var curUnit = curUnits[unitIndex];
              if (curUnit.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
                continue;
              }
    
              var sync = this.decrypter.isSync();
    
              this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);
    
              if (!sync) {
                return;
              }
            }
          }
        }
      }]);
    
      return SampleAesDecrypter;
    }();
    
    exports.default = SampleAesDecrypter;
    
    },{"19":19}],30:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * highly optimized TS demuxer:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * parse PAT, PMT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * extract PES packet from audio and video PIDs
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * extract AVC/H264 NAL units and AAC/ADTS samples from PES packet
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * trigger the remuxer upon parsing completion
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * it also tries to workaround as best as it can audio codec switch (HE-AAC to AAC and vice versa), without having to restart the MediaSource.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * it also controls the remuxing process :
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * upon discontinuity or level switch detection, it will also notifies the remuxer so that it can reset its state.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         */
    
    // import Hex from '../utils/hex';
    
    
    var _adts = _dereq_(22);
    
    var _adts2 = _interopRequireDefault(_adts);
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _expGolomb = _dereq_(26);
    
    var _expGolomb2 = _interopRequireDefault(_expGolomb);
    
    var _sampleAes = _dereq_(29);
    
    var _sampleAes2 = _interopRequireDefault(_sampleAes);
    
    var _logger = _dereq_(51);
    
    var _errors = _dereq_(31);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var TSDemuxer = function () {
      function TSDemuxer(observer, remuxer, config, typeSupported) {
        _classCallCheck(this, TSDemuxer);
    
        this.observer = observer;
        this.config = config;
        this.typeSupported = typeSupported;
        this.remuxer = remuxer;
        this.sampleAes = null;
      }
    
      _createClass(TSDemuxer, [{
        key: 'setDecryptData',
        value: function setDecryptData(decryptdata) {
          if (decryptdata != null && decryptdata.key != null && decryptdata.method === 'SAMPLE-AES') {
            this.sampleAes = new _sampleAes2.default(this.observer, this.config, decryptdata, this.discardEPB);
          } else {
            this.sampleAes = null;
          }
        }
      }, {
        key: 'resetInitSegment',
        value: function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
          this.pmtParsed = false;
          this._pmtId = -1;
          this._avcTrack = { container: 'video/mp2t', type: 'video', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0, dropped: 0 };
          this._audioTrack = { container: 'video/mp2t', type: 'audio', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0, isAAC: true };
          this._id3Track = { type: 'id3', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0 };
          this._txtTrack = { type: 'text', id: -1, inputTimeScale: 90000, sequenceNumber: 0, samples: [], len: 0 };
          // flush any partial content
          this.aacOverFlow = null;
          this.aacLastPTS = null;
          this.avcSample = null;
          this.audioCodec = audioCodec;
          this.videoCodec = videoCodec;
          this._duration = duration;
        }
      }, {
        key: 'resetTimeStamp',
        value: function resetTimeStamp() {}
    
        // feed incoming data to the front of the parsing pipeline
    
      }, {
        key: 'append',
        value: function append(data, timeOffset, contiguous, accurateTimeOffset) {
          var start,
              len = data.length,
              stt,
              pid,
              atf,
              offset,
              pes,
              unknownPIDs = false;
          this.contiguous = contiguous;
          var pmtParsed = this.pmtParsed,
              avcTrack = this._avcTrack,
              audioTrack = this._audioTrack,
              id3Track = this._id3Track,
              avcId = avcTrack.id,
              audioId = audioTrack.id,
              id3Id = id3Track.id,
              pmtId = this._pmtId,
              avcData = avcTrack.pesData,
              audioData = audioTrack.pesData,
              id3Data = id3Track.pesData,
              parsePAT = this._parsePAT,
              parsePMT = this._parsePMT,
              parsePES = this._parsePES,
              parseAVCPES = this._parseAVCPES.bind(this),
              parseAACPES = this._parseAACPES.bind(this),
              parseMPEGPES = this._parseMPEGPES.bind(this),
              parseID3PES = this._parseID3PES.bind(this);
    
          // don't parse last TS packet if incomplete
          len -= len % 188;
          // loop through TS packets
          for (start = 0; start < len; start += 188) {
            if (data[start] === 0x47) {
              stt = !!(data[start + 1] & 0x40);
              // pid is a 13-bit field starting at the last bit of TS[1]
              pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];
              atf = (data[start + 3] & 0x30) >> 4;
              // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.
              if (atf > 1) {
                offset = start + 5 + data[start + 4];
                // continue if there is only adaptation field
                if (offset === start + 188) {
                  continue;
                }
              } else {
                offset = start + 4;
              }
              switch (pid) {
                case avcId:
                  if (stt) {
                    if (avcData && (pes = parsePES(avcData))) {
                      parseAVCPES(pes, false);
                    }
                    avcData = { data: [], size: 0 };
                  }
                  if (avcData) {
                    avcData.data.push(data.subarray(offset, start + 188));
                    avcData.size += start + 188 - offset;
                  }
                  break;
                case audioId:
                  if (stt) {
                    if (audioData && (pes = parsePES(audioData))) {
                      if (audioTrack.isAAC) {
                        parseAACPES(pes);
                      } else {
                        parseMPEGPES(pes);
                      }
                    }
                    audioData = { data: [], size: 0 };
                  }
                  if (audioData) {
                    audioData.data.push(data.subarray(offset, start + 188));
                    audioData.size += start + 188 - offset;
                  }
                  break;
                case id3Id:
                  if (stt) {
                    if (id3Data && (pes = parsePES(id3Data))) {
                      parseID3PES(pes);
                    }
                    id3Data = { data: [], size: 0 };
                  }
                  if (id3Data) {
                    id3Data.data.push(data.subarray(offset, start + 188));
                    id3Data.size += start + 188 - offset;
                  }
                  break;
                case 0:
                  if (stt) {
                    offset += data[offset] + 1;
                  }
                  pmtId = this._pmtId = parsePAT(data, offset);
                  break;
                case pmtId:
                  if (stt) {
                    offset += data[offset] + 1;
                  }
                  var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);
    
                  // only update track id if track PID found while parsing PMT
                  // this is to avoid resetting the PID to -1 in case
                  // track PID transiently disappears from the stream
                  // this could happen in case of transient missing audio samples for example
                  avcId = parsedPIDs.avc;
                  if (avcId > 0) {
                    avcTrack.id = avcId;
                  }
                  audioId = parsedPIDs.audio;
                  if (audioId > 0) {
                    audioTrack.id = audioId;
                    audioTrack.isAAC = parsedPIDs.isAAC;
                  }
                  id3Id = parsedPIDs.id3;
                  if (id3Id > 0) {
                    id3Track.id = id3Id;
                  }
                  if (unknownPIDs && !pmtParsed) {
                    _logger.logger.log('reparse from beginning');
                    unknownPIDs = false;
                    // we set it to -188, the += 188 in the for loop will reset start to 0
                    start = -188;
                  }
                  pmtParsed = this.pmtParsed = true;
                  break;
                case 17:
                case 0x1fff:
                  break;
                default:
                  unknownPIDs = true;
                  break;
              }
            } else {
              this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'TS packet did not start with 0x47' });
            }
          }
          // try to parse last PES packets
          if (avcData && (pes = parsePES(avcData))) {
            parseAVCPES(pes, true);
            avcTrack.pesData = null;
          } else {
            // either avcData null or PES truncated, keep it for next frag parsing
            avcTrack.pesData = avcData;
          }
    
          if (audioData && (pes = parsePES(audioData))) {
            if (audioTrack.isAAC) {
              parseAACPES(pes);
            } else {
              parseMPEGPES(pes);
            }
            audioTrack.pesData = null;
          } else {
            if (audioData && audioData.size) {
              _logger.logger.log('last AAC PES packet truncated,might overlap between fragments');
            }
            // either audioData null or PES truncated, keep it for next frag parsing
            audioTrack.pesData = audioData;
          }
    
          if (id3Data && (pes = parsePES(id3Data))) {
            parseID3PES(pes);
            id3Track.pesData = null;
          } else {
            // either id3Data null or PES truncated, keep it for next frag parsing
            id3Track.pesData = id3Data;
          }
    
          if (this.sampleAes == null) {
            this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
          } else {
            this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
          }
        }
      }, {
        key: 'decryptAndRemux',
        value: function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
          if (audioTrack.samples && audioTrack.isAAC) {
            var localthis = this;
            this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function () {
              localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
            });
          } else {
            this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
          }
        }
      }, {
        key: 'decryptAndRemuxAvc',
        value: function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
          if (videoTrack.samples) {
            var localthis = this;
            this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function () {
              localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
            });
          } else {
            this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
          }
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          this._initPTS = this._initDTS = undefined;
          this._duration = 0;
        }
      }, {
        key: '_parsePAT',
        value: function _parsePAT(data, offset) {
          // skip the PSI header and parse the first PMT entry
          return (data[offset + 10] & 0x1F) << 8 | data[offset + 11];
          //logger.log('PMT PID:'  + this._pmtId);
        }
      }, {
        key: '_parsePMT',
        value: function _parsePMT(data, offset, mpegSupported, isSampleAes) {
          var sectionLength,
              tableEnd,
              programInfoLength,
              pid,
              result = { audio: -1, avc: -1, id3: -1, isAAC: true };
          sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];
          tableEnd = offset + 3 + sectionLength - 4;
          // to determine where the table is, we have to figure out how
          // long the program info descriptors are
          programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];
          // advance the offset to the first entry in the mapping table
          offset += 12 + programInfoLength;
          while (offset < tableEnd) {
            pid = (data[offset + 1] & 0x1F) << 8 | data[offset + 2];
            switch (data[offset]) {
              case 0xcf:
                // SAMPLE-AES AAC
                if (!isSampleAes) {
                  _logger.logger.log('unkown stream type:' + data[offset]);
                  break;
                }
              /* falls through */
    
              // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)
              case 0x0f:
                //logger.log('AAC PID:'  + pid);
                if (result.audio === -1) {
                  result.audio = pid;
                }
                break;
    
              // Packetized metadata (ID3)
              case 0x15:
                //logger.log('ID3 PID:'  + pid);
                if (result.id3 === -1) {
                  result.id3 = pid;
                }
                break;
    
              case 0xdb:
                // SAMPLE-AES AVC
                if (!isSampleAes) {
                  _logger.logger.log('unkown stream type:' + data[offset]);
                  break;
                }
              /* falls through */
    
              // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)
              case 0x1b:
                //logger.log('AVC PID:'  + pid);
                if (result.avc === -1) {
                  result.avc = pid;
                }
                break;
    
              // ISO/IEC 11172-3 (MPEG-1 audio)
              // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)
              case 0x03:
              case 0x04:
                //logger.log('MPEG PID:'  + pid);
                if (!mpegSupported) {
                  _logger.logger.log('MPEG audio found, not supported in this browser for now');
                } else if (result.audio === -1) {
                  result.audio = pid;
                  result.isAAC = false;
                }
                break;
    
              case 0x24:
                _logger.logger.warn('HEVC stream type found, not supported for now');
                break;
    
              default:
                _logger.logger.log('unkown stream type:' + data[offset]);
                break;
            }
            // move to the next table entry
            // skip past the elementary stream descriptors, if present
            offset += ((data[offset + 3] & 0x0F) << 8 | data[offset + 4]) + 5;
          }
          return result;
        }
      }, {
        key: '_parsePES',
        value: function _parsePES(stream) {
          var i = 0,
              frag,
              pesFlags,
              pesPrefix,
              pesLen,
              pesHdrLen,
              pesData,
              pesPts,
              pesDts,
              payloadStartOffset,
              data = stream.data;
          // safety check
          if (!stream || stream.size === 0) {
            return null;
          }
    
          // we might need up to 19 bytes to read PES header
          // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes
          // usually only one merge is needed (and this is rare ...)
          while (data[0].length < 19 && data.length > 1) {
            var newData = new Uint8Array(data[0].length + data[1].length);
            newData.set(data[0]);
            newData.set(data[1], data[0].length);
            data[0] = newData;
            data.splice(1, 1);
          }
          //retrieve PTS/DTS from first fragment
          frag = data[0];
          pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
          if (pesPrefix === 1) {
            pesLen = (frag[4] << 8) + frag[5];
            // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated
            // minus 6 : PES header size
            if (pesLen && pesLen > stream.size - 6) {
              return null;
            }
            pesFlags = frag[7];
            if (pesFlags & 0xC0) {
              /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html
                  as PTS / DTS is 33 bit we cannot use bitwise operator in JS,
                  as Bitwise operators treat their operands as a sequence of 32 bits */
              pesPts = (frag[9] & 0x0E) * 536870912 + // 1 << 29
              (frag[10] & 0xFF) * 4194304 + // 1 << 22
              (frag[11] & 0xFE) * 16384 + // 1 << 14
              (frag[12] & 0xFF) * 128 + // 1 << 7
              (frag[13] & 0xFE) / 2;
              // check if greater than 2^32 -1
              if (pesPts > 4294967295) {
                // decrement 2^33
                pesPts -= 8589934592;
              }
              if (pesFlags & 0x40) {
                pesDts = (frag[14] & 0x0E) * 536870912 + // 1 << 29
                (frag[15] & 0xFF) * 4194304 + // 1 << 22
                (frag[16] & 0xFE) * 16384 + // 1 << 14
                (frag[17] & 0xFF) * 128 + // 1 << 7
                (frag[18] & 0xFE) / 2;
                // check if greater than 2^32 -1
                if (pesDts > 4294967295) {
                  // decrement 2^33
                  pesDts -= 8589934592;
                }
                if (pesPts - pesDts > 60 * 90000) {
                  _logger.logger.warn(Math.round((pesPts - pesDts) / 90000) + 's delta between PTS and DTS, align them');
                  pesPts = pesDts;
                }
              } else {
                pesDts = pesPts;
              }
            }
            pesHdrLen = frag[8];
            // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension
            payloadStartOffset = pesHdrLen + 9;
    
            stream.size -= payloadStartOffset;
            //reassemble PES packet
            pesData = new Uint8Array(stream.size);
            for (var j = 0, dataLen = data.length; j < dataLen; j++) {
              frag = data[j];
              var len = frag.byteLength;
              if (payloadStartOffset) {
                if (payloadStartOffset > len) {
                  // trim full frag if PES header bigger than frag
                  payloadStartOffset -= len;
                  continue;
                } else {
                  // trim partial frag if PES header smaller than frag
                  frag = frag.subarray(payloadStartOffset);
                  len -= payloadStartOffset;
                  payloadStartOffset = 0;
                }
              }
              pesData.set(frag, i);
              i += len;
            }
            if (pesLen) {
              // payload size : remove PES header + PES extension
              pesLen -= pesHdrLen + 3;
            }
            return { data: pesData, pts: pesPts, dts: pesDts, len: pesLen };
          } else {
            return null;
          }
        }
      }, {
        key: 'pushAccesUnit',
        value: function pushAccesUnit(avcSample, avcTrack) {
          if (avcSample.units.length && avcSample.frame) {
            var samples = avcTrack.samples;
            var nbSamples = samples.length;
            // only push AVC sample if starting with a keyframe is not mandatory OR
            //    if keyframe already found in this fragment OR
            //       keyframe found in last fragment (track.sps) AND
            //          samples already appended (we already found a keyframe in this fragment) OR fragment is contiguous
            if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (nbSamples || this.contiguous)) {
              avcSample.id = nbSamples;
              samples.push(avcSample);
            } else {
              // dropped samples, track it
              avcTrack.dropped++;
            }
          }
          if (avcSample.debug.length) {
            _logger.logger.log(avcSample.pts + '/' + avcSample.dts + ':' + avcSample.debug);
          }
        }
      }, {
        key: '_parseAVCPES',
        value: function _parseAVCPES(pes, last) {
          var _this = this;
    
          //logger.log('parse new PES');
          var track = this._avcTrack,
              units = this._parseAVCNALu(pes.data),
              debug = false,
              expGolombDecoder,
              avcSample = this.avcSample,
              push,
              i;
          //free pes.data to save up some memory
          pes.data = null;
    
          units.forEach(function (unit) {
            switch (unit.type) {
              //NDR
              case 1:
                push = true;
                if (debug && avcSample) {
                  avcSample.debug += 'NDR ';
                }
                avcSample.frame = true;
                // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR
                var data = unit.data;
                if (data.length > 4) {
                  var sliceType = new _expGolomb2.default(data).readSliceType();
                  // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice
                  // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.
                  // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.
                  // I slice: A slice that is not an SI slice that is decoded using intra prediction only.
                  //if (sliceType === 2 || sliceType === 7) {
                  if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                    avcSample.key = true;
                  }
                }
                break;
              //IDR
              case 5:
                push = true;
                // handle PES not starting with AUD
                if (!avcSample) {
                  avcSample = _this.avcSample = _this._createAVCSample(true, pes.pts, pes.dts, '');
                }
                if (debug) {
                  avcSample.debug += 'IDR ';
                }
                avcSample.key = true;
                avcSample.frame = true;
                break;
              //SEI
              case 6:
                push = true;
                if (debug && avcSample) {
                  avcSample.debug += 'SEI ';
                }
                expGolombDecoder = new _expGolomb2.default(_this.discardEPB(unit.data));
    
                // skip frameType
                expGolombDecoder.readUByte();
    
                var payloadType = 0;
                var payloadSize = 0;
                var endOfCaptions = false;
                var b = 0;
    
                while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
                  payloadType = 0;
                  do {
                    b = expGolombDecoder.readUByte();
                    payloadType += b;
                  } while (b === 0xFF);
    
                  // Parse payload size.
                  payloadSize = 0;
                  do {
                    b = expGolombDecoder.readUByte();
                    payloadSize += b;
                  } while (b === 0xFF);
    
                  // TODO: there can be more than one payload in an SEI packet...
                  // TODO: need to read type and size in a while loop to get them all
                  if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {
    
                    endOfCaptions = true;
    
                    var countryCode = expGolombDecoder.readUByte();
    
                    if (countryCode === 181) {
                      var providerCode = expGolombDecoder.readUShort();
    
                      if (providerCode === 49) {
                        var userStructure = expGolombDecoder.readUInt();
    
                        if (userStructure === 0x47413934) {
                          var userDataType = expGolombDecoder.readUByte();
    
                          // Raw CEA-608 bytes wrapped in CEA-708 packet
                          if (userDataType === 3) {
                            var firstByte = expGolombDecoder.readUByte();
                            var secondByte = expGolombDecoder.readUByte();
    
                            var totalCCs = 31 & firstByte;
                            var byteArray = [firstByte, secondByte];
    
                            for (i = 0; i < totalCCs; i++) {
                              // 3 bytes per CC
                              byteArray.push(expGolombDecoder.readUByte());
                              byteArray.push(expGolombDecoder.readUByte());
                              byteArray.push(expGolombDecoder.readUByte());
                            }
    
                            _this._insertSampleInOrder(_this._txtTrack.samples, { type: 3, pts: pes.pts, bytes: byteArray });
                          }
                        }
                      }
                    }
                  } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                    for (i = 0; i < payloadSize; i++) {
                      expGolombDecoder.readUByte();
                    }
                  }
                }
                break;
              //SPS
              case 7:
                push = true;
                if (debug && avcSample) {
                  avcSample.debug += 'SPS ';
                }
                if (!track.sps) {
                  expGolombDecoder = new _expGolomb2.default(unit.data);
                  var config = expGolombDecoder.readSPS();
                  track.width = config.width;
                  track.height = config.height;
                  track.pixelRatio = config.pixelRatio;
                  track.sps = [unit.data];
                  track.duration = _this._duration;
                  var codecarray = unit.data.subarray(1, 4);
                  var codecstring = 'avc1.';
                  for (i = 0; i < 3; i++) {
                    var h = codecarray[i].toString(16);
                    if (h.length < 2) {
                      h = '0' + h;
                    }
                    codecstring += h;
                  }
                  track.codec = codecstring;
                }
                break;
              //PPS
              case 8:
                push = true;
                if (debug && avcSample) {
                  avcSample.debug += 'PPS ';
                }
                if (!track.pps) {
                  track.pps = [unit.data];
                }
                break;
              // AUD
              case 9:
                push = false;
                if (avcSample) {
                  _this.pushAccesUnit(avcSample, track);
                }
                avcSample = _this.avcSample = _this._createAVCSample(false, pes.pts, pes.dts, debug ? 'AUD ' : '');
                break;
              // Filler Data
              case 12:
                push = false;
                break;
              default:
                push = false;
                if (avcSample) {
                  avcSample.debug += 'unknown NAL ' + unit.type + ' ';
                }
                break;
            }
            if (avcSample && push) {
              var _units = avcSample.units;
              _units.push(unit);
            }
          });
          // if last PES packet, push samples
          if (last && avcSample) {
            this.pushAccesUnit(avcSample, track);
            this.avcSample = null;
          }
        }
      }, {
        key: '_createAVCSample',
        value: function _createAVCSample(key, pts, dts, debug) {
          return { key: key, pts: pts, dts: dts, units: [], debug: debug };
        }
      }, {
        key: '_insertSampleInOrder',
        value: function _insertSampleInOrder(arr, data) {
          var len = arr.length;
          if (len > 0) {
            if (data.pts >= arr[len - 1].pts) {
              arr.push(data);
            } else {
              for (var pos = len - 1; pos >= 0; pos--) {
                if (data.pts < arr[pos].pts) {
                  arr.splice(pos, 0, data);
                  break;
                }
              }
            }
          } else {
            arr.push(data);
          }
        }
      }, {
        key: '_getLastNalUnit',
        value: function _getLastNalUnit() {
          var avcSample = this.avcSample,
              lastUnit = void 0;
          // try to fallback to previous sample if current one is empty
          if (!avcSample || avcSample.units.length === 0) {
            var track = this._avcTrack,
                samples = track.samples;
            avcSample = samples[samples.length - 1];
          }
          if (avcSample) {
            var units = avcSample.units;
            lastUnit = units[units.length - 1];
          }
          return lastUnit;
        }
      }, {
        key: '_parseAVCNALu',
        value: function _parseAVCNALu(array) {
          var i = 0,
              len = array.byteLength,
              value,
              overflow,
              track = this._avcTrack,
              state = track.naluState || 0,
              lastState = state;
          var units = [],
              unit,
              unitType,
              lastUnitStart = -1,
              lastUnitType;
          //logger.log('PES:' + Hex.hexDump(array));
    
          if (state === -1) {
            // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet
            lastUnitStart = 0;
            // NALu type is value read from offset 0
            lastUnitType = array[0] & 0x1f;
            state = 0;
            i = 1;
          }
    
          while (i < len) {
            value = array[i++];
            // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case
            if (!state) {
              state = value ? 0 : 1;
              continue;
            }
            if (state === 1) {
              state = value ? 0 : 2;
              continue;
            }
            // here we have state either equal to 2 or 3
            if (!value) {
              state = 3;
            } else if (value === 1) {
              if (lastUnitStart >= 0) {
                unit = { data: array.subarray(lastUnitStart, i - state - 1), type: lastUnitType };
                //logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);
                units.push(unit);
              } else {
                // lastUnitStart is undefined => this is the first start code found in this PES packet
                // first check if start code delimiter is overlapping between 2 PES packets,
                // ie it started in last packet (lastState not zero)
                // and ended at the beginning of this PES packet (i <= 4 - lastState)
                var lastUnit = this._getLastNalUnit();
                if (lastUnit) {
                  if (lastState && i <= 4 - lastState) {
                    // start delimiter overlapping between PES packets
                    // strip start delimiter bytes from the end of last NAL unit
                    // check if lastUnit had a state different from zero
                    if (lastUnit.state) {
                      // strip last bytes
                      lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                    }
                  }
                  // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.
                  overflow = i - state - 1;
                  if (overflow > 0) {
                    //logger.log('first NALU found with overflow:' + overflow);
                    var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                    tmp.set(lastUnit.data, 0);
                    tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                    lastUnit.data = tmp;
                  }
                }
              }
              // check if we can read unit type
              if (i < len) {
                unitType = array[i] & 0x1f;
                //logger.log('find NALU @ offset:' + i + ',type:' + unitType);
                lastUnitStart = i;
                lastUnitType = unitType;
                state = 0;
              } else {
                // not enough byte to read unit type. let's read it on next PES parsing
                state = -1;
              }
            } else {
              state = 0;
            }
          }
          if (lastUnitStart >= 0 && state >= 0) {
            unit = { data: array.subarray(lastUnitStart, len), type: lastUnitType, state: state };
            units.push(unit);
            //logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);
          }
          // no NALu found
          if (units.length === 0) {
            // append pes.data to previous NAL unit
            var _lastUnit = this._getLastNalUnit();
            if (_lastUnit) {
              var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
              _tmp.set(_lastUnit.data, 0);
              _tmp.set(array, _lastUnit.data.byteLength);
              _lastUnit.data = _tmp;
            }
          }
          track.naluState = state;
          return units;
        }
    
        /**
         * remove Emulation Prevention bytes from a RBSP
         */
    
      }, {
        key: 'discardEPB',
        value: function discardEPB(data) {
          var length = data.byteLength,
              EPBPositions = [],
              i = 1,
              newLength,
              newData;
    
          // Find all `Emulation Prevention Bytes`
          while (i < length - 2) {
            if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {
              EPBPositions.push(i + 2);
              i += 2;
            } else {
              i++;
            }
          }
    
          // If no Emulation Prevention Bytes were found just return the original
          // array
          if (EPBPositions.length === 0) {
            return data;
          }
    
          // Create a new array to hold the NAL unit data
          newLength = length - EPBPositions.length;
          newData = new Uint8Array(newLength);
          var sourceIndex = 0;
    
          for (i = 0; i < newLength; sourceIndex++, i++) {
            if (sourceIndex === EPBPositions[0]) {
              // Skip this byte
              sourceIndex++;
              // Remove this position index
              EPBPositions.shift();
            }
            newData[i] = data[sourceIndex];
          }
          return newData;
        }
      }, {
        key: '_parseAACPES',
        value: function _parseAACPES(pes) {
          var track = this._audioTrack,
              data = pes.data,
              pts = pes.pts,
              startOffset = 0,
              aacOverFlow = this.aacOverFlow,
              aacLastPTS = this.aacLastPTS,
              config,
              frameLength,
              frameDuration,
              frameIndex,
              offset,
              headerLength,
              stamp,
              len,
              aacSample;
          if (aacOverFlow) {
            var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
            tmp.set(aacOverFlow, 0);
            tmp.set(data, aacOverFlow.byteLength);
            //logger.log(`AAC: append overflowing ${aacOverFlow.byteLength} bytes to beginning of new PES`);
            data = tmp;
          }
          // look for ADTS header (0xFFFx)
          for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
            if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
              break;
            }
          }
          // if ADTS header does not start straight from the beginning of the PES payload, raise an error
          if (offset) {
            var reason, fatal;
            if (offset < len - 1) {
              reason = 'AAC PES did not start with ADTS header,offset:' + offset;
              fatal = false;
            } else {
              reason = 'no ADTS header found in AAC PES';
              fatal = true;
            }
            _logger.logger.warn('parsing error:' + reason);
            this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: fatal, reason: reason });
            if (fatal) {
              return;
            }
          }
          if (!track.samplerate) {
            var audioCodec = this.audioCodec;
            config = _adts2.default.getAudioConfig(this.observer, data, offset, audioCodec);
            track.config = config.config;
            track.samplerate = config.samplerate;
            track.channelCount = config.channelCount;
            track.codec = config.codec;
            track.manifestCodec = config.manifestCodec;
            track.duration = this._duration;
            _logger.logger.log('parsed codec:' + track.codec + ',rate:' + config.samplerate + ',nb channel:' + config.channelCount);
          }
          frameIndex = 0;
          frameDuration = 1024 * 90000 / track.samplerate;
    
          // if last AAC frame is overflowing, we should ensure timestamps are contiguous:
          // first sample PTS should be equal to last sample PTS + frameDuration
          if (aacOverFlow && aacLastPTS) {
            var newPTS = aacLastPTS + frameDuration;
            if (Math.abs(newPTS - pts) > 1) {
              _logger.logger.log('AAC: align PTS for overlapping frames by ' + Math.round((newPTS - pts) / 90));
              pts = newPTS;
            }
          }
    
          while (offset + 5 < len) {
            // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header
            headerLength = !!(data[offset + 1] & 0x01) ? 7 : 9;
            // retrieve frame size
            frameLength = (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xE0) >>> 5;
            frameLength -= headerLength;
            //stamp = pes.pts;
    
            if (frameLength > 0 && offset + headerLength + frameLength <= len) {
              stamp = pts + frameIndex * frameDuration;
              //logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}/${(stamp/90).toFixed(0)}`);
              aacSample = { unit: data.subarray(offset + headerLength, offset + headerLength + frameLength), pts: stamp, dts: stamp };
              track.samples.push(aacSample);
              track.len += frameLength;
              offset += frameLength + headerLength;
              frameIndex++;
              // look for ADTS header (0xFFFx)
              for (; offset < len - 1; offset++) {
                if (data[offset] === 0xff && (data[offset + 1] & 0xf0) === 0xf0) {
                  break;
                }
              }
            } else {
              break;
            }
          }
          if (offset < len) {
            aacOverFlow = data.subarray(offset, len);
            //logger.log(`AAC: overflow detected:${len-offset}`);
          } else {
            aacOverFlow = null;
          }
          this.aacOverFlow = aacOverFlow;
          this.aacLastPTS = stamp;
        }
      }, {
        key: '_parseMPEGPES',
        value: function _parseMPEGPES(pes) {
          var data = pes.data;
          var pts = pes.pts;
          var length = data.length;
          var frameIndex = 0;
          var offset = 0;
          var parsed;
    
          while (offset < length && (parsed = this._parseMpeg(data, offset, length, frameIndex++, pts)) > 0) {
            offset += parsed;
          }
        }
      }, {
        key: '_onMpegFrame',
        value: function _onMpegFrame(data, bitRate, sampleRate, channelCount, frameIndex, pts) {
          var frameDuration = 1152 / sampleRate * 1000;
          var stamp = pts + frameIndex * frameDuration;
          var track = this._audioTrack;
    
          track.config = [];
          track.channelCount = channelCount;
          track.samplerate = sampleRate;
          track.duration = this._duration;
          track.samples.push({ unit: data, pts: stamp, dts: stamp });
          track.len += data.length;
        }
      }, {
        key: '_onMpegNoise',
        value: function _onMpegNoise(data) {
          _logger.logger.warn('mpeg audio has noise: ' + data.length + ' bytes');
        }
      }, {
        key: '_parseMpeg',
        value: function _parseMpeg(data, start, end, frameIndex, pts) {
          var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
          var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];
    
          if (start + 2 > end) {
            return -1; // we need at least 2 bytes to detect sync pattern
          }
          if (data[start] === 0xFF || (data[start + 1] & 0xE0) === 0xE0) {
            // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference
            if (start + 24 > end) {
              return -1;
            }
            var headerB = data[start + 1] >> 3 & 3;
            var headerC = data[start + 1] >> 1 & 3;
            var headerE = data[start + 2] >> 4 & 15;
            var headerF = data[start + 2] >> 2 & 3;
            var headerG = !!(data[start + 2] & 2);
            if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
              var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
              var bitRate = BitratesMap[columnInBitrates * 14 + headerE - 1] * 1000;
              var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
              var sampleRate = SamplingRateMap[columnInSampleRates * 3 + headerF];
              var padding = headerG ? 1 : 0;
              var channelCount = data[start + 3] >> 6 === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)
              var frameLength = headerC === 3 ? (headerB === 3 ? 12 : 6) * bitRate / sampleRate + padding << 2 : (headerB === 3 ? 144 : 72) * bitRate / sampleRate + padding | 0;
              if (start + frameLength > end) {
                return -1;
              }
              if (this._onMpegFrame) {
                this._onMpegFrame(data.subarray(start, start + frameLength), bitRate, sampleRate, channelCount, frameIndex, pts);
              }
              return frameLength;
            }
          }
          // noise or ID3, trying to skip
          var offset = start + 2;
          while (offset < end) {
            if (data[offset - 1] === 0xFF && (data[offset] & 0xE0) === 0xE0) {
              // sync pattern is found
              if (this._onMpegNoise) {
                this._onMpegNoise(data.subarray(start, offset - 1));
              }
              return offset - start - 1;
            }
            offset++;
          }
          return -1;
        }
      }, {
        key: '_parseID3PES',
        value: function _parseID3PES(pes) {
          this._id3Track.samples.push(pes);
        }
      }], [{
        key: 'probe',
        value: function probe(data) {
          // a TS fragment should contain at least 3 TS packets, a PAT, a PMT, and one PID, each starting with 0x47
          if (data.length >= 3 * 188 && data[0] === 0x47 && data[188] === 0x47 && data[2 * 188] === 0x47) {
            return true;
          } else {
            return false;
          }
        }
      }]);
    
      return TSDemuxer;
    }();
    
    exports.default = TSDemuxer;
    
    },{"22":22,"26":26,"29":29,"31":31,"33":33,"51":51}],31:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var ErrorTypes = exports.ErrorTypes = {
      // Identifier for a network error (loading error / timeout ...)
      NETWORK_ERROR: 'networkError',
      // Identifier for a media Error (video/parsing/mediasource error)
      MEDIA_ERROR: 'mediaError',
      // Identifier for a mux Error (demuxing/remuxing)
      MUX_ERROR: 'muxError',
      // Identifier for all other errors
      OTHER_ERROR: 'otherError'
    };
    
    var ErrorDetails = exports.ErrorDetails = {
      // Identifier for a manifest load error - data: { url : faulty URL, response : { code: error code, text: error text }}
      MANIFEST_LOAD_ERROR: 'manifestLoadError',
      // Identifier for a manifest load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
      MANIFEST_LOAD_TIMEOUT: 'manifestLoadTimeOut',
      // Identifier for a manifest parsing error - data: { url : faulty URL, reason : error reason}
      MANIFEST_PARSING_ERROR: 'manifestParsingError',
      // Identifier for a manifest with only incompatible codecs error - data: { url : faulty URL, reason : error reason}
      MANIFEST_INCOMPATIBLE_CODECS_ERROR: 'manifestIncompatibleCodecsError',
      // Identifier for a level load error - data: { url : faulty URL, response : { code: error code, text: error text }}
      LEVEL_LOAD_ERROR: 'levelLoadError',
      // Identifier for a level load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
      LEVEL_LOAD_TIMEOUT: 'levelLoadTimeOut',
      // Identifier for a level switch error - data: { level : faulty level Id, event : error description}
      LEVEL_SWITCH_ERROR: 'levelSwitchError',
      // Identifier for an audio track load error - data: { url : faulty URL, response : { code: error code, text: error text }}
      AUDIO_TRACK_LOAD_ERROR: 'audioTrackLoadError',
      // Identifier for an audio track load timeout - data: { url : faulty URL, response : { code: error code, text: error text }}
      AUDIO_TRACK_LOAD_TIMEOUT: 'audioTrackLoadTimeOut',
      // Identifier for fragment load error - data: { frag : fragment object, response : { code: error code, text: error text }}
      FRAG_LOAD_ERROR: 'fragLoadError',
      // Identifier for fragment loop loading error - data: { frag : fragment object}
      FRAG_LOOP_LOADING_ERROR: 'fragLoopLoadingError',
      // Identifier for fragment load timeout error - data: { frag : fragment object}
      FRAG_LOAD_TIMEOUT: 'fragLoadTimeOut',
      // Identifier for a fragment decryption error event - data: {id : demuxer Id,frag: fragment object, reason : parsing error description }
      FRAG_DECRYPT_ERROR: 'fragDecryptError',
      // Identifier for a fragment parsing error event - data: { id : demuxer Id, reason : parsing error description }
      // will be renamed DEMUX_PARSING_ERROR and switched to MUX_ERROR in the next major release
      FRAG_PARSING_ERROR: 'fragParsingError',
      // Identifier for a remux alloc error event - data: { id : demuxer Id, frag : fragment object, bytes : nb of bytes on which allocation failed , reason : error text }
      REMUX_ALLOC_ERROR: 'remuxAllocError',
      // Identifier for decrypt key load error - data: { frag : fragment object, response : { code: error code, text: error text }}
      KEY_LOAD_ERROR: 'keyLoadError',
      // Identifier for decrypt key load timeout error - data: { frag : fragment object}
      KEY_LOAD_TIMEOUT: 'keyLoadTimeOut',
      // Triggered when an exception occurs while adding a sourceBuffer to MediaSource - data : {  err : exception , mimeType : mimeType }
      BUFFER_ADD_CODEC_ERROR: 'bufferAddCodecError',
      // Identifier for a buffer append error - data: append error description
      BUFFER_APPEND_ERROR: 'bufferAppendError',
      // Identifier for a buffer appending error event - data: appending error description
      BUFFER_APPENDING_ERROR: 'bufferAppendingError',
      // Identifier for a buffer stalled error event
      BUFFER_STALLED_ERROR: 'bufferStalledError',
      // Identifier for a buffer full event
      BUFFER_FULL_ERROR: 'bufferFullError',
      // Identifier for a buffer seek over hole event
      BUFFER_SEEK_OVER_HOLE: 'bufferSeekOverHole',
      // Identifier for a buffer nudge on stall (playback is stuck although currentTime is in a buffered area)
      BUFFER_NUDGE_ON_STALL: 'bufferNudgeOnStall',
      // Identifier for an internal exception happening inside hls.js while handling an event
      INTERNAL_EXCEPTION: 'internalException',
      // Malformed WebVTT contents
      WEBVTT_EXCEPTION: 'webVTTException'
    };
    
    },{}],32:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * All objects in the event handling chain should inherit from this class
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         */
    
    var _logger = _dereq_(51);
    
    var _errors = _dereq_(31);
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var EventHandler = function () {
      function EventHandler(hls) {
        _classCallCheck(this, EventHandler);
    
        this.hls = hls;
        this.onEvent = this.onEvent.bind(this);
    
        for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          events[_key - 1] = arguments[_key];
        }
    
        this.handledEvents = events;
        this.useGenericHandler = true;
    
        this.registerListeners();
      }
    
      _createClass(EventHandler, [{
        key: 'destroy',
        value: function destroy() {
          this.unregisterListeners();
        }
      }, {
        key: 'isEventHandler',
        value: function isEventHandler() {
          return _typeof(this.handledEvents) === 'object' && this.handledEvents.length && typeof this.onEvent === 'function';
        }
      }, {
        key: 'registerListeners',
        value: function registerListeners() {
          if (this.isEventHandler()) {
            this.handledEvents.forEach(function (event) {
              if (event === 'hlsEventGeneric') {
                throw new Error('Forbidden event name: ' + event);
              }
              this.hls.on(event, this.onEvent);
            }.bind(this));
          }
        }
      }, {
        key: 'unregisterListeners',
        value: function unregisterListeners() {
          if (this.isEventHandler()) {
            this.handledEvents.forEach(function (event) {
              this.hls.off(event, this.onEvent);
            }.bind(this));
          }
        }
    
        /**
         * arguments: event (string), data (any)
         */
    
      }, {
        key: 'onEvent',
        value: function onEvent(event, data) {
          this.onEventGeneric(event, data);
        }
      }, {
        key: 'onEventGeneric',
        value: function onEventGeneric(event, data) {
          var eventToFunction = function eventToFunction(event, data) {
            var funcName = 'on' + event.replace('hls', '');
            if (typeof this[funcName] !== 'function') {
              throw new Error('Event ' + event + ' has no generic handler in this ' + this.constructor.name + ' class (tried ' + funcName + ')');
            }
            return this[funcName].bind(this, data);
          };
          try {
            eventToFunction.call(this, event, data).call();
          } catch (err) {
            _logger.logger.error('internal error happened while processing ' + event + ':' + err.message);
            this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.OTHER_ERROR, details: _errors.ErrorDetails.INTERNAL_EXCEPTION, fatal: false, event: event, err: err });
          }
        }
      }]);
    
      return EventHandler;
    }();
    
    exports.default = EventHandler;
    
    },{"31":31,"33":33,"51":51}],33:[function(_dereq_,module,exports){
    'use strict';
    
    module.exports = {
      // fired before MediaSource is attaching to media element - data: { media }
      MEDIA_ATTACHING: 'hlsMediaAttaching',
      // fired when MediaSource has been succesfully attached to media element - data: { }
      MEDIA_ATTACHED: 'hlsMediaAttached',
      // fired before detaching MediaSource from media element - data: { }
      MEDIA_DETACHING: 'hlsMediaDetaching',
      // fired when MediaSource has been detached from media element - data: { }
      MEDIA_DETACHED: 'hlsMediaDetached',
      // fired when we buffer is going to be resetted
      BUFFER_RESET: 'hlsBufferReset',
      // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
      BUFFER_CODECS: 'hlsBufferCodecs',
      // fired when sourcebuffers have been created data: { tracks : tracks}
      BUFFER_CREATED: 'hlsBufferCreated',
      // fired when we append a segment to the buffer - data: { segment: segment object }
      BUFFER_APPENDING: 'hlsBufferAppending',
      // fired when we are done with appending a media segment to the buffer data : { parent : segment parent that triggered BUFFER_APPENDING , pending : nb of segments waiting for appending for this segment parent}
      BUFFER_APPENDED: 'hlsBufferAppended',
      // fired when the stream is finished and we want to notify the media buffer that there will be no more data
      BUFFER_EOS: 'hlsBufferEos',
      // fired when the media buffer should be flushed - data {startOffset, endOffset}
      BUFFER_FLUSHING: 'hlsBufferFlushing',
      // fired when the media has been flushed
      BUFFER_FLUSHED: 'hlsBufferFlushed',
      // fired to signal that a manifest loading starts - data: { url : manifestURL}
      MANIFEST_LOADING: 'hlsManifestLoading',
      // fired after manifest has been loaded - data: { levels : [available quality levels] , audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
      MANIFEST_LOADED: 'hlsManifestLoaded',
      // fired after manifest has been parsed - data: { levels : [available quality levels] , firstLevel : index of first quality level appearing in Manifest}
      MANIFEST_PARSED: 'hlsManifestParsed',
      // fired when a level switch is requested - data: { level : id of new level } // deprecated in favor LEVEL_SWITCHING
      LEVEL_SWITCH: 'hlsLevelSwitch',
      // fired when a level switch is requested - data: { level : id of new level }
      LEVEL_SWITCHING: 'hlsLevelSwitching',
      // fired when a level switch is effective - data: { level : id of new level }
      LEVEL_SWITCHED: 'hlsLevelSwitched',
      // fired when a level playlist loading starts - data: { url : level URL  level : id of level being loaded}
      LEVEL_LOADING: 'hlsLevelLoading',
      // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
      LEVEL_LOADED: 'hlsLevelLoaded',
      // fired when a level's details have been updated based on previous details, after it has been loaded. - data: { details : levelDetails object, level : id of updated level }
      LEVEL_UPDATED: 'hlsLevelUpdated',
      // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
      LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated',
      // fired to notify that audio track lists has been updated data: { audioTracks : audioTracks}
      AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated',
      // fired when an audio track switch occurs - data: {  id : audio track id} // deprecated in favor AUDIO_TRACK_SWITCHING
      AUDIO_TRACK_SWITCH: 'hlsAudioTrackSwitch',
      // fired when an audio track switching is requested - data: {  id : audio track id}
      AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching',
      // fired when an audio track switch actually occurs - data: {  id : audio track id}
      AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched',
      // fired when an audio track loading starts - data: { url : audio track URL  id : audio track id}
      AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading',
      // fired when an audio track loading  finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime} }
      AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded',
      // fired to notify that subtitle track lists has been updated data: { subtitleTracks : subtitleTracks}
      SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated',
      // fired when an subtitle track switch occurs - data: {  id : subtitle track id}
      SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch',
      // fired when an subtitle track loading starts - data: { url : subtitle track URL  id : subtitle track id}
      SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading',
      // fired when an subtitle track loading  finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime} }
      SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded',
      // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag}
      SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed',
      // fired when the first timestamp is found. - data: { id : demuxer id, initPTS: initPTS , frag : fragment object}
      INIT_PTS_FOUND: 'hlsInitPtsFound',
      // fired when a fragment loading starts - data: { frag : fragment object}
      FRAG_LOADING: 'hlsFragLoading',
      // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded}}
      FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress',
      // Identifier for fragment load aborting for emergency switch down - data: {frag : fragment object}
      FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted',
      // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length}}
      FRAG_LOADED: 'hlsFragLoaded',
      // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, stats : {tstart,tdecrypt} }
      FRAG_DECRYPTED: 'hlsFragDecrypted',
      // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment}
      FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment',
      // fired when parsing sei text is completed - data: { id : demuxer id, , frag: fragment object, samples : [ sei samples pes ] }
      FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata',
      // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
      FRAG_PARSING_METADATA: 'hlsFragParsingMetadata',
      // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
      FRAG_PARSING_DATA: 'hlsFragParsingData',
      // fired when fragment parsing is completed - data: { id : demuxer id,frag: fragment object }
      FRAG_PARSED: 'hlsFragParsed',
      // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id,frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length} }
      FRAG_BUFFERED: 'hlsFragBuffered',
      // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
      FRAG_CHANGED: 'hlsFragChanged',
      // Identifier for a FPS drop event - data: {curentDropped, currentDecoded, totalDroppedFrames}
      FPS_DROP: 'hlsFpsDrop',
      //triggered when FPS drop triggers auto level capping - data: {level, droppedlevel}
      FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping',
      // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data}
      ERROR: 'hlsError',
      // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example
      DESTROYING: 'hlsDestroying',
      // fired when a decrypt key loading starts - data: { frag : fragment object}
      KEY_LOADING: 'hlsKeyLoading',
      // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length}}
      KEY_LOADED: 'hlsKeyLoaded',
      // fired upon stream controller state transitions - data: {previousState, nextState}
      STREAM_STATE_TRANSITION: 'hlsStreamStateTransition'
    };
    
    },{}],34:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     *  AAC helper
     */
    
    var AAC = function () {
      function AAC() {
        _classCallCheck(this, AAC);
      }
    
      _createClass(AAC, null, [{
        key: 'getSilentFrame',
        value: function getSilentFrame(codec, channelCount) {
          switch (codec) {
            case 'mp4a.40.2':
              if (channelCount === 1) {
                return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);
              } else if (channelCount === 2) {
                return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);
              } else if (channelCount === 3) {
                return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);
              } else if (channelCount === 4) {
                return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);
              } else if (channelCount === 5) {
                return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);
              } else if (channelCount === 6) {
                return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);
              }
              break;
            // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)
            default:
              if (channelCount === 1) {
                // ffmpeg -y -f lavfi -i "aevalsrc=0:d=0.05" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
                return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
              } else if (channelCount === 2) {
                // ffmpeg -y -f lavfi -i "aevalsrc=0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
                return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
              } else if (channelCount === 3) {
                // ffmpeg -y -f lavfi -i "aevalsrc=0|0|0:d=0.05" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 "0x%x," "\n"' -v output.aac
                return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);
              }
              break;
          }
          return null;
        }
      }]);
    
      return AAC;
    }();
    
    exports.default = AAC;
    
    },{}],35:[function(_dereq_,module,exports){
    "use strict";
    
    /**
     * Buffer Helper utils, providing methods dealing buffer length retrieval
    */
    
    var BufferHelper = {
      isBuffered: function isBuffered(media, position) {
        if (media) {
          var buffered = media.buffered;
          for (var i = 0; i < buffered.length; i++) {
            if (position >= buffered.start(i) && position <= buffered.end(i)) {
              return true;
            }
          }
        }
        return false;
      },
    
      bufferInfo: function bufferInfo(media, pos, maxHoleDuration) {
        if (media) {
          var vbuffered = media.buffered,
              buffered = [],
              i;
          for (i = 0; i < vbuffered.length; i++) {
            buffered.push({ start: vbuffered.start(i), end: vbuffered.end(i) });
          }
          return this.bufferedInfo(buffered, pos, maxHoleDuration);
        } else {
          return { len: 0, start: pos, end: pos, nextStart: undefined };
        }
      },
    
      bufferedInfo: function bufferedInfo(buffered, pos, maxHoleDuration) {
        var buffered2 = [],
    
        // bufferStart and bufferEnd are buffer boundaries around current video position
        bufferLen,
            bufferStart,
            bufferEnd,
            bufferStartNext,
            i;
        // sort on buffer.start/smaller end (IE does not always return sorted buffered range)
        buffered.sort(function (a, b) {
          var diff = a.start - b.start;
          if (diff) {
            return diff;
          } else {
            return b.end - a.end;
          }
        });
        // there might be some small holes between buffer time range
        // consider that holes smaller than maxHoleDuration are irrelevant and build another
        // buffer time range representations that discards those holes
        for (i = 0; i < buffered.length; i++) {
          var buf2len = buffered2.length;
          if (buf2len) {
            var buf2end = buffered2[buf2len - 1].end;
            // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)
            if (buffered[i].start - buf2end < maxHoleDuration) {
              // merge overlapping time ranges
              // update lastRange.end only if smaller than item.end
              // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)
              // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])
              if (buffered[i].end > buf2end) {
                buffered2[buf2len - 1].end = buffered[i].end;
              }
            } else {
              // big hole
              buffered2.push(buffered[i]);
            }
          } else {
            // first value
            buffered2.push(buffered[i]);
          }
        }
        for (i = 0, bufferLen = 0, bufferStart = bufferEnd = pos; i < buffered2.length; i++) {
          var start = buffered2[i].start,
              end = buffered2[i].end;
          //logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));
          if (pos + maxHoleDuration >= start && pos < end) {
            // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length
            bufferStart = start;
            bufferEnd = end;
            bufferLen = bufferEnd - pos;
          } else if (pos + maxHoleDuration < start) {
            bufferStartNext = start;
            break;
          }
        }
        return { len: bufferLen, start: bufferStart, end: bufferEnd, nextStart: bufferStartNext };
      }
    };
    
    module.exports = BufferHelper;
    
    },{}],36:[function(_dereq_,module,exports){
    'use strict';
    
    var _logger = _dereq_(51);
    
    var LevelHelper = {
    
      mergeDetails: function mergeDetails(oldDetails, newDetails) {
        var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN,
            end = Math.min(oldDetails.endSN, newDetails.endSN) - newDetails.startSN,
            delta = newDetails.startSN - oldDetails.startSN,
            oldfragments = oldDetails.fragments,
            newfragments = newDetails.fragments,
            ccOffset = 0,
            PTSFrag;
    
        // check if old/new playlists have fragments in common
        if (end < start) {
          newDetails.PTSKnown = false;
          return;
        }
        // loop through overlapping SN and update startPTS , cc, and duration if any found
        for (var i = start; i <= end; i++) {
          var oldFrag = oldfragments[delta + i],
              newFrag = newfragments[i];
          if (newFrag && oldFrag) {
            ccOffset = oldFrag.cc - newFrag.cc;
            if (!isNaN(oldFrag.startPTS)) {
              newFrag.start = newFrag.startPTS = oldFrag.startPTS;
              newFrag.endPTS = oldFrag.endPTS;
              newFrag.duration = oldFrag.duration;
              PTSFrag = newFrag;
            }
          }
        }
    
        if (ccOffset) {
          _logger.logger.log('discontinuity sliding from playlist, take drift into account');
          for (i = 0; i < newfragments.length; i++) {
            newfragments[i].cc += ccOffset;
          }
        }
    
        // if at least one fragment contains PTS info, recompute PTS information for all fragments
        if (PTSFrag) {
          LevelHelper.updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
        } else {
          // ensure that delta is within oldfragments range
          // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])
          // in that case we also need to adjust start offset of all fragments
          if (delta >= 0 && delta < oldfragments.length) {
            // adjust start by sliding offset
            var sliding = oldfragments[delta].start;
            for (i = 0; i < newfragments.length; i++) {
              newfragments[i].start += sliding;
            }
          }
        }
        // if we are here, it means we have fragments overlapping between
        // old and new level. reliable PTS info is thus relying on old level
        newDetails.PTSKnown = oldDetails.PTSKnown;
        return;
      },
    
      updateFragPTSDTS: function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
        // update frag PTS/DTS
        if (!isNaN(frag.startPTS)) {
          // delta PTS between audio and video
          var deltaPTS = Math.abs(frag.startPTS - startPTS);
          if (isNaN(frag.deltaPTS)) {
            frag.deltaPTS = deltaPTS;
          } else {
            frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
          }
          startPTS = Math.min(startPTS, frag.startPTS);
          endPTS = Math.max(endPTS, frag.endPTS);
          startDTS = Math.min(startDTS, frag.startDTS);
          endDTS = Math.max(endDTS, frag.endDTS);
        }
    
        var drift = startPTS - frag.start;
        frag.start = frag.startPTS = startPTS;
        frag.endPTS = endPTS;
        frag.startDTS = startDTS;
        frag.endDTS = endDTS;
        frag.duration = endPTS - startPTS;
    
        var sn = frag.sn;
        // exit if sn out of range
        if (!details || sn < details.startSN || sn > details.endSN) {
          return 0;
        }
        var fragIdx, fragments, i;
        fragIdx = sn - details.startSN;
        fragments = details.fragments;
        frag = fragments[fragIdx];
        // adjust fragment PTS/duration from seqnum-1 to frag 0
        for (i = fragIdx; i > 0; i--) {
          LevelHelper.updatePTS(fragments, i, i - 1);
        }
    
        // adjust fragment PTS/duration from seqnum to last frag
        for (i = fragIdx; i < fragments.length - 1; i++) {
          LevelHelper.updatePTS(fragments, i, i + 1);
        }
        details.PTSKnown = true;
        //logger.log(`                                            frag start/end:${startPTS.toFixed(3)}/${endPTS.toFixed(3)}`);
    
        return drift;
      },
    
      updatePTS: function updatePTS(fragments, fromIdx, toIdx) {
        var fragFrom = fragments[fromIdx],
            fragTo = fragments[toIdx],
            fragToPTS = fragTo.startPTS;
        // if we know startPTS[toIdx]
        if (!isNaN(fragToPTS)) {
          // update fragment duration.
          // it helps to fix drifts between playlist reported duration and fragment real duration
          if (toIdx > fromIdx) {
            fragFrom.duration = fragToPTS - fragFrom.start;
            if (fragFrom.duration < 0) {
              _logger.logger.warn('negative duration computed for frag ' + fragFrom.sn + ',level ' + fragFrom.level + ', there should be some duration drift between playlist and fragment!');
            }
          } else {
            fragTo.duration = fragFrom.start - fragToPTS;
            if (fragTo.duration < 0) {
              _logger.logger.warn('negative duration computed for frag ' + fragTo.sn + ',level ' + fragTo.level + ', there should be some duration drift between playlist and fragment!');
            }
          }
        } else {
          // we dont know startPTS[toIdx]
          if (toIdx > fromIdx) {
            fragTo.start = fragFrom.start + fragFrom.duration;
          } else {
            fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
          }
        }
      }
    }; /**
        * Level Helper class, providing methods dealing with playlist sliding and drift
       */
    
    module.exports = LevelHelper;
    
    },{"51":51}],37:[function(_dereq_,module,exports){
    /**
     * HLS interface
     */
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _urlToolkit = _dereq_(2);
    
    var _urlToolkit2 = _interopRequireDefault(_urlToolkit);
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _errors = _dereq_(31);
    
    var _playlistLoader = _dereq_(41);
    
    var _playlistLoader2 = _interopRequireDefault(_playlistLoader);
    
    var _fragmentLoader = _dereq_(39);
    
    var _fragmentLoader2 = _interopRequireDefault(_fragmentLoader);
    
    var _keyLoader = _dereq_(40);
    
    var _keyLoader2 = _interopRequireDefault(_keyLoader);
    
    var _streamController = _dereq_(13);
    
    var _streamController2 = _interopRequireDefault(_streamController);
    
    var _levelController = _dereq_(12);
    
    var _levelController2 = _interopRequireDefault(_levelController);
    
    var _id3TrackController = _dereq_(11);
    
    var _id3TrackController2 = _interopRequireDefault(_id3TrackController);
    
    var _logger = _dereq_(51);
    
    var _events3 = _dereq_(1);
    
    var _events4 = _interopRequireDefault(_events3);
    
    var _config = _dereq_(4);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var Hls = function () {
      _createClass(Hls, null, [{
        key: 'isSupported',
        value: function isSupported() {
          window.MediaSource = window.MediaSource || window.WebKitMediaSource;
          return window.MediaSource && typeof window.MediaSource.isTypeSupported === 'function' && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
        }
      }, {
        key: 'version',
        get: function get() {
          // replaced with browserify-versionify transform
          return '0.7.6';
        }
      }, {
        key: 'Events',
        get: function get() {
          return _events2.default;
        }
      }, {
        key: 'ErrorTypes',
        get: function get() {
          return _errors.ErrorTypes;
        }
      }, {
        key: 'ErrorDetails',
        get: function get() {
          return _errors.ErrorDetails;
        }
      }, {
        key: 'DefaultConfig',
        get: function get() {
          if (!Hls.defaultConfig) {
            return _config.hlsDefaultConfig;
          }
          return Hls.defaultConfig;
        },
        set: function set(defaultConfig) {
          Hls.defaultConfig = defaultConfig;
        }
      }]);
    
      function Hls() {
        var _this = this;
    
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    
        _classCallCheck(this, Hls);
    
        var defaultConfig = Hls.DefaultConfig;
    
        if ((config.liveSyncDurationCount || config.liveMaxLatencyDurationCount) && (config.liveSyncDuration || config.liveMaxLatencyDuration)) {
          throw new Error('Illegal hls.js config: don\'t mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration');
        }
    
        for (var prop in defaultConfig) {
          if (prop in config) {
            continue;
          }
          config[prop] = defaultConfig[prop];
        }
    
        if (config.liveMaxLatencyDurationCount !== undefined && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
          throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
        }
    
        if (config.liveMaxLatencyDuration !== undefined && (config.liveMaxLatencyDuration <= config.liveSyncDuration || config.liveSyncDuration === undefined)) {
          throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
        }
    
        (0, _logger.enableLogs)(config.debug);
        this.config = config;
        this._autoLevelCapping = -1;
        // observer setup
        var observer = this.observer = new _events4.default();
        observer.trigger = function trigger(event) {
          for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            data[_key - 1] = arguments[_key];
          }
    
          observer.emit.apply(observer, [event, event].concat(data));
        };
    
        observer.off = function off(event) {
          for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            data[_key2 - 1] = arguments[_key2];
          }
    
          observer.removeListener.apply(observer, [event].concat(data));
        };
        this.on = observer.on.bind(observer);
        this.off = observer.off.bind(observer);
        this.trigger = observer.trigger.bind(observer);
    
        // core controllers and network loaders
        var abrController = this.abrController = new config.abrController(this);
        var bufferController = new config.bufferController(this);
        var capLevelController = new config.capLevelController(this);
        var fpsController = new config.fpsController(this);
        var playListLoader = new _playlistLoader2.default(this);
        var fragmentLoader = new _fragmentLoader2.default(this);
        var keyLoader = new _keyLoader2.default(this);
        var id3TrackController = new _id3TrackController2.default(this);
    
        // network controllers
        var levelController = this.levelController = new _levelController2.default(this);
        var streamController = this.streamController = new _streamController2.default(this);
        var networkControllers = [levelController, streamController];
    
        // optional audio stream controller
        var Controller = config.audioStreamController;
        if (Controller) {
          networkControllers.push(new Controller(this));
        }
        this.networkControllers = networkControllers;
    
        var coreComponents = [playListLoader, fragmentLoader, keyLoader, abrController, bufferController, capLevelController, fpsController, id3TrackController];
    
        // optional audio track and subtitle controller
        Controller = config.audioTrackController;
        if (Controller) {
          var audioTrackController = new Controller(this);
          this.audioTrackController = audioTrackController;
          coreComponents.push(audioTrackController);
        }
    
        Controller = config.subtitleTrackController;
        if (Controller) {
          var subtitleTrackController = new Controller(this);
          this.subtitleTrackController = subtitleTrackController;
          coreComponents.push(subtitleTrackController);
        }
    
        // optional subtitle controller
        [config.subtitleStreamController, config.timelineController].forEach(function (Controller) {
          if (Controller) {
            coreComponents.push(new Controller(_this));
          }
        });
        this.coreComponents = coreComponents;
      }
    
      _createClass(Hls, [{
        key: 'destroy',
        value: function destroy() {
          _logger.logger.log('destroy');
          this.trigger(_events2.default.DESTROYING);
          this.detachMedia();
          this.coreComponents.concat(this.networkControllers).forEach(function (component) {
            component.destroy();
          });
          this.url = null;
          this.observer.removeAllListeners();
          this._autoLevelCapping = -1;
        }
      }, {
        key: 'attachMedia',
        value: function attachMedia(media) {
          _logger.logger.log('attachMedia');
          this.media = media;
          this.trigger(_events2.default.MEDIA_ATTACHING, { media: media });
        }
      }, {
        key: 'detachMedia',
        value: function detachMedia() {
          _logger.logger.log('detachMedia');
          this.trigger(_events2.default.MEDIA_DETACHING);
          this.media = null;
        }
      }, {
        key: 'loadSource',
        value: function loadSource(url) {
          url = _urlToolkit2.default.buildAbsoluteURL(window.location.href, url, { alwaysNormalize: true });
          _logger.logger.log('loadSource:' + url);
          this.url = url;
          // when attaching to a source URL, trigger a playlist load
          this.trigger(_events2.default.MANIFEST_LOADING, { url: url });
        }
      }, {
        key: 'startLoad',
        value: function startLoad() {
          var startPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    
          _logger.logger.log('startLoad(' + startPosition + ')');
          this.networkControllers.forEach(function (controller) {
            controller.startLoad(startPosition);
          });
        }
      }, {
        key: 'stopLoad',
        value: function stopLoad() {
          _logger.logger.log('stopLoad');
          this.networkControllers.forEach(function (controller) {
            controller.stopLoad();
          });
        }
      }, {
        key: 'swapAudioCodec',
        value: function swapAudioCodec() {
          _logger.logger.log('swapAudioCodec');
          this.streamController.swapAudioCodec();
        }
      }, {
        key: 'recoverMediaError',
        value: function recoverMediaError() {
          _logger.logger.log('recoverMediaError');
          var media = this.media;
          this.detachMedia();
          this.attachMedia(media);
        }
    
        /** Return all quality levels **/
    
      }, {
        key: 'levels',
        get: function get() {
          return this.levelController.levels;
        }
    
        /** Return current playback quality level **/
    
      }, {
        key: 'currentLevel',
        get: function get() {
          return this.streamController.currentLevel;
        }
    
        /* set quality level immediately (-1 for automatic level selection) */
        ,
        set: function set(newLevel) {
          _logger.logger.log('set currentLevel:' + newLevel);
          this.loadLevel = newLevel;
          this.streamController.immediateLevelSwitch();
        }
    
        /** Return next playback quality level (quality level of next fragment) **/
    
      }, {
        key: 'nextLevel',
        get: function get() {
          return this.streamController.nextLevel;
        }
    
        /* set quality level for next fragment (-1 for automatic level selection) */
        ,
        set: function set(newLevel) {
          _logger.logger.log('set nextLevel:' + newLevel);
          this.levelController.manualLevel = newLevel;
          this.streamController.nextLevelSwitch();
        }
    
        /** Return the quality level of current/last loaded fragment **/
    
      }, {
        key: 'loadLevel',
        get: function get() {
          return this.levelController.level;
        }
    
        /* set quality level for current/next loaded fragment (-1 for automatic level selection) */
        ,
        set: function set(newLevel) {
          _logger.logger.log('set loadLevel:' + newLevel);
          this.levelController.manualLevel = newLevel;
        }
    
        /** Return the quality level of next loaded fragment **/
    
      }, {
        key: 'nextLoadLevel',
        get: function get() {
          return this.levelController.nextLoadLevel;
        }
    
        /** set quality level of next loaded fragment **/
        ,
        set: function set(level) {
          this.levelController.nextLoadLevel = level;
        }
    
        /** Return first level (index of first level referenced in manifest)
        **/
    
      }, {
        key: 'firstLevel',
        get: function get() {
          return Math.max(this.levelController.firstLevel, this.minAutoLevel);
        }
    
        /** set first level (index of first level referenced in manifest)
        **/
        ,
        set: function set(newLevel) {
          _logger.logger.log('set firstLevel:' + newLevel);
          this.levelController.firstLevel = newLevel;
        }
    
        /** Return start level (level of first fragment that will be played back)
            if not overrided by user, first level appearing in manifest will be used as start level
            if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
        **/
    
      }, {
        key: 'startLevel',
        get: function get() {
          return this.levelController.startLevel;
        }
    
        /** set  start level (level of first fragment that will be played back)
            if not overrided by user, first level appearing in manifest will be used as start level
            if -1 : automatic start level selection, playback will start from level matching download bandwidth (determined from download of first segment)
        **/
        ,
        set: function set(newLevel) {
          _logger.logger.log('set startLevel:' + newLevel);
          var hls = this;
          // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel
          if (newLevel !== -1) {
            newLevel = Math.max(newLevel, hls.minAutoLevel);
          }
          hls.levelController.startLevel = newLevel;
        }
    
        /** Return the capping/max level value that could be used by automatic level selection algorithm **/
    
      }, {
        key: 'autoLevelCapping',
        get: function get() {
          return this._autoLevelCapping;
        }
    
        /** set the capping/max level value that could be used by automatic level selection algorithm **/
        ,
        set: function set(newLevel) {
          _logger.logger.log('set autoLevelCapping:' + newLevel);
          this._autoLevelCapping = newLevel;
        }
    
        /* check if we are in automatic level selection mode */
    
      }, {
        key: 'autoLevelEnabled',
        get: function get() {
          return this.levelController.manualLevel === -1;
        }
    
        /* return manual level */
    
      }, {
        key: 'manualLevel',
        get: function get() {
          return this.levelController.manualLevel;
        }
    
        /* return min level selectable in auto mode according to config.minAutoBitrate */
    
      }, {
        key: 'minAutoLevel',
        get: function get() {
          var hls = this,
              levels = hls.levels,
              minAutoBitrate = hls.config.minAutoBitrate,
              len = levels ? levels.length : 0;
          for (var i = 0; i < len; i++) {
            var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
            if (levelNextBitrate > minAutoBitrate) {
              return i;
            }
          }
          return 0;
        }
    
        /* return max level selectable in auto mode according to autoLevelCapping */
    
      }, {
        key: 'maxAutoLevel',
        get: function get() {
          var hls = this;
          var levels = hls.levels;
          var autoLevelCapping = hls.autoLevelCapping;
          var maxAutoLevel = void 0;
          if (autoLevelCapping === -1 && levels && levels.length) {
            maxAutoLevel = levels.length - 1;
          } else {
            maxAutoLevel = autoLevelCapping;
          }
          return maxAutoLevel;
        }
    
        // return next auto level
    
      }, {
        key: 'nextAutoLevel',
        get: function get() {
          var hls = this;
          // ensure next auto level is between  min and max auto level
          return Math.min(Math.max(hls.abrController.nextAutoLevel, hls.minAutoLevel), hls.maxAutoLevel);
        }
    
        // this setter is used to force next auto level
        // this is useful to force a switch down in auto mode : in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)
        // forced value is valid for one fragment. upon succesful frag loading at forced level, this value will be resetted to -1 by ABR controller
        ,
        set: function set(nextLevel) {
          var hls = this;
          hls.abrController.nextAutoLevel = Math.max(hls.minAutoLevel, nextLevel);
        }
    
        /** get alternate audio tracks list from playlist **/
    
      }, {
        key: 'audioTracks',
        get: function get() {
          var audioTrackController = this.audioTrackController;
          return audioTrackController ? audioTrackController.audioTracks : [];
        }
    
        /** get index of the selected audio track (index in audio track lists) **/
    
      }, {
        key: 'audioTrack',
        get: function get() {
          var audioTrackController = this.audioTrackController;
          return audioTrackController ? audioTrackController.audioTrack : -1;
        }
    
        /** select an audio track, based on its index in audio track lists**/
        ,
        set: function set(audioTrackId) {
          var audioTrackController = this.audioTrackController;
          if (audioTrackController) {
            audioTrackController.audioTrack = audioTrackId;
          }
        }
      }, {
        key: 'liveSyncPosition',
        get: function get() {
          return this.streamController.liveSyncPosition;
        }
    
        /** get alternate subtitle tracks list from playlist **/
    
      }, {
        key: 'subtitleTracks',
        get: function get() {
          var subtitleTrackController = this.subtitleTrackController;
          return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
        }
    
        /** get index of the selected subtitle track (index in subtitle track lists) **/
    
      }, {
        key: 'subtitleTrack',
        get: function get() {
          var subtitleTrackController = this.subtitleTrackController;
          return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
        }
    
        /** select an subtitle track, based on its index in subtitle track lists**/
        ,
        set: function set(subtitleTrackId) {
          var subtitleTrackController = this.subtitleTrackController;
          if (subtitleTrackController) {
            subtitleTrackController.subtitleTrack = subtitleTrackId;
          }
        }
      }]);
    
      return Hls;
    }();
    
    exports.default = Hls;
    
    },{"1":1,"11":11,"12":12,"13":13,"2":2,"31":31,"33":33,"39":39,"4":4,"40":40,"41":41,"51":51}],38:[function(_dereq_,module,exports){
    'use strict';
    
    // This is mostly for support of the es6 module export
    // syntax with the babel compiler, it looks like it doesnt support
    // function exports like we are used to in node/commonjs
    module.exports = _dereq_(37).default;
    
    },{"37":37}],39:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _errors = _dereq_(31);
    
    var _logger = _dereq_(51);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * Fragment Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    var FragmentLoader = function (_EventHandler) {
      _inherits(FragmentLoader, _EventHandler);
    
      function FragmentLoader(hls) {
        _classCallCheck(this, FragmentLoader);
    
        var _this = _possibleConstructorReturn(this, (FragmentLoader.__proto__ || Object.getPrototypeOf(FragmentLoader)).call(this, hls, _events2.default.FRAG_LOADING));
    
        _this.loaders = {};
        return _this;
      }
    
      _createClass(FragmentLoader, [{
        key: 'destroy',
        value: function destroy() {
          var loaders = this.loaders;
          for (var loaderName in loaders) {
            var loader = loaders[loaderName];
            if (loader) {
              loader.destroy();
            }
          }
          this.loaders = {};
          _eventHandler2.default.prototype.destroy.call(this);
        }
      }, {
        key: 'onFragLoading',
        value: function onFragLoading(data) {
          var frag = data.frag,
              type = frag.type,
              loader = this.loaders[type],
              config = this.hls.config;
    
          frag.loaded = 0;
          if (loader) {
            _logger.logger.warn('abort previous fragment loader for type:' + type);
            loader.abort();
          }
          loader = this.loaders[type] = frag.loader = typeof config.fLoader !== 'undefined' ? new config.fLoader(config) : new config.loader(config);
    
          var loaderContext = void 0,
              loaderConfig = void 0,
              loaderCallbacks = void 0;
          loaderContext = { url: frag.url, frag: frag, responseType: 'arraybuffer', progressData: false };
          var start = frag.byteRangeStartOffset,
              end = frag.byteRangeEndOffset;
          if (!isNaN(start) && !isNaN(end)) {
            loaderContext.rangeStart = start;
            loaderContext.rangeEnd = end;
          }
          loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
          loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) };
          loader.load(loaderContext, loaderConfig, loaderCallbacks);
        }
      }, {
        key: 'loadsuccess',
        value: function loadsuccess(response, stats, context) {
          var payload = response.data,
              frag = context.frag;
          // detach fragment loader on load success
          frag.loader = undefined;
          this.loaders[frag.type] = undefined;
          this.hls.trigger(_events2.default.FRAG_LOADED, { payload: payload, frag: frag, stats: stats });
        }
      }, {
        key: 'loaderror',
        value: function loaderror(response, context) {
          var loader = context.loader;
          if (loader) {
            loader.abort();
          }
          this.loaders[context.type] = undefined;
          this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_ERROR, fatal: false, frag: context.frag, response: response });
        }
      }, {
        key: 'loadtimeout',
        value: function loadtimeout(stats, context) {
          var loader = context.loader;
          if (loader) {
            loader.abort();
          }
          this.loaders[context.type] = undefined;
          this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.FRAG_LOAD_TIMEOUT, fatal: false, frag: context.frag });
        }
    
        // data will be used for progressive parsing
    
      }, {
        key: 'loadprogress',
        value: function loadprogress(stats, context, data) {
          // jshint ignore:line
          var frag = context.frag;
          frag.loaded = stats.loaded;
          this.hls.trigger(_events2.default.FRAG_LOAD_PROGRESS, { frag: frag, stats: stats });
        }
      }]);
    
      return FragmentLoader;
    }(_eventHandler2.default);
    
    exports.default = FragmentLoader;
    
    },{"31":31,"32":32,"33":33,"51":51}],40:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _errors = _dereq_(31);
    
    var _logger = _dereq_(51);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    * Decrypt key Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   */
    
    var KeyLoader = function (_EventHandler) {
      _inherits(KeyLoader, _EventHandler);
    
      function KeyLoader(hls) {
        _classCallCheck(this, KeyLoader);
    
        var _this = _possibleConstructorReturn(this, (KeyLoader.__proto__ || Object.getPrototypeOf(KeyLoader)).call(this, hls, _events2.default.KEY_LOADING));
    
        _this.loaders = {};
        _this.decryptkey = null;
        _this.decrypturl = null;
        return _this;
      }
    
      _createClass(KeyLoader, [{
        key: 'destroy',
        value: function destroy() {
          for (var loaderName in this.loaders) {
            var loader = this.loaders[loaderName];
            if (loader) {
              loader.destroy();
            }
          }
          this.loaders = {};
          _eventHandler2.default.prototype.destroy.call(this);
        }
      }, {
        key: 'onKeyLoading',
        value: function onKeyLoading(data) {
          var frag = data.frag,
              type = frag.type,
              loader = this.loaders[type],
              decryptdata = frag.decryptdata,
              uri = decryptdata.uri;
          // if uri is different from previous one or if decrypt key not retrieved yet
          if (uri !== this.decrypturl || this.decryptkey === null) {
            var config = this.hls.config;
    
            if (loader) {
              _logger.logger.warn('abort previous key loader for type:' + type);
              loader.abort();
            }
            frag.loader = this.loaders[type] = new config.loader(config);
            this.decrypturl = uri;
            this.decryptkey = null;
    
            var loaderContext = void 0,
                loaderConfig = void 0,
                loaderCallbacks = void 0;
            loaderContext = { url: uri, frag: frag, responseType: 'arraybuffer' };
            loaderConfig = { timeout: config.fragLoadingTimeOut, maxRetry: config.fragLoadingMaxRetry, retryDelay: config.fragLoadingRetryDelay, maxRetryDelay: config.fragLoadingMaxRetryTimeout };
            loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
            frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
          } else if (this.decryptkey) {
            // we already loaded this key, return it
            decryptdata.key = this.decryptkey;
            this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
          }
        }
      }, {
        key: 'loadsuccess',
        value: function loadsuccess(response, stats, context) {
          var frag = context.frag;
          this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
          // detach fragment loader on load success
          frag.loader = undefined;
          this.loaders[frag.type] = undefined;
          this.hls.trigger(_events2.default.KEY_LOADED, { frag: frag });
        }
      }, {
        key: 'loaderror',
        value: function loaderror(response, context) {
          var frag = context.frag,
              loader = frag.loader;
          if (loader) {
            loader.abort();
          }
          this.loaders[context.type] = undefined;
          this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_ERROR, fatal: false, frag: frag, response: response });
        }
      }, {
        key: 'loadtimeout',
        value: function loadtimeout(stats, context) {
          var frag = context.frag,
              loader = frag.loader;
          if (loader) {
            loader.abort();
          }
          this.loaders[context.type] = undefined;
          this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.KEY_LOAD_TIMEOUT, fatal: false, frag: frag });
        }
      }]);
    
      return KeyLoader;
    }(_eventHandler2.default);
    
    exports.default = KeyLoader;
    
    },{"31":31,"32":32,"33":33,"51":51}],41:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Playlist Loader
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         */
    
    var _urlToolkit = _dereq_(2);
    
    var _urlToolkit2 = _interopRequireDefault(_urlToolkit);
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _eventHandler = _dereq_(32);
    
    var _eventHandler2 = _interopRequireDefault(_eventHandler);
    
    var _errors = _dereq_(31);
    
    var _attrList = _dereq_(45);
    
    var _attrList2 = _interopRequireDefault(_attrList);
    
    var _logger = _dereq_(51);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
    
    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    // https://regex101.com is your friend
    var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g;
    var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
    var LEVEL_PLAYLIST_REGEX_FAST = /#EXTINF:(\d*(?:\.\d+)?)(?:,(.*))?|(?!#)(\S.+)|#EXT-X-BYTERANGE: *(.+)|#EXT-X-PROGRAM-DATE-TIME:(.+)|#.*/g;
    var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;
    
    var LevelKey = function () {
      function LevelKey() {
        _classCallCheck(this, LevelKey);
    
        this.method = null;
        this.key = null;
        this.iv = null;
        this._uri = null;
      }
    
      _createClass(LevelKey, [{
        key: 'uri',
        get: function get() {
          if (!this._uri && this.reluri) {
            this._uri = _urlToolkit2.default.buildAbsoluteURL(this.baseuri, this.reluri, { alwaysNormalize: true });
          }
          return this._uri;
        }
      }]);
    
      return LevelKey;
    }();
    
    var Fragment = function () {
      function Fragment() {
        _classCallCheck(this, Fragment);
    
        this._url = null;
        this._byteRange = null;
        this._decryptdata = null;
        this.tagList = [];
      }
    
      _createClass(Fragment, [{
        key: 'createInitializationVector',
    
    
        /**
         * Utility method for parseLevelPlaylist to create an initialization vector for a given segment
         * @returns {Uint8Array}
         */
        value: function createInitializationVector(segmentNumber) {
          var uint8View = new Uint8Array(16);
    
          for (var i = 12; i < 16; i++) {
            uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;
          }
    
          return uint8View;
        }
    
        /**
         * Utility method for parseLevelPlaylist to get a fragment's decryption data from the currently parsed encryption key data
         * @param levelkey - a playlist's encryption info
         * @param segmentNumber - the fragment's segment number
         * @returns {*} - an object to be applied as a fragment's decryptdata
         */
    
      }, {
        key: 'fragmentDecryptdataFromLevelkey',
        value: function fragmentDecryptdataFromLevelkey(levelkey, segmentNumber) {
          var decryptdata = levelkey;
    
          if (levelkey && levelkey.method && levelkey.uri && !levelkey.iv) {
            decryptdata = new LevelKey();
            decryptdata.method = levelkey.method;
            decryptdata.baseuri = levelkey.baseuri;
            decryptdata.reluri = levelkey.reluri;
            decryptdata.iv = this.createInitializationVector(segmentNumber);
          }
    
          return decryptdata;
        }
      }, {
        key: 'cloneObj',
        value: function cloneObj(obj) {
          return JSON.parse(JSON.stringify(obj));
        }
      }, {
        key: 'url',
        get: function get() {
          if (!this._url && this.relurl) {
            this._url = _urlToolkit2.default.buildAbsoluteURL(this.baseurl, this.relurl, { alwaysNormalize: true });
          }
          return this._url;
        },
        set: function set(value) {
          this._url = value;
        }
      }, {
        key: 'programDateTime',
        get: function get() {
          if (!this._programDateTime && this.rawProgramDateTime) {
            this._programDateTime = new Date(Date.parse(this.rawProgramDateTime));
          }
          return this._programDateTime;
        }
      }, {
        key: 'byteRange',
        get: function get() {
          if (!this._byteRange) {
            var byteRange = this._byteRange = [];
            if (this.rawByteRange) {
              var params = this.rawByteRange.split('@', 2);
              if (params.length === 1) {
                var lastByteRangeEndOffset = this.lastByteRangeEndOffset;
                byteRange[0] = lastByteRangeEndOffset ? lastByteRangeEndOffset : 0;
              } else {
                byteRange[0] = parseInt(params[1]);
              }
              byteRange[1] = parseInt(params[0]) + byteRange[0];
            }
          }
          return this._byteRange;
        }
      }, {
        key: 'byteRangeStartOffset',
        get: function get() {
          return this.byteRange[0];
        }
      }, {
        key: 'byteRangeEndOffset',
        get: function get() {
          return this.byteRange[1];
        }
      }, {
        key: 'decryptdata',
        get: function get() {
          if (!this._decryptdata) {
            this._decryptdata = this.fragmentDecryptdataFromLevelkey(this.levelkey, this.sn);
          }
          return this._decryptdata;
        }
      }]);
    
      return Fragment;
    }();
    
    var PlaylistLoader = function (_EventHandler) {
      _inherits(PlaylistLoader, _EventHandler);
    
      function PlaylistLoader(hls) {
        _classCallCheck(this, PlaylistLoader);
    
        var _this = _possibleConstructorReturn(this, (PlaylistLoader.__proto__ || Object.getPrototypeOf(PlaylistLoader)).call(this, hls, _events2.default.MANIFEST_LOADING, _events2.default.LEVEL_LOADING, _events2.default.AUDIO_TRACK_LOADING, _events2.default.SUBTITLE_TRACK_LOADING));
    
        _this.loaders = {};
        return _this;
      }
    
      _createClass(PlaylistLoader, [{
        key: 'destroy',
        value: function destroy() {
          for (var loaderName in this.loaders) {
            var loader = this.loaders[loaderName];
            if (loader) {
              loader.destroy();
            }
          }
          this.loaders = {};
          _eventHandler2.default.prototype.destroy.call(this);
        }
      }, {
        key: 'onManifestLoading',
        value: function onManifestLoading(data) {
          this.load(data.url, { type: 'manifest' });
        }
      }, {
        key: 'onLevelLoading',
        value: function onLevelLoading(data) {
          this.load(data.url, { type: 'level', level: data.level, id: data.id });
        }
      }, {
        key: 'onAudioTrackLoading',
        value: function onAudioTrackLoading(data) {
          this.load(data.url, { type: 'audioTrack', id: data.id });
        }
      }, {
        key: 'onSubtitleTrackLoading',
        value: function onSubtitleTrackLoading(data) {
          this.load(data.url, { type: 'subtitleTrack', id: data.id });
        }
      }, {
        key: 'load',
        value: function load(url, context) {
          var loader = this.loaders[context.type];
          if (loader) {
            var loaderContext = loader.context;
            if (loaderContext && loaderContext.url === url) {
              _logger.logger.trace('playlist request ongoing');
              return;
            } else {
              _logger.logger.warn('abort previous loader for type:' + context.type);
              loader.abort();
            }
          }
          var config = this.hls.config,
              retry = void 0,
              timeout = void 0,
              retryDelay = void 0,
              maxRetryDelay = void 0;
          if (context.type === 'manifest') {
            retry = config.manifestLoadingMaxRetry;
            timeout = config.manifestLoadingTimeOut;
            retryDelay = config.manifestLoadingRetryDelay;
            maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
          } else {
            retry = config.levelLoadingMaxRetry;
            timeout = config.levelLoadingTimeOut;
            retryDelay = config.levelLoadingRetryDelay;
            maxRetryDelay = config.levelLoadingMaxRetryTimeout;
            _logger.logger.log('loading playlist for ' + context.type + ' ' + (context.level || context.id));
          }
          loader = this.loaders[context.type] = context.loader = typeof config.pLoader !== 'undefined' ? new config.pLoader(config) : new config.loader(config);
          context.url = url;
          context.responseType = '';
    
          var loaderConfig = void 0,
              loaderCallbacks = void 0;
          loaderConfig = { timeout: timeout, maxRetry: retry, retryDelay: retryDelay, maxRetryDelay: maxRetryDelay };
          loaderCallbacks = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) };
          loader.load(context, loaderConfig, loaderCallbacks);
        }
      }, {
        key: 'resolve',
        value: function resolve(url, baseUrl) {
          return _urlToolkit2.default.buildAbsoluteURL(baseUrl, url, { alwaysNormalize: true });
        }
      }, {
        key: 'parseMasterPlaylist',
        value: function parseMasterPlaylist(string, baseurl) {
          var levels = [],
              result = void 0;
          MASTER_PLAYLIST_REGEX.lastIndex = 0;
          while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
            var level = {};
    
            var attrs = level.attrs = new _attrList2.default(result[1]);
            level.url = this.resolve(result[2], baseurl);
    
            var resolution = attrs.decimalResolution('RESOLUTION');
            if (resolution) {
              level.width = resolution.width;
              level.height = resolution.height;
            }
            level.bitrate = attrs.decimalInteger('AVERAGE-BANDWIDTH') || attrs.decimalInteger('BANDWIDTH');
            level.name = attrs.NAME;
    
            var codecs = attrs.CODECS;
            if (codecs) {
              codecs = codecs.split(/[ ,]+/);
              for (var i = 0; i < codecs.length; i++) {
                var codec = codecs[i];
                if (codec.indexOf('avc1') !== -1) {
                  level.videoCodec = this.avc1toavcoti(codec);
                } else {
                  level.audioCodec = codec;
                }
              }
            }
    
            levels.push(level);
          }
          return levels;
        }
      }, {
        key: 'parseMasterPlaylistMedia',
        value: function parseMasterPlaylistMedia(string, baseurl, type) {
          var result = void 0,
              medias = [],
              id = 0;
          MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
          while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) != null) {
            var media = {};
            var attrs = new _attrList2.default(result[1]);
            if (attrs.TYPE === type) {
              media.groupId = attrs['GROUP-ID'];
              media.name = attrs.NAME;
              media.type = type;
              media.default = attrs.DEFAULT === 'YES';
              media.autoselect = attrs.AUTOSELECT === 'YES';
              media.forced = attrs.FORCED === 'YES';
              if (attrs.URI) {
                media.url = this.resolve(attrs.URI, baseurl);
              }
              media.lang = attrs.LANGUAGE;
              if (!media.name) {
                media.name = media.lang;
              }
              media.id = id++;
              medias.push(media);
            }
          }
          return medias;
        }
      }, {
        key: 'avc1toavcoti',
        value: function avc1toavcoti(codec) {
          var result,
              avcdata = codec.split('.');
          if (avcdata.length > 2) {
            result = avcdata.shift() + '.';
            result += parseInt(avcdata.shift()).toString(16);
            result += ('000' + parseInt(avcdata.shift()).toString(16)).substr(-4);
          } else {
            result = codec;
          }
          return result;
        }
      }, {
        key: 'parseLevelPlaylist',
        value: function parseLevelPlaylist(string, baseurl, id, type) {
          var currentSN = 0,
              totalduration = 0,
              level = { type: null, version: null, url: baseurl, fragments: [], live: true, startSN: 0 },
              levelkey = new LevelKey(),
              cc = 0,
              prevFrag = null,
              frag = new Fragment(),
              result,
              i;
    
          LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
    
          while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
            var duration = result[1];
            if (duration) {
              // INF
              frag.duration = parseFloat(duration);
              // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
              var title = (' ' + result[2]).slice(1);
              frag.title = title ? title : null;
              frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);
            } else if (result[3]) {
              // url
              if (!isNaN(frag.duration)) {
                var sn = currentSN++;
                frag.type = type;
                frag.start = totalduration;
                frag.levelkey = levelkey;
                frag.sn = sn;
                frag.level = id;
                frag.cc = cc;
                frag.baseurl = baseurl;
                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
                frag.relurl = (' ' + result[3]).slice(1);
    
                level.fragments.push(frag);
                prevFrag = frag;
                totalduration += frag.duration;
    
                frag = new Fragment();
              }
            } else if (result[4]) {
              // X-BYTERANGE
              frag.rawByteRange = (' ' + result[4]).slice(1);
              if (prevFrag) {
                var lastByteRangeEndOffset = prevFrag.byteRangeEndOffset;
                if (lastByteRangeEndOffset) {
                  frag.lastByteRangeEndOffset = lastByteRangeEndOffset;
                }
              }
            } else if (result[5]) {
              // PROGRAM-DATE-TIME
              // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
              frag.rawProgramDateTime = (' ' + result[5]).slice(1);
              frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);
            } else {
              result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
              for (i = 1; i < result.length; i++) {
                if (result[i] !== undefined) {
                  break;
                }
              }
    
              // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939
              var value1 = (' ' + result[i + 1]).slice(1);
              var value2 = (' ' + result[i + 2]).slice(1);
    
              switch (result[i]) {
                case '#':
                  frag.tagList.push(value2 ? [value1, value2] : [value1]);
                  break;
                case 'PLAYLIST-TYPE':
                  level.type = value1.toUpperCase();
                  break;
                case 'MEDIA-SEQUENCE':
                  currentSN = level.startSN = parseInt(value1);
                  break;
                case 'TARGETDURATION':
                  level.targetduration = parseFloat(value1);
                  break;
                case 'VERSION':
                  level.version = parseInt(value1);
                  break;
                case 'EXTM3U':
                  break;
                case 'ENDLIST':
                  level.live = false;
                  break;
                case 'DIS':
                  cc++;
                  frag.tagList.push(['DIS']);
                  break;
                case 'DISCONTINUITY-SEQ':
                  cc = parseInt(value1);
                  break;
                case 'KEY':
                  // https://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-3.4.4
                  var decryptparams = value1;
                  var keyAttrs = new _attrList2.default(decryptparams);
                  var decryptmethod = keyAttrs.enumeratedString('METHOD'),
                      decrypturi = keyAttrs.URI,
                      decryptiv = keyAttrs.hexadecimalInteger('IV');
                  if (decryptmethod) {
                    levelkey = new LevelKey();
                    if (decrypturi && ['AES-128', 'SAMPLE-AES'].indexOf(decryptmethod) >= 0) {
                      levelkey.method = decryptmethod;
                      // URI to get the key
                      levelkey.baseuri = baseurl;
                      levelkey.reluri = decrypturi;
                      levelkey.key = null;
                      // Initialization Vector (IV)
                      levelkey.iv = decryptiv;
                    }
                  }
                  break;
                case 'START':
                  var startParams = value1;
                  var startAttrs = new _attrList2.default(startParams);
                  var startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');
                  //TIME-OFFSET can be 0
                  if (!isNaN(startTimeOffset)) {
                    level.startTimeOffset = startTimeOffset;
                  }
                  break;
                case 'MAP':
                  var mapAttrs = new _attrList2.default(value1);
                  frag.relurl = mapAttrs.URI;
                  frag.rawByteRange = mapAttrs.BYTERANGE;
                  frag.baseurl = baseurl;
                  frag.level = id;
                  frag.type = type;
                  frag.sn = 'initSegment';
                  level.initSegment = frag;
                  frag = new Fragment();
                  break;
                default:
                  _logger.logger.warn('line parsed but not handled: ' + result);
                  break;
              }
            }
          }
          frag = prevFrag;
          //logger.log('found ' + level.fragments.length + ' fragments');
          if (frag && !frag.relurl) {
            level.fragments.pop();
            totalduration -= frag.duration;
          }
          level.totalduration = totalduration;
          level.averagetargetduration = totalduration / level.fragments.length;
          level.endSN = currentSN - 1;
          return level;
        }
      }, {
        key: 'loadsuccess',
        value: function loadsuccess(response, stats, context) {
          var string = response.data,
              url = response.url,
              type = context.type,
              id = context.id,
              level = context.level,
              hls = this.hls;
    
          this.loaders[type] = undefined;
          // responseURL not supported on some browsers (it is used to detect URL redirection)
          // data-uri mode also not supported (but no need to detect redirection)
          if (url === undefined || url.indexOf('data:') === 0) {
            // fallback to initial URL
            url = context.url;
          }
          stats.tload = performance.now();
          //stats.mtime = new Date(target.getResponseHeader('Last-Modified'));
          if (string.indexOf('#EXTM3U') === 0) {
            if (string.indexOf('#EXTINF:') > 0) {
              var isLevel = type !== 'audioTrack' && type !== 'subtitleTrack',
                  levelId = !isNaN(level) ? level : !isNaN(id) ? id : 0,
                  levelDetails = this.parseLevelPlaylist(string, url, levelId, type === 'audioTrack' ? 'audio' : type === 'subtitleTrack' ? 'subtitle' : 'main');
              levelDetails.tload = stats.tload;
              if (type === 'manifest') {
                // first request, stream manifest (no master playlist), fire manifest loaded event with level details
                hls.trigger(_events2.default.MANIFEST_LOADED, { levels: [{ url: url, details: levelDetails }], audioTracks: [], url: url, stats: stats });
              }
              stats.tparsed = performance.now();
              if (levelDetails.targetduration) {
                if (isLevel) {
                  hls.trigger(_events2.default.LEVEL_LOADED, { details: levelDetails, level: level || 0, id: id || 0, stats: stats });
                } else {
                  if (type === 'audioTrack') {
                    hls.trigger(_events2.default.AUDIO_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });
                  } else if (type === 'subtitleTrack') {
                    hls.trigger(_events2.default.SUBTITLE_TRACK_LOADED, { details: levelDetails, id: id, stats: stats });
                  }
                }
              } else {
                hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'invalid targetduration' });
              }
            } else {
              var levels = this.parseMasterPlaylist(string, url);
              // multi level playlist, parse level info
              if (levels.length) {
                var audioTracks = this.parseMasterPlaylistMedia(string, url, 'AUDIO');
                var subtitles = this.parseMasterPlaylistMedia(string, url, 'SUBTITLES');
                if (audioTracks.length) {
                  // check if we have found an audio track embedded in main playlist (audio track without URI attribute)
                  var embeddedAudioFound = false;
                  audioTracks.forEach(function (audioTrack) {
                    if (!audioTrack.url) {
                      embeddedAudioFound = true;
                    }
                  });
                  // if no embedded audio track defined, but audio codec signaled in quality level, we need to signal this main audio track
                  // this could happen with playlists with alt audio rendition in which quality levels (main) contains both audio+video. but with mixed audio track not signaled
                  if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                    _logger.logger.log('audio codec signaled in quality level, but no embedded audio track signaled, create one');
                    audioTracks.unshift({ type: 'main', name: 'main' });
                  }
                }
                hls.trigger(_events2.default.MANIFEST_LOADED, { levels: levels, audioTracks: audioTracks, subtitles: subtitles, url: url, stats: stats });
              } else {
                hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no level found in manifest' });
              }
            }
          } else {
            hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: _errors.ErrorDetails.MANIFEST_PARSING_ERROR, fatal: true, url: url, reason: 'no EXTM3U delimiter' });
          }
        }
      }, {
        key: 'loaderror',
        value: function loaderror(response, context) {
          var details,
              fatal,
              loader = context.loader;
          switch (context.type) {
            case 'manifest':
              details = _errors.ErrorDetails.MANIFEST_LOAD_ERROR;
              fatal = true;
              break;
            case 'level':
              details = _errors.ErrorDetails.LEVEL_LOAD_ERROR;
              fatal = false;
              break;
            case 'audioTrack':
              details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
              fatal = false;
              break;
          }
          if (loader) {
            loader.abort();
            this.loaders[context.type] = undefined;
          }
          this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, response: response, context: context });
        }
      }, {
        key: 'loadtimeout',
        value: function loadtimeout(stats, context) {
          var details,
              fatal,
              loader = context.loader;
          switch (context.type) {
            case 'manifest':
              details = _errors.ErrorDetails.MANIFEST_LOAD_TIMEOUT;
              fatal = true;
              break;
            case 'level':
              details = _errors.ErrorDetails.LEVEL_LOAD_TIMEOUT;
              fatal = false;
              break;
            case 'audioTrack':
              details = _errors.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT;
              fatal = false;
              break;
          }
          if (loader) {
            loader.abort();
            this.loaders[context.type] = undefined;
          }
          this.hls.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.NETWORK_ERROR, details: details, fatal: fatal, url: loader.url, loader: loader, context: context });
        }
      }]);
    
      return PlaylistLoader;
    }(_eventHandler2.default);
    
    exports.default = PlaylistLoader;
    
    },{"2":2,"31":31,"32":32,"33":33,"45":45,"51":51}],42:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     * Generate MP4 Box
    */
    
    //import Hex from '../utils/hex';
    
    var UINT32_MAX = Math.pow(2, 32) - 1;
    
    var MP4 = function () {
      function MP4() {
        _classCallCheck(this, MP4);
      }
    
      _createClass(MP4, null, [{
        key: 'init',
        value: function init() {
          MP4.types = {
            avc1: [], // codingname
            avcC: [],
            btrt: [],
            dinf: [],
            dref: [],
            esds: [],
            ftyp: [],
            hdlr: [],
            mdat: [],
            mdhd: [],
            mdia: [],
            mfhd: [],
            minf: [],
            moof: [],
            moov: [],
            mp4a: [],
            '.mp3': [],
            mvex: [],
            mvhd: [],
            pasp: [],
            sdtp: [],
            stbl: [],
            stco: [],
            stsc: [],
            stsd: [],
            stsz: [],
            stts: [],
            tfdt: [],
            tfhd: [],
            traf: [],
            trak: [],
            trun: [],
            trex: [],
            tkhd: [],
            vmhd: [],
            smhd: []
          };
    
          var i;
          for (i in MP4.types) {
            if (MP4.types.hasOwnProperty(i)) {
              MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
            }
          }
    
          var videoHdlr = new Uint8Array([0x00, // version 0
          0x00, 0x00, 0x00, // flags
          0x00, 0x00, 0x00, 0x00, // pre_defined
          0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'
          0x00, 0x00, 0x00, 0x00, // reserved
          0x00, 0x00, 0x00, 0x00, // reserved
          0x00, 0x00, 0x00, 0x00, // reserved
          0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'
          ]);
    
          var audioHdlr = new Uint8Array([0x00, // version 0
          0x00, 0x00, 0x00, // flags
          0x00, 0x00, 0x00, 0x00, // pre_defined
          0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'
          0x00, 0x00, 0x00, 0x00, // reserved
          0x00, 0x00, 0x00, 0x00, // reserved
          0x00, 0x00, 0x00, 0x00, // reserved
          0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'
          ]);
    
          MP4.HDLR_TYPES = {
            'video': videoHdlr,
            'audio': audioHdlr
          };
    
          var dref = new Uint8Array([0x00, // version 0
          0x00, 0x00, 0x00, // flags
          0x00, 0x00, 0x00, 0x01, // entry_count
          0x00, 0x00, 0x00, 0x0c, // entry_size
          0x75, 0x72, 0x6c, 0x20, // 'url' type
          0x00, // version 0
          0x00, 0x00, 0x01 // entry_flags
          ]);
    
          var stco = new Uint8Array([0x00, // version
          0x00, 0x00, 0x00, // flags
          0x00, 0x00, 0x00, 0x00 // entry_count
          ]);
    
          MP4.STTS = MP4.STSC = MP4.STCO = stco;
    
          MP4.STSZ = new Uint8Array([0x00, // version
          0x00, 0x00, 0x00, // flags
          0x00, 0x00, 0x00, 0x00, // sample_size
          0x00, 0x00, 0x00, 0x00]);
          MP4.VMHD = new Uint8Array([0x00, // version
          0x00, 0x00, 0x01, // flags
          0x00, 0x00, // graphicsmode
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor
          ]);
          MP4.SMHD = new Uint8Array([0x00, // version
          0x00, 0x00, 0x00, // flags
          0x00, 0x00, // balance
          0x00, 0x00 // reserved
          ]);
    
          MP4.STSD = new Uint8Array([0x00, // version 0
          0x00, 0x00, 0x00, // flags
          0x00, 0x00, 0x00, 0x01]); // entry_count
    
          var majorBrand = new Uint8Array([105, 115, 111, 109]); // isom
          var avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1
          var minorVersion = new Uint8Array([0, 0, 0, 1]);
    
          MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
          MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
        }
      }, {
        key: 'box',
        value: function box(type) {
          var payload = Array.prototype.slice.call(arguments, 1),
              size = 8,
              i = payload.length,
              len = i,
              result;
          // calculate the total size we need to allocate
          while (i--) {
            size += payload[i].byteLength;
          }
          result = new Uint8Array(size);
          result[0] = size >> 24 & 0xff;
          result[1] = size >> 16 & 0xff;
          result[2] = size >> 8 & 0xff;
          result[3] = size & 0xff;
          result.set(type, 4);
          // copy the payload into the result
          for (i = 0, size = 8; i < len; i++) {
            // copy payload[i] array @ offset size
            result.set(payload[i], size);
            size += payload[i].byteLength;
          }
          return result;
        }
      }, {
        key: 'hdlr',
        value: function hdlr(type) {
          return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
        }
      }, {
        key: 'mdat',
        value: function mdat(data) {
          return MP4.box(MP4.types.mdat, data);
        }
      }, {
        key: 'mdhd',
        value: function mdhd(timescale, duration) {
          duration *= timescale;
          var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
          var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
          return MP4.box(MP4.types.mdhd, new Uint8Array([0x01, // version 1
          0x00, 0x00, 0x00, // flags
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
          timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
          upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x55, 0xc4, // 'und' language (undetermined)
          0x00, 0x00]));
        }
      }, {
        key: 'mdia',
        value: function mdia(track) {
          return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
        }
      }, {
        key: 'mfhd',
        value: function mfhd(sequenceNumber) {
          return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags
          sequenceNumber >> 24, sequenceNumber >> 16 & 0xFF, sequenceNumber >> 8 & 0xFF, sequenceNumber & 0xFF]));
        }
      }, {
        key: 'minf',
        value: function minf(track) {
          if (track.type === 'audio') {
            return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
          } else {
            return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
          }
        }
      }, {
        key: 'moof',
        value: function moof(sn, baseMediaDecodeTime, track) {
          return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
        }
        /**
         * @param tracks... (optional) {array} the tracks associated with this movie
         */
    
      }, {
        key: 'moov',
        value: function moov(tracks) {
          var i = tracks.length,
              boxes = [];
    
          while (i--) {
            boxes[i] = MP4.trak(tracks[i]);
          }
    
          return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
        }
      }, {
        key: 'mvex',
        value: function mvex(tracks) {
          var i = tracks.length,
              boxes = [];
    
          while (i--) {
            boxes[i] = MP4.trex(tracks[i]);
          }
          return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
        }
      }, {
        key: 'mvhd',
        value: function mvhd(timescale, duration) {
          duration *= timescale;
          var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
          var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
          var bytes = new Uint8Array([0x01, // version 1
          0x00, 0x00, 0x00, // flags
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
          timescale >> 24 & 0xFF, timescale >> 16 & 0xFF, timescale >> 8 & 0xFF, timescale & 0xFF, // timescale
          upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x01, 0x00, 0x00, // 1.0 rate
          0x01, 0x00, // 1.0 volume
          0x00, 0x00, // reserved
          0x00, 0x00, 0x00, 0x00, // reserved
          0x00, 0x00, 0x00, 0x00, // reserved
          0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
          0xff, 0xff, 0xff, 0xff // next_track_ID
          ]);
          return MP4.box(MP4.types.mvhd, bytes);
        }
      }, {
        key: 'sdtp',
        value: function sdtp(track) {
          var samples = track.samples || [],
              bytes = new Uint8Array(4 + samples.length),
              flags,
              i;
          // leave the full box header (4 bytes) all zero
          // write the sample table
          for (i = 0; i < samples.length; i++) {
            flags = samples[i].flags;
            bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
          }
    
          return MP4.box(MP4.types.sdtp, bytes);
        }
      }, {
        key: 'stbl',
        value: function stbl(track) {
          return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
        }
      }, {
        key: 'avc1',
        value: function avc1(track) {
          var sps = [],
              pps = [],
              i,
              data,
              len;
          // assemble the SPSs
    
          for (i = 0; i < track.sps.length; i++) {
            data = track.sps[i];
            len = data.byteLength;
            sps.push(len >>> 8 & 0xFF);
            sps.push(len & 0xFF);
            sps = sps.concat(Array.prototype.slice.call(data)); // SPS
          }
    
          // assemble the PPSs
          for (i = 0; i < track.pps.length; i++) {
            data = track.pps[i];
            len = data.byteLength;
            pps.push(len >>> 8 & 0xFF);
            pps.push(len & 0xFF);
            pps = pps.concat(Array.prototype.slice.call(data));
          }
    
          var avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01, // version
          sps[3], // profile
          sps[4], // profile compat
          sps[5], // level
          0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes
          0xE0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets
          ].concat(sps).concat([track.pps.length // numOfPictureParameterSets
          ]).concat(pps))),
              // "PPS"
          width = track.width,
              height = track.height,
              hSpacing = track.pixelRatio[0],
              vSpacing = track.pixelRatio[1];
          //console.log('avcc:' + Hex.hexDump(avcc));
          return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00, // reserved
          0x00, 0x00, 0x00, // reserved
          0x00, 0x01, // data_reference_index
          0x00, 0x00, // pre_defined
          0x00, 0x00, // reserved
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined
          width >> 8 & 0xFF, width & 0xff, // width
          height >> 8 & 0xFF, height & 0xff, // height
          0x00, 0x48, 0x00, 0x00, // horizresolution
          0x00, 0x48, 0x00, 0x00, // vertresolution
          0x00, 0x00, 0x00, 0x00, // reserved
          0x00, 0x01, // frame_count
          0x12, 0x64, 0x61, 0x69, 0x6C, //dailymotion/hls.js
          0x79, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x68, 0x6C, 0x73, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname
          0x00, 0x18, // depth = 24
          0x11, 0x11]), // pre_defined = -1
          avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB
          0x00, 0x2d, 0xc6, 0xc0, // maxBitrate
          0x00, 0x2d, 0xc6, 0xc0])), // avgBitrate
          MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24, // hSpacing
          hSpacing >> 16 & 0xFF, hSpacing >> 8 & 0xFF, hSpacing & 0xFF, vSpacing >> 24, // vSpacing
          vSpacing >> 16 & 0xFF, vSpacing >> 8 & 0xFF, vSpacing & 0xFF])));
        }
      }, {
        key: 'esds',
        value: function esds(track) {
          var configlen = track.config.length;
          return new Uint8Array([0x00, // version 0
          0x00, 0x00, 0x00, // flags
    
          0x03, // descriptor_type
          0x17 + configlen, // length
          0x00, 0x01, //es_id
          0x00, // stream_priority
    
          0x04, // descriptor_type
          0x0f + configlen, // length
          0x40, //codec : mpeg4_audio
          0x15, // stream_type
          0x00, 0x00, 0x00, // buffer_size
          0x00, 0x00, 0x00, 0x00, // maxBitrate
          0x00, 0x00, 0x00, 0x00, // avgBitrate
    
          0x05 // descriptor_type
          ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor
        }
      }, {
        key: 'mp4a',
        value: function mp4a(track) {
          var samplerate = track.samplerate;
          return MP4.box(MP4.types.mp4a, new Uint8Array([0x00, 0x00, 0x00, // reserved
          0x00, 0x00, 0x00, // reserved
          0x00, 0x01, // data_reference_index
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
          0x00, track.channelCount, // channelcount
          0x00, 0x10, // sampleSize:16bits
          0x00, 0x00, 0x00, 0x00, // reserved2
          samplerate >> 8 & 0xFF, samplerate & 0xff, //
          0x00, 0x00]), MP4.box(MP4.types.esds, MP4.esds(track)));
        }
      }, {
        key: 'mp3',
        value: function mp3(track) {
          var samplerate = track.samplerate;
          return MP4.box(MP4.types['.mp3'], new Uint8Array([0x00, 0x00, 0x00, // reserved
          0x00, 0x00, 0x00, // reserved
          0x00, 0x01, // data_reference_index
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
          0x00, track.channelCount, // channelcount
          0x00, 0x10, // sampleSize:16bits
          0x00, 0x00, 0x00, 0x00, // reserved2
          samplerate >> 8 & 0xFF, samplerate & 0xff, //
          0x00, 0x00]));
        }
      }, {
        key: 'stsd',
        value: function stsd(track) {
          if (track.type === 'audio') {
            if (!track.isAAC && track.codec === 'mp3') {
              return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
            }
            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
          } else {
            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
          }
        }
      }, {
        key: 'tkhd',
        value: function tkhd(track) {
          var id = track.id,
              duration = track.duration * track.timescale,
              width = track.width,
              height = track.height,
              upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)),
              lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
          return MP4.box(MP4.types.tkhd, new Uint8Array([0x01, // version 1
          0x00, 0x00, 0x07, // flags
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // creation_time
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // modification_time
          id >> 24 & 0xFF, id >> 16 & 0xFF, id >> 8 & 0xFF, id & 0xFF, // track_ID
          0x00, 0x00, 0x00, 0x00, // reserved
          upperWordDuration >> 24, upperWordDuration >> 16 & 0xFF, upperWordDuration >> 8 & 0xFF, upperWordDuration & 0xFF, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xFF, lowerWordDuration >> 8 & 0xFF, lowerWordDuration & 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved
          0x00, 0x00, // layer
          0x00, 0x00, // alternate_group
          0x00, 0x00, // non-audio track volume
          0x00, 0x00, // reserved
          0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix
          width >> 8 & 0xFF, width & 0xFF, 0x00, 0x00, // width
          height >> 8 & 0xFF, height & 0xFF, 0x00, 0x00 // height
          ]));
        }
      }, {
        key: 'traf',
        value: function traf(track, baseMediaDecodeTime) {
          var sampleDependencyTable = MP4.sdtp(track),
              id = track.id,
              upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)),
              lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
          return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00, // version 0
          0x00, 0x00, 0x00, // flags
          id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01, // version 1
          0x00, 0x00, 0x00, // flags
          upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0XFF, upperWordBaseMediaDecodeTime >> 8 & 0XFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0XFF, lowerWordBaseMediaDecodeTime >> 8 & 0XFF, lowerWordBaseMediaDecodeTime & 0xFF])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd
          20 + // tfdt
          8 + // traf header
          16 + // mfhd
          8 + // moof header
          8), // mdat header
          sampleDependencyTable);
        }
    
        /**
         * Generate a track box.
         * @param track {object} a track definition
         * @return {Uint8Array} the track box
         */
    
      }, {
        key: 'trak',
        value: function trak(track) {
          track.duration = track.duration || 0xffffffff;
          return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
        }
      }, {
        key: 'trex',
        value: function trex(track) {
          var id = track.id;
          return MP4.box(MP4.types.trex, new Uint8Array([0x00, // version 0
          0x00, 0x00, 0x00, // flags
          id >> 24, id >> 16 & 0XFF, id >> 8 & 0XFF, id & 0xFF, // track_ID
          0x00, 0x00, 0x00, 0x01, // default_sample_description_index
          0x00, 0x00, 0x00, 0x00, // default_sample_duration
          0x00, 0x00, 0x00, 0x00, // default_sample_size
          0x00, 0x01, 0x00, 0x01 // default_sample_flags
          ]));
        }
      }, {
        key: 'trun',
        value: function trun(track, offset) {
          var samples = track.samples || [],
              len = samples.length,
              arraylen = 12 + 16 * len,
              array = new Uint8Array(arraylen),
              i,
              sample,
              duration,
              size,
              flags,
              cts;
          offset += 8 + arraylen;
          array.set([0x00, // version 0
          0x00, 0x0f, 0x01, // flags
          len >>> 24 & 0xFF, len >>> 16 & 0xFF, len >>> 8 & 0xFF, len & 0xFF, // sample_count
          offset >>> 24 & 0xFF, offset >>> 16 & 0xFF, offset >>> 8 & 0xFF, offset & 0xFF // data_offset
          ], 0);
          for (i = 0; i < len; i++) {
            sample = samples[i];
            duration = sample.duration;
            size = sample.size;
            flags = sample.flags;
            cts = sample.cts;
            array.set([duration >>> 24 & 0xFF, duration >>> 16 & 0xFF, duration >>> 8 & 0xFF, duration & 0xFF, // sample_duration
            size >>> 24 & 0xFF, size >>> 16 & 0xFF, size >>> 8 & 0xFF, size & 0xFF, // sample_size
            flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xF0 << 8, flags.degradPrio & 0x0F, // sample_flags
            cts >>> 24 & 0xFF, cts >>> 16 & 0xFF, cts >>> 8 & 0xFF, cts & 0xFF // sample_composition_time_offset
            ], 12 + 16 * i);
          }
          return MP4.box(MP4.types.trun, array);
        }
      }, {
        key: 'initSegment',
        value: function initSegment(tracks) {
          if (!MP4.types) {
            MP4.init();
          }
          var movie = MP4.moov(tracks),
              result;
          result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
          result.set(MP4.FTYP);
          result.set(movie, MP4.FTYP.byteLength);
          return result;
        }
      }]);
    
      return MP4;
    }();
    
    exports.default = MP4;
    
    },{}],43:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * fMP4 remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         */
    
    var _aac = _dereq_(34);
    
    var _aac2 = _interopRequireDefault(_aac);
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    var _logger = _dereq_(51);
    
    var _mp4Generator = _dereq_(42);
    
    var _mp4Generator2 = _interopRequireDefault(_mp4Generator);
    
    var _errors = _dereq_(31);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var MP4Remuxer = function () {
      function MP4Remuxer(observer, config, typeSupported, vendor) {
        _classCallCheck(this, MP4Remuxer);
    
        this.observer = observer;
        this.config = config;
        this.typeSupported = typeSupported;
        var userAgent = navigator.userAgent;
        this.isSafari = vendor && vendor.indexOf('Apple') > -1 && userAgent && !userAgent.match('CriOS');
        this.ISGenerated = false;
      }
    
      _createClass(MP4Remuxer, [{
        key: 'destroy',
        value: function destroy() {}
      }, {
        key: 'resetTimeStamp',
        value: function resetTimeStamp(defaultTimeStamp) {
          this._initPTS = this._initDTS = defaultTimeStamp;
        }
      }, {
        key: 'resetInitSegment',
        value: function resetInitSegment() {
          this.ISGenerated = false;
        }
      }, {
        key: 'remux',
        value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
          // generate Init Segment if needed
          if (!this.ISGenerated) {
            this.generateIS(audioTrack, videoTrack, timeOffset);
          }
    
          if (this.ISGenerated) {
            // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is
            // calculated in remuxAudio.
            //logger.log('nb AAC samples:' + audioTrack.samples.length);
            if (audioTrack.samples.length) {
              // if initSegment was generated without video samples, regenerate it again
              if (!audioTrack.timescale) {
                _logger.logger.warn('regenerate InitSegment as audio detected');
                this.generateIS(audioTrack, videoTrack, timeOffset);
              }
              var audioData = this.remuxAudio(audioTrack, timeOffset, contiguous, accurateTimeOffset);
              //logger.log('nb AVC samples:' + videoTrack.samples.length);
              if (videoTrack.samples.length) {
                var audioTrackLength = void 0;
                if (audioData) {
                  audioTrackLength = audioData.endPTS - audioData.startPTS;
                }
                // if initSegment was generated without video samples, regenerate it again
                if (!videoTrack.timescale) {
                  _logger.logger.warn('regenerate InitSegment as video detected');
                  this.generateIS(audioTrack, videoTrack, timeOffset);
                }
                this.remuxVideo(videoTrack, timeOffset, contiguous, audioTrackLength);
              }
            } else {
              var videoData = void 0;
              //logger.log('nb AVC samples:' + videoTrack.samples.length);
              if (videoTrack.samples.length) {
                videoData = this.remuxVideo(videoTrack, timeOffset, contiguous);
              }
              if (videoData && audioTrack.codec) {
                this.remuxEmptyAudio(audioTrack, timeOffset, contiguous, videoData);
              }
            }
          }
          //logger.log('nb ID3 samples:' + audioTrack.samples.length);
          if (id3Track.samples.length) {
            this.remuxID3(id3Track, timeOffset);
          }
          //logger.log('nb ID3 samples:' + audioTrack.samples.length);
          if (textTrack.samples.length) {
            this.remuxText(textTrack, timeOffset);
          }
          //notify end of parsing
          this.observer.trigger(_events2.default.FRAG_PARSED);
        }
      }, {
        key: 'generateIS',
        value: function generateIS(audioTrack, videoTrack, timeOffset) {
          var observer = this.observer,
              audioSamples = audioTrack.samples,
              videoSamples = videoTrack.samples,
              typeSupported = this.typeSupported,
              container = 'audio/mp4',
              tracks = {},
              data = { tracks: tracks },
              computePTSDTS = this._initPTS === undefined,
              initPTS,
              initDTS;
    
          if (computePTSDTS) {
            initPTS = initDTS = Infinity;
          }
          if (audioTrack.config && audioSamples.length) {
            // let's use audio sampling rate as MP4 time scale.
            // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)
            // using audio sampling rate here helps having an integer MP4 frame duration
            // this avoids potential rounding issue and AV sync issue
            audioTrack.timescale = audioTrack.samplerate;
            _logger.logger.log('audio sampling rate : ' + audioTrack.samplerate);
            if (!audioTrack.isAAC) {
              if (typeSupported.mpeg) {
                // Chrome and Safari
                container = 'audio/mpeg';
                audioTrack.codec = '';
              } else if (typeSupported.mp3) {
                // Firefox
                audioTrack.codec = 'mp3';
              }
            }
            tracks.audio = {
              container: container,
              codec: audioTrack.codec,
              initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : _mp4Generator2.default.initSegment([audioTrack]),
              metadata: {
                channelCount: audioTrack.channelCount
              }
            };
            if (computePTSDTS) {
              // remember first PTS of this demuxing context. for audio, PTS = DTS
              initPTS = initDTS = audioSamples[0].pts - audioTrack.inputTimeScale * timeOffset;
            }
          }
    
          if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
            // let's use input time scale as MP4 video timescale
            // we use input time scale straight away to avoid rounding issues on frame duration / cts computation
            var inputTimeScale = videoTrack.inputTimeScale;
            videoTrack.timescale = inputTimeScale;
            tracks.video = {
              container: 'video/mp4',
              codec: videoTrack.codec,
              initSegment: _mp4Generator2.default.initSegment([videoTrack]),
              metadata: {
                width: videoTrack.width,
                height: videoTrack.height
              }
            };
            if (computePTSDTS) {
              initPTS = Math.min(initPTS, videoSamples[0].pts - inputTimeScale * timeOffset);
              initDTS = Math.min(initDTS, videoSamples[0].dts - inputTimeScale * timeOffset);
              this.observer.trigger(_events2.default.INIT_PTS_FOUND, { initPTS: initPTS });
            }
          }
    
          if (Object.keys(tracks).length) {
            observer.trigger(_events2.default.FRAG_PARSING_INIT_SEGMENT, data);
            this.ISGenerated = true;
            if (computePTSDTS) {
              this._initPTS = initPTS;
              this._initDTS = initDTS;
            }
          } else {
            observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MEDIA_ERROR, details: _errors.ErrorDetails.FRAG_PARSING_ERROR, fatal: false, reason: 'no audio/video samples found' });
          }
        }
      }, {
        key: 'remuxVideo',
        value: function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
          var offset = 8,
              timeScale = track.timescale,
              mp4SampleDuration,
              mdat,
              moof,
              firstPTS,
              firstDTS,
              nextDTS,
              lastPTS,
              lastDTS,
              inputSamples = track.samples,
              outputSamples = [],
              nbSamples = inputSamples.length,
              ptsNormalize = this._PTSNormalize,
              initDTS = this._initDTS;
    
          // for (let i = 0; i < track.samples.length; i++) {
          //   let avcSample = track.samples[i];
          //   let units = avcSample.units;
          //   let unitsString = '';
          //   for (let j = 0; j < units.length ; j++) {
          //     unitsString += units[j].type + ',';
          //     if (units[j].data.length < 500) {
          //       unitsString += Hex.hexDump(units[j].data);
          //     }
          //   }
          //   logger.log(avcSample.pts + '/' + avcSample.dts + ',' + unitsString + avcSample.units.length);
          // }
    
          // sort video samples by DTS then PTS then demux id order
          inputSamples.sort(function (a, b) {
            var deltadts = a.dts - b.dts;
            var deltapts = a.pts - b.pts;
            return deltadts ? deltadts : deltapts ? deltapts : a.id - b.id;
          });
    
          // handle broken streams with PTS < DTS, tolerance up 200ms (18000 in 90kHz timescale)
          var PTSDTSshift = inputSamples.reduce(function (prev, curr) {
            return Math.max(Math.min(prev, curr.pts - curr.dts), -18000);
          }, 0);
          if (PTSDTSshift < 0) {
            _logger.logger.warn('PTS < DTS detected in video samples, shifting DTS by ' + Math.round(PTSDTSshift / 90) + ' ms to overcome this issue');
            for (var i = 0; i < inputSamples.length; i++) {
              inputSamples[i].dts += PTSDTSshift;
            }
          }
    
          // PTS is coded on 33bits, and can loop from -2^32 to 2^32
          // ptsNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value
          var nextAvcDts = void 0;
          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
          if (contiguous) {
            // if parsed fragment is contiguous with last one, let's use last DTS value as reference
            nextAvcDts = this.nextAvcDts;
          } else {
            // if not contiguous, let's use target timeOffset
            nextAvcDts = timeOffset * timeScale;
          }
    
          // compute first DTS and last DTS, normalize them against reference value
          var sample = inputSamples[0];
          firstDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);
          firstPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);
    
          // check timestamp continuity accross consecutive fragments (this is to remove inter-fragment gap/hole)
          var delta = Math.round((firstDTS - nextAvcDts) / 90);
          // if fragment are contiguous, detect hole/overlapping between fragments
          if (contiguous) {
            if (delta) {
              if (delta > 1) {
                _logger.logger.log('AVC:' + delta + ' ms hole between fragments detected,filling it');
              } else if (delta < -1) {
                _logger.logger.log('AVC:' + -delta + ' ms overlapping between fragments detected');
              }
              // remove hole/gap : set DTS to next expected DTS
              firstDTS = nextAvcDts;
              inputSamples[0].dts = firstDTS + initDTS;
              // offset PTS as well, ensure that PTS is smaller or equal than new DTS
              firstPTS = Math.max(firstPTS - delta, nextAvcDts);
              inputSamples[0].pts = firstPTS + initDTS;
              _logger.logger.log('Video/PTS/DTS adjusted: ' + Math.round(firstPTS / 90) + '/' + Math.round(firstDTS / 90) + ',delta:' + delta + ' ms');
            }
          }
          nextDTS = firstDTS;
    
          // compute lastPTS/lastDTS
          sample = inputSamples[inputSamples.length - 1];
          lastDTS = Math.max(ptsNormalize(sample.dts - initDTS, nextAvcDts), 0);
          lastPTS = Math.max(ptsNormalize(sample.pts - initDTS, nextAvcDts), 0);
          lastPTS = Math.max(lastPTS, lastDTS);
    
          var isSafari = this.isSafari;
          // on Safari let's signal the same sample duration for all samples
          // sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS
          // set this constant duration as being the avg delta between consecutive DTS.
          if (isSafari) {
            mp4SampleDuration = Math.round((lastDTS - firstDTS) / (inputSamples.length - 1));
          }
    
          var nbNalu = 0,
              naluLen = 0;
          for (var _i = 0; _i < nbSamples; _i++) {
            // compute total/avc sample length and nb of NAL units
            var _sample = inputSamples[_i],
                units = _sample.units,
                nbUnits = units.length,
                sampleLen = 0;
            for (var j = 0; j < nbUnits; j++) {
              sampleLen += units[j].data.length;
            }
            naluLen += sampleLen;
            nbNalu += nbUnits;
            _sample.length = sampleLen;
    
            // normalize PTS/DTS
            if (isSafari) {
              // sample DTS is computed using a constant decoding offset (mp4SampleDuration) between samples
              _sample.dts = firstDTS + _i * mp4SampleDuration;
            } else {
              // ensure sample monotonic DTS
              _sample.dts = Math.max(ptsNormalize(_sample.dts - initDTS, nextAvcDts), firstDTS);
            }
            // we normalize PTS against nextAvcDts, we also substract initDTS (some streams don't start @ PTS O)
            // and we ensure that computed value is greater or equal than sample DTS
            _sample.pts = Math.max(ptsNormalize(_sample.pts - initDTS, nextAvcDts), _sample.dts);
          }
    
          /* concatenate the video data and construct the mdat in place
            (need 8 more bytes to fill length and mpdat type) */
          var mdatSize = naluLen + 4 * nbNalu + 8;
          try {
            mdat = new Uint8Array(mdatSize);
          } catch (err) {
            this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating video mdat ' + mdatSize });
            return;
          }
          var view = new DataView(mdat.buffer);
          view.setUint32(0, mdatSize);
          mdat.set(_mp4Generator2.default.types.mdat, 4);
    
          for (var _i2 = 0; _i2 < nbSamples; _i2++) {
            var avcSample = inputSamples[_i2],
                avcSampleUnits = avcSample.units,
                mp4SampleLength = 0,
                compositionTimeOffset = void 0;
            // convert NALU bitstream to MP4 format (prepend NALU with size field)
            for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
              var unit = avcSampleUnits[_j],
                  unitData = unit.data,
                  unitDataLen = unit.data.byteLength;
              view.setUint32(offset, unitDataLen);
              offset += 4;
              mdat.set(unitData, offset);
              offset += unitDataLen;
              mp4SampleLength += 4 + unitDataLen;
            }
    
            if (!isSafari) {
              // expected sample duration is the Decoding Timestamp diff of consecutive samples
              if (_i2 < nbSamples - 1) {
                mp4SampleDuration = inputSamples[_i2 + 1].dts - avcSample.dts;
              } else {
                var config = this.config,
                    lastFrameDuration = avcSample.dts - inputSamples[_i2 > 0 ? _i2 - 1 : _i2].dts;
                if (config.stretchShortVideoTrack) {
                  // In some cases, a segment's audio track duration may exceed the video track duration.
                  // Since we've already remuxed audio, and we know how long the audio track is, we look to
                  // see if the delta to the next segment is longer than the minimum of maxBufferHole and
                  // maxSeekHole. If so, playback would potentially get stuck, so we artificially inflate
                  // the duration of the last frame to minimize any potential gap between segments.
                  var maxBufferHole = config.maxBufferHole,
                      maxSeekHole = config.maxSeekHole,
                      gapTolerance = Math.floor(Math.min(maxBufferHole, maxSeekHole) * timeScale),
                      deltaToFrameEnd = (audioTrackLength ? firstPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
                  if (deltaToFrameEnd > gapTolerance) {
                    // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video
                    // frame overlap. maxBufferHole/maxSeekHole should be >> lastFrameDuration anyway.
                    mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                    if (mp4SampleDuration < 0) {
                      mp4SampleDuration = lastFrameDuration;
                    }
                    _logger.logger.log('It is approximately ' + deltaToFrameEnd / 90 + ' ms to the next segment; using duration ' + mp4SampleDuration / 90 + ' ms for the last video frame.');
                  } else {
                    mp4SampleDuration = lastFrameDuration;
                  }
                } else {
                  mp4SampleDuration = lastFrameDuration;
                }
              }
              compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
            } else {
              compositionTimeOffset = Math.max(0, mp4SampleDuration * Math.round((avcSample.pts - avcSample.dts) / mp4SampleDuration));
            }
    
            //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${avcSample.pts}/${avcSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(avcSample.pts/4294967296).toFixed(3)}');
            outputSamples.push({
              size: mp4SampleLength,
              // constant duration
              duration: mp4SampleDuration,
              cts: compositionTimeOffset,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: avcSample.key ? 2 : 1,
                isNonSync: avcSample.key ? 0 : 1
              }
            });
          }
          // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)
          this.nextAvcDts = lastDTS + mp4SampleDuration;
          var dropped = track.dropped;
          track.len = 0;
          track.nbNalu = 0;
          track.dropped = 0;
          if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
            var flags = outputSamples[0].flags;
            // chrome workaround, mark first sample as being a Random Access Point to avoid sourcebuffer append issue
            // https://code.google.com/p/chromium/issues/detail?id=229412
            flags.dependsOn = 2;
            flags.isNonSync = 0;
          }
          track.samples = outputSamples;
          moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS, track);
          track.samples = [];
    
          var data = {
            data1: moof,
            data2: mdat,
            startPTS: firstPTS / timeScale,
            endPTS: (lastPTS + mp4SampleDuration) / timeScale,
            startDTS: firstDTS / timeScale,
            endDTS: this.nextAvcDts / timeScale,
            type: 'video',
            nb: outputSamples.length,
            dropped: dropped
          };
          this.observer.trigger(_events2.default.FRAG_PARSING_DATA, data);
          return data;
        }
      }, {
        key: 'remuxAudio',
        value: function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
          var inputTimeScale = track.inputTimeScale,
              mp4timeScale = track.timescale,
              scaleFactor = inputTimeScale / mp4timeScale,
              mp4SampleDuration = track.isAAC ? 1024 : 1152,
              inputSampleDuration = mp4SampleDuration * scaleFactor,
              ptsNormalize = this._PTSNormalize,
              initDTS = this._initDTS,
              rawMPEG = !track.isAAC && this.typeSupported.mpeg;
    
          var view,
              offset = rawMPEG ? 0 : 8,
              audioSample,
              mp4Sample,
              unit,
              mdat,
              moof,
              firstPTS,
              firstDTS,
              lastDTS,
              pts,
              dts,
              ptsnorm,
              dtsnorm,
              outputSamples = [],
              inputSamples = [],
              fillFrame,
              newStamp,
              nextAudioPts;
    
          track.samples.sort(function (a, b) {
            return a.pts - b.pts;
          });
          inputSamples = track.samples;
    
          // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),
          // for sake of clarity:
          // consecutive fragments are frags with
          //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR
          //  - less than 20 audio frames distance
          // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
          // this helps ensuring audio continuity
          // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame
    
          nextAudioPts = this.nextAudioPts;
          contiguous |= inputSamples.length && nextAudioPts && (accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - initDTS) < 20 * inputSampleDuration);
    
          if (!contiguous) {
            // if fragments are not contiguous, let's use timeOffset to compute next Audio PTS
            nextAudioPts = timeOffset * inputTimeScale;
          }
          // If the audio track is missing samples, the frames seem to get "left-shifted" within the
          // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.
          // In an effort to prevent this from happening, we inject frames here where there are gaps.
          // When possible, we inject a silent frame; when that's not possible, we duplicate the last
          // frame.
    
          // only inject/drop audio frames in case time offset is accurate
          if (accurateTimeOffset && track.isAAC) {
            for (var i = 0, nextPtsNorm = nextAudioPts; i < inputSamples.length;) {
              // First, let's see how far off this frame is from where we expect it to be
              var sample = inputSamples[i],
                  ptsNorm = ptsNormalize(sample.pts - initDTS, nextAudioPts),
                  delta = ptsNorm - nextPtsNorm;
    
              // If we're overlapping by more than a duration, drop this sample
              if (delta <= -inputSampleDuration) {
                _logger.logger.warn('Dropping 1 audio frame @ ' + (nextPtsNorm / inputTimeScale).toFixed(3) + 's due to ' + Math.abs(1000 * delta / inputTimeScale) + ' ms overlap.');
                inputSamples.splice(i, 1);
                track.len -= sample.unit.length;
                // Don't touch nextPtsNorm or i
              }
              // Otherwise, if we're more than a frame away from where we should be, insert missing frames
              // also only inject silent audio frames if currentTime !== 0 (nextPtsNorm !== 0)
              else if (delta >= inputSampleDuration && nextPtsNorm) {
                  var missing = Math.round(delta / inputSampleDuration);
                  _logger.logger.warn('Injecting ' + missing + ' audio frame @ ' + (nextPtsNorm / inputTimeScale).toFixed(3) + 's due to ' + 1000 * delta / inputTimeScale + ' ms gap.');
                  for (var j = 0; j < missing; j++) {
                    newStamp = nextPtsNorm + initDTS;
                    newStamp = Math.max(newStamp, initDTS);
                    fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                    if (!fillFrame) {
                      _logger.logger.log('Unable to get silent frame for given audio codec; duplicating last frame instead.');
                      fillFrame = sample.unit.subarray();
                    }
                    inputSamples.splice(i, 0, { unit: fillFrame, pts: newStamp, dts: newStamp });
                    track.len += fillFrame.length;
                    nextPtsNorm += inputSampleDuration;
                    i += 1;
                  }
    
                  // Adjust sample to next expected pts
                  sample.pts = sample.dts = nextPtsNorm + initDTS;
                  nextPtsNorm += inputSampleDuration;
                  i += 1;
                }
                // Otherwise, we're within half a frame duration, so just adjust pts
                else {
                    if (Math.abs(delta) > 0.1 * inputSampleDuration) {
                      //logger.log(`Invalid frame delta ${Math.round(ptsNorm - nextPtsNorm + inputSampleDuration)} at PTS ${Math.round(ptsNorm / 90)} (should be ${Math.round(inputSampleDuration)}).`);
                    }
                    nextPtsNorm += inputSampleDuration;
                    if (i === 0) {
                      sample.pts = sample.dts = initDTS + nextAudioPts;
                    } else {
                      sample.pts = sample.dts = inputSamples[i - 1].pts + inputSampleDuration;
                    }
                    i += 1;
                  }
            }
          }
    
          for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
            audioSample = inputSamples[_j2];
            unit = audioSample.unit;
            pts = audioSample.pts - initDTS;
            dts = audioSample.dts - initDTS;
            //logger.log(`Audio/PTS:${Math.round(pts/90)}`);
            // if not first sample
            if (lastDTS !== undefined) {
              ptsnorm = ptsNormalize(pts, lastDTS);
              dtsnorm = ptsNormalize(dts, lastDTS);
              mp4Sample.duration = Math.round((dtsnorm - lastDTS) / scaleFactor);
            } else {
              ptsnorm = ptsNormalize(pts, nextAudioPts);
              dtsnorm = ptsNormalize(dts, nextAudioPts);
              var _delta = Math.round(1000 * (ptsnorm - nextAudioPts) / inputTimeScale),
                  numMissingFrames = 0;
              // if fragment are contiguous, detect hole/overlapping between fragments
              // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)
              if (contiguous && track.isAAC) {
                // log delta
                if (_delta) {
                  if (_delta > 0) {
                    numMissingFrames = Math.round((ptsnorm - nextAudioPts) / inputSampleDuration);
                    _logger.logger.log(_delta + ' ms hole between AAC samples detected,filling it');
                    if (numMissingFrames > 0) {
                      fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                      if (!fillFrame) {
                        fillFrame = unit.subarray();
                      }
                      track.len += numMissingFrames * fillFrame.length;
                    }
                    // if we have frame overlap, overlapping for more than half a frame duraion
                  } else if (_delta < -12) {
                    // drop overlapping audio frames... browser will deal with it
                    _logger.logger.log('drop overlapping AAC sample, expected/parsed/delta:' + (nextAudioPts / inputTimeScale).toFixed(3) + 's/' + (ptsnorm / inputTimeScale).toFixed(3) + 's/' + -_delta + 'ms');
                    track.len -= unit.byteLength;
                    continue;
                  }
                  // set PTS/DTS to expected PTS/DTS
                  ptsnorm = dtsnorm = nextAudioPts;
                }
              }
              // remember first PTS of our audioSamples, ensure value is positive
              firstPTS = Math.max(0, ptsnorm);
              firstDTS = Math.max(0, dtsnorm);
              if (track.len > 0) {
                /* concatenate the audio data and construct the mdat in place
                  (need 8 more bytes to fill length and mdat type) */
    
                var mdatSize = rawMPEG ? track.len : track.len + 8;
                try {
                  mdat = new Uint8Array(mdatSize);
                } catch (err) {
                  this.observer.trigger(_events2.default.ERROR, { type: _errors.ErrorTypes.MUX_ERROR, details: _errors.ErrorDetails.REMUX_ALLOC_ERROR, fatal: false, bytes: mdatSize, reason: 'fail allocating audio mdat ' + mdatSize });
                  return;
                }
                if (!rawMPEG) {
                  view = new DataView(mdat.buffer);
                  view.setUint32(0, mdatSize);
                  mdat.set(_mp4Generator2.default.types.mdat, 4);
                }
              } else {
                // no audio samples
                return;
              }
              for (var _i3 = 0; _i3 < numMissingFrames; _i3++) {
                newStamp = ptsnorm - (numMissingFrames - _i3) * inputSampleDuration;
                fillFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                if (!fillFrame) {
                  _logger.logger.log('Unable to get silent frame for given audio codec; duplicating this frame instead.');
                  fillFrame = unit.subarray();
                }
                mdat.set(fillFrame, offset);
                offset += fillFrame.byteLength;
                mp4Sample = {
                  size: fillFrame.byteLength,
                  cts: 0,
                  duration: 1024,
                  flags: {
                    isLeading: 0,
                    isDependedOn: 0,
                    hasRedundancy: 0,
                    degradPrio: 0,
                    dependsOn: 1
                  }
                };
                outputSamples.push(mp4Sample);
              }
            }
            mdat.set(unit, offset);
            var unitLen = unit.byteLength;
            offset += unitLen;
            //console.log('PTS/DTS/initDTS/normPTS/normDTS/relative PTS : ${audioSample.pts}/${audioSample.dts}/${initDTS}/${ptsnorm}/${dtsnorm}/${(audioSample.pts/4294967296).toFixed(3)}');
            mp4Sample = {
              size: unitLen,
              cts: 0,
              duration: 0,
              flags: {
                isLeading: 0,
                isDependedOn: 0,
                hasRedundancy: 0,
                degradPrio: 0,
                dependsOn: 1
              }
            };
            outputSamples.push(mp4Sample);
            lastDTS = dtsnorm;
          }
          var lastSampleDuration = 0;
          var nbSamples = outputSamples.length;
          //set last sample duration as being identical to previous sample
          if (nbSamples >= 2) {
            lastSampleDuration = outputSamples[nbSamples - 2].duration;
            mp4Sample.duration = lastSampleDuration;
          }
          if (nbSamples) {
            // next audio sample PTS should be equal to last sample PTS + duration
            this.nextAudioPts = ptsnorm + scaleFactor * lastSampleDuration;
            //logger.log('Audio/PTS/PTSend:' + audioSample.pts.toFixed(0) + '/' + this.nextAacDts.toFixed(0));
            track.len = 0;
            track.samples = outputSamples;
            if (rawMPEG) {
              moof = new Uint8Array();
            } else {
              moof = _mp4Generator2.default.moof(track.sequenceNumber++, firstDTS / scaleFactor, track);
            }
            track.samples = [];
            var audioData = {
              data1: moof,
              data2: mdat,
              startPTS: firstPTS / inputTimeScale,
              endPTS: this.nextAudioPts / inputTimeScale,
              startDTS: firstDTS / inputTimeScale,
              endDTS: (dtsnorm + scaleFactor * lastSampleDuration) / inputTimeScale,
              type: 'audio',
              nb: nbSamples
            };
            this.observer.trigger(_events2.default.FRAG_PARSING_DATA, audioData);
            return audioData;
          }
          return null;
        }
      }, {
        key: 'remuxEmptyAudio',
        value: function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
          var inputTimeScale = track.inputTimeScale,
              mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale,
              scaleFactor = inputTimeScale / mp4timeScale,
              nextAudioPts = this.nextAudioPts,
    
    
          // sync with video's timestamp
          startDTS = (nextAudioPts !== undefined ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS,
              endDTS = videoData.endDTS * inputTimeScale + this._initDTS,
    
          // one sample's duration value
          sampleDuration = 1024,
              frameDuration = scaleFactor * sampleDuration,
    
    
          // samples count of this segment's duration
          nbSamples = Math.ceil((endDTS - startDTS) / frameDuration),
    
    
          // silent frame
          silentFrame = _aac2.default.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
    
          _logger.logger.warn('remux empty Audio');
          // Can't remux if we can't generate a silent frame...
          if (!silentFrame) {
            _logger.logger.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!');
            return;
          }
    
          var samples = [];
          for (var i = 0; i < nbSamples; i++) {
            var stamp = startDTS + i * frameDuration;
            samples.push({ unit: silentFrame, pts: stamp, dts: stamp });
            track.len += silentFrame.length;
          }
          track.samples = samples;
    
          this.remuxAudio(track, timeOffset, contiguous);
        }
      }, {
        key: 'remuxID3',
        value: function remuxID3(track, timeOffset) {
          var length = track.samples.length,
              sample;
          var inputTimeScale = track.inputTimeScale;
          var initPTS = this._initPTS;
          var initDTS = this._initDTS;
          // consume samples
          if (length) {
            for (var index = 0; index < length; index++) {
              sample = track.samples[index];
              // setting id3 pts, dts to relative time
              // using this._initPTS and this._initDTS to calculate relative time
              sample.pts = (sample.pts - initPTS) / inputTimeScale;
              sample.dts = (sample.dts - initDTS) / inputTimeScale;
            }
            this.observer.trigger(_events2.default.FRAG_PARSING_METADATA, {
              samples: track.samples
            });
          }
    
          track.samples = [];
          timeOffset = timeOffset;
        }
      }, {
        key: 'remuxText',
        value: function remuxText(track, timeOffset) {
          track.samples.sort(function (a, b) {
            return a.pts - b.pts;
          });
    
          var length = track.samples.length,
              sample;
          var inputTimeScale = track.inputTimeScale;
          var initPTS = this._initPTS;
          // consume samples
          if (length) {
            for (var index = 0; index < length; index++) {
              sample = track.samples[index];
              // setting text pts, dts to relative time
              // using this._initPTS and this._initDTS to calculate relative time
              sample.pts = (sample.pts - initPTS) / inputTimeScale;
            }
            this.observer.trigger(_events2.default.FRAG_PARSING_USERDATA, {
              samples: track.samples
            });
          }
    
          track.samples = [];
          timeOffset = timeOffset;
        }
      }, {
        key: '_PTSNormalize',
        value: function _PTSNormalize(value, reference) {
          var offset;
          if (reference === undefined) {
            return value;
          }
          if (reference < value) {
            // - 2^33
            offset = -8589934592;
          } else {
            // + 2^33
            offset = 8589934592;
          }
          /* PTS is 33bit (from 0 to 2^33 -1)
            if diff between value and reference is bigger than half of the amplitude (2^32) then it means that
            PTS looping occured. fill the gap */
          while (Math.abs(value - reference) > 4294967296) {
            value += offset;
          }
          return value;
        }
      }]);
    
      return MP4Remuxer;
    }();
    
    exports.default = MP4Remuxer;
    
    },{"31":31,"33":33,"34":34,"42":42,"51":51}],44:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * passthrough remuxer
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         */
    
    
    var _events = _dereq_(33);
    
    var _events2 = _interopRequireDefault(_events);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var PassThroughRemuxer = function () {
      function PassThroughRemuxer(observer) {
        _classCallCheck(this, PassThroughRemuxer);
    
        this.observer = observer;
      }
    
      _createClass(PassThroughRemuxer, [{
        key: 'destroy',
        value: function destroy() {}
      }, {
        key: 'resetTimeStamp',
        value: function resetTimeStamp() {}
      }, {
        key: 'resetInitSegment',
        value: function resetInitSegment() {}
      }, {
        key: 'remux',
        value: function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
          var observer = this.observer;
          var streamType = '';
          if (audioTrack) {
            streamType += 'audio';
          }
          if (videoTrack) {
            streamType += 'video';
          }
          observer.trigger(_events2.default.FRAG_PARSING_DATA, {
            data1: rawData,
            startPTS: timeOffset,
            startDTS: timeOffset,
            type: streamType,
            nb: 1,
            dropped: 0
          });
          //notify end of parsing
          observer.trigger(_events2.default.FRAG_PARSED);
        }
      }]);
    
      return PassThroughRemuxer;
    }();
    
    exports.default = PassThroughRemuxer;
    
    },{"33":33}],45:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
    var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;
    
    // adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js
    
    var AttrList = function () {
      function AttrList(attrs) {
        _classCallCheck(this, AttrList);
    
        if (typeof attrs === 'string') {
          attrs = AttrList.parseAttrList(attrs);
        }
        for (var attr in attrs) {
          if (attrs.hasOwnProperty(attr)) {
            this[attr] = attrs[attr];
          }
        }
      }
    
      _createClass(AttrList, [{
        key: 'decimalInteger',
        value: function decimalInteger(attrName) {
          var intValue = parseInt(this[attrName], 10);
          if (intValue > Number.MAX_SAFE_INTEGER) {
            return Infinity;
          }
          return intValue;
        }
      }, {
        key: 'hexadecimalInteger',
        value: function hexadecimalInteger(attrName) {
          if (this[attrName]) {
            var stringValue = (this[attrName] || '0x').slice(2);
            stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;
    
            var value = new Uint8Array(stringValue.length / 2);
            for (var i = 0; i < stringValue.length / 2; i++) {
              value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
            }
            return value;
          } else {
            return null;
          }
        }
      }, {
        key: 'hexadecimalIntegerAsNumber',
        value: function hexadecimalIntegerAsNumber(attrName) {
          var intValue = parseInt(this[attrName], 16);
          if (intValue > Number.MAX_SAFE_INTEGER) {
            return Infinity;
          }
          return intValue;
        }
      }, {
        key: 'decimalFloatingPoint',
        value: function decimalFloatingPoint(attrName) {
          return parseFloat(this[attrName]);
        }
      }, {
        key: 'enumeratedString',
        value: function enumeratedString(attrName) {
          return this[attrName];
        }
      }, {
        key: 'decimalResolution',
        value: function decimalResolution(attrName) {
          var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
          if (res === null) {
            return undefined;
          }
          return {
            width: parseInt(res[1], 10),
            height: parseInt(res[2], 10)
          };
        }
      }], [{
        key: 'parseAttrList',
        value: function parseAttrList(input) {
          var match,
              attrs = {};
          ATTR_LIST_REGEX.lastIndex = 0;
          while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
            var value = match[2],
                quote = '"';
    
            if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
              value = value.slice(1, -1);
            }
            attrs[match[1]] = value;
          }
          return attrs;
        }
      }]);
    
      return AttrList;
    }();
    
    exports.default = AttrList;
    
    },{}],46:[function(_dereq_,module,exports){
    "use strict";
    
    var BinarySearch = {
        /**
         * Searches for an item in an array which matches a certain condition.
         * This requires the condition to only match one item in the array,
         * and for the array to be ordered.
         *
         * @param {Array} list The array to search.
         * @param {Function} comparisonFunction
         *      Called and provided a candidate item as the first argument.
         *      Should return:
         *          > -1 if the item should be located at a lower index than the provided item.
         *          > 1 if the item should be located at a higher index than the provided item.
         *          > 0 if the item is the item you're looking for.
         *
         * @return {*} The object if it is found or null otherwise.
         */
        search: function search(list, comparisonFunction) {
            var minIndex = 0;
            var maxIndex = list.length - 1;
            var currentIndex = null;
            var currentElement = null;
    
            while (minIndex <= maxIndex) {
                currentIndex = (minIndex + maxIndex) / 2 | 0;
                currentElement = list[currentIndex];
    
                var comparisonResult = comparisonFunction(currentElement);
                if (comparisonResult > 0) {
                    minIndex = currentIndex + 1;
                } else if (comparisonResult < 0) {
                    maxIndex = currentIndex - 1;
                } else {
                    return currentElement;
                }
            }
    
            return null;
        }
    };
    
    module.exports = BinarySearch;
    
    },{}],47:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /**
     *
     * This code was ported from the dash.js project at:
     *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js
     *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2
     *
     * The original copyright appears below:
     *
     * The copyright in this software is being made available under the BSD License,
     * included below. This software may be subject to other third party and contributor
     * rights, including patent rights, and no such rights are granted under this license.
     *
     * Copyright (c) 2015-2016, DASH Industry Forum.
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without modification,
     * are permitted provided that the following conditions are met:
     *  1. Redistributions of source code must retain the above copyright notice, this
     *  list of conditions and the following disclaimer.
     *  * Redistributions in binary form must reproduce the above copyright notice,
     *  this list of conditions and the following disclaimer in the documentation and/or
     *  other materials provided with the distribution.
     *  2. Neither the name of Dash Industry Forum nor the names of its
     *  contributors may be used to endorse or promote products derived from this software
     *  without specific prior written permission.
     *
     *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY
     *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
     *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
     *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
     *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
     *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     *  POSSIBILITY OF SUCH DAMAGE.
     */
    /**
     *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes
     */
    
    var specialCea608CharsCodes = {
        0x2a: 0xe1, // lowercase a, acute accent
        0x5c: 0xe9, // lowercase e, acute accent
        0x5e: 0xed, // lowercase i, acute accent
        0x5f: 0xf3, // lowercase o, acute accent
        0x60: 0xfa, // lowercase u, acute accent
        0x7b: 0xe7, // lowercase c with cedilla
        0x7c: 0xf7, // division symbol
        0x7d: 0xd1, // uppercase N tilde
        0x7e: 0xf1, // lowercase n tilde
        0x7f: 0x2588, // Full block
        // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
        // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
        // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
        0x80: 0xae, // Registered symbol (R)
        0x81: 0xb0, // degree sign
        0x82: 0xbd, // 1/2 symbol
        0x83: 0xbf, // Inverted (open) question mark
        0x84: 0x2122, // Trademark symbol (TM)
        0x85: 0xa2, // Cents symbol
        0x86: 0xa3, // Pounds sterling
        0x87: 0x266a, // Music 8'th note
        0x88: 0xe0, // lowercase a, grave accent
        0x89: 0x20, // transparent space (regular)
        0x8a: 0xe8, // lowercase e, grave accent
        0x8b: 0xe2, // lowercase a, circumflex accent
        0x8c: 0xea, // lowercase e, circumflex accent
        0x8d: 0xee, // lowercase i, circumflex accent
        0x8e: 0xf4, // lowercase o, circumflex accent
        0x8f: 0xfb, // lowercase u, circumflex accent
        // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
        // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
        0x90: 0xc1, // capital letter A with acute
        0x91: 0xc9, // capital letter E with acute
        0x92: 0xd3, // capital letter O with acute
        0x93: 0xda, // capital letter U with acute
        0x94: 0xdc, // capital letter U with diaresis
        0x95: 0xfc, // lowercase letter U with diaeresis
        0x96: 0x2018, // opening single quote
        0x97: 0xa1, // inverted exclamation mark
        0x98: 0x2a, // asterisk
        0x99: 0x2019, // closing single quote
        0x9a: 0x2501, // box drawings heavy horizontal
        0x9b: 0xa9, // copyright sign
        0x9c: 0x2120, // Service mark
        0x9d: 0x2022, // (round) bullet
        0x9e: 0x201c, // Left double quotation mark
        0x9f: 0x201d, // Right double quotation mark
        0xa0: 0xc0, // uppercase A, grave accent
        0xa1: 0xc2, // uppercase A, circumflex
        0xa2: 0xc7, // uppercase C with cedilla
        0xa3: 0xc8, // uppercase E, grave accent
        0xa4: 0xca, // uppercase E, circumflex
        0xa5: 0xcb, // capital letter E with diaresis
        0xa6: 0xeb, // lowercase letter e with diaresis
        0xa7: 0xce, // uppercase I, circumflex
        0xa8: 0xcf, // uppercase I, with diaresis
        0xa9: 0xef, // lowercase i, with diaresis
        0xaa: 0xd4, // uppercase O, circumflex
        0xab: 0xd9, // uppercase U, grave accent
        0xac: 0xf9, // lowercase u, grave accent
        0xad: 0xdb, // uppercase U, circumflex
        0xae: 0xab, // left-pointing double angle quotation mark
        0xaf: 0xbb, // right-pointing double angle quotation mark
        // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
        // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
        0xb0: 0xc3, // Uppercase A, tilde
        0xb1: 0xe3, // Lowercase a, tilde
        0xb2: 0xcd, // Uppercase I, acute accent
        0xb3: 0xcc, // Uppercase I, grave accent
        0xb4: 0xec, // Lowercase i, grave accent
        0xb5: 0xd2, // Uppercase O, grave accent
        0xb6: 0xf2, // Lowercase o, grave accent
        0xb7: 0xd5, // Uppercase O, tilde
        0xb8: 0xf5, // Lowercase o, tilde
        0xb9: 0x7b, // Open curly brace
        0xba: 0x7d, // Closing curly brace
        0xbb: 0x5c, // Backslash
        0xbc: 0x5e, // Caret
        0xbd: 0x5f, // Underscore
        0xbe: 0x7c, // Pipe (vertical line)
        0xbf: 0x223c, // Tilde operator
        0xc0: 0xc4, // Uppercase A, umlaut
        0xc1: 0xe4, // Lowercase A, umlaut
        0xc2: 0xd6, // Uppercase O, umlaut
        0xc3: 0xf6, // Lowercase o, umlaut
        0xc4: 0xdf, // Esszett (sharp S)
        0xc5: 0xa5, // Yen symbol
        0xc6: 0xa4, // Generic currency sign
        0xc7: 0x2503, // Box drawings heavy vertical
        0xc8: 0xc5, // Uppercase A, ring
        0xc9: 0xe5, // Lowercase A, ring
        0xca: 0xd8, // Uppercase O, stroke
        0xcb: 0xf8, // Lowercase o, strok
        0xcc: 0x250f, // Box drawings heavy down and right
        0xcd: 0x2513, // Box drawings heavy down and left
        0xce: 0x2517, // Box drawings heavy up and right
        0xcf: 0x251b // Box drawings heavy up and left
    };
    
    /**
     * Utils
     */
    var getCharForByte = function getCharForByte(byte) {
        var charCode = byte;
        if (specialCea608CharsCodes.hasOwnProperty(byte)) {
            charCode = specialCea608CharsCodes[byte];
        }
        return String.fromCharCode(charCode);
    };
    
    var NR_ROWS = 15,
        NR_COLS = 100;
    // Tables to look up row from PAC data
    var rowsLowCh1 = { 0x11: 1, 0x12: 3, 0x15: 5, 0x16: 7, 0x17: 9, 0x10: 11, 0x13: 12, 0x14: 14 };
    var rowsHighCh1 = { 0x11: 2, 0x12: 4, 0x15: 6, 0x16: 8, 0x17: 10, 0x13: 13, 0x14: 15 };
    var rowsLowCh2 = { 0x19: 1, 0x1A: 3, 0x1D: 5, 0x1E: 7, 0x1F: 9, 0x18: 11, 0x1B: 12, 0x1C: 14 };
    var rowsHighCh2 = { 0x19: 2, 0x1A: 4, 0x1D: 6, 0x1E: 8, 0x1F: 10, 0x1B: 13, 0x1C: 15 };
    
    var backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];
    
    /**
     * Simple logger class to be able to write with time-stamps and filter on level.
     */
    var logger = {
        verboseFilter: { 'DATA': 3, 'DEBUG': 3, 'INFO': 2, 'WARNING': 2, 'TEXT': 1, 'ERROR': 0 },
        time: null,
        verboseLevel: 0, // Only write errors
        setTime: function setTime(newTime) {
            this.time = newTime;
        },
        log: function log(severity, msg) {
            var minLevel = this.verboseFilter[severity];
            if (this.verboseLevel >= minLevel) {
                console.log(this.time + ' [' + severity + '] ' + msg);
            }
        }
    };
    
    var numArrayToHexArray = function numArrayToHexArray(numArray) {
        var hexArray = [];
        for (var j = 0; j < numArray.length; j++) {
            hexArray.push(numArray[j].toString(16));
        }
        return hexArray;
    };
    
    var PenState = function () {
        function PenState(foreground, underline, italics, background, flash) {
            _classCallCheck(this, PenState);
    
            this.foreground = foreground || 'white';
            this.underline = underline || false;
            this.italics = italics || false;
            this.background = background || 'black';
            this.flash = flash || false;
        }
    
        _createClass(PenState, [{
            key: 'reset',
            value: function reset() {
                this.foreground = 'white';
                this.underline = false;
                this.italics = false;
                this.background = 'black';
                this.flash = false;
            }
        }, {
            key: 'setStyles',
            value: function setStyles(styles) {
                var attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];
                for (var i = 0; i < attribs.length; i++) {
                    var style = attribs[i];
                    if (styles.hasOwnProperty(style)) {
                        this[style] = styles[style];
                    }
                }
            }
        }, {
            key: 'isDefault',
            value: function isDefault() {
                return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;
            }
        }, {
            key: 'equals',
            value: function equals(other) {
                return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
            }
        }, {
            key: 'copy',
            value: function copy(newPenState) {
                this.foreground = newPenState.foreground;
                this.underline = newPenState.underline;
                this.italics = newPenState.italics;
                this.background = newPenState.background;
                this.flash = newPenState.flash;
            }
        }, {
            key: 'toString',
            value: function toString() {
                return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;
            }
        }]);
    
        return PenState;
    }();
    
    /**
     * Unicode character with styling and background.
     * @constructor
     */
    
    
    var StyledUnicodeChar = function () {
        function StyledUnicodeChar(uchar, foreground, underline, italics, background, flash) {
            _classCallCheck(this, StyledUnicodeChar);
    
            this.uchar = uchar || ' '; // unicode character
            this.penState = new PenState(foreground, underline, italics, background, flash);
        }
    
        _createClass(StyledUnicodeChar, [{
            key: 'reset',
            value: function reset() {
                this.uchar = ' ';
                this.penState.reset();
            }
        }, {
            key: 'setChar',
            value: function setChar(uchar, newPenState) {
                this.uchar = uchar;
                this.penState.copy(newPenState);
            }
        }, {
            key: 'setPenState',
            value: function setPenState(newPenState) {
                this.penState.copy(newPenState);
            }
        }, {
            key: 'equals',
            value: function equals(other) {
                return this.uchar === other.uchar && this.penState.equals(other.penState);
            }
        }, {
            key: 'copy',
            value: function copy(newChar) {
                this.uchar = newChar.uchar;
                this.penState.copy(newChar.penState);
            }
        }, {
            key: 'isEmpty',
            value: function isEmpty() {
                return this.uchar === ' ' && this.penState.isDefault();
            }
        }]);
    
        return StyledUnicodeChar;
    }();
    
    /**
     * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.
     * @constructor
     */
    
    
    var Row = function () {
        function Row() {
            _classCallCheck(this, Row);
    
            this.chars = [];
            for (var i = 0; i < NR_COLS; i++) {
                this.chars.push(new StyledUnicodeChar());
            }
            this.pos = 0;
            this.currPenState = new PenState();
        }
    
        _createClass(Row, [{
            key: 'equals',
            value: function equals(other) {
                var equal = true;
                for (var i = 0; i < NR_COLS; i++) {
                    if (!this.chars[i].equals(other.chars[i])) {
                        equal = false;
                        break;
                    }
                }
                return equal;
            }
        }, {
            key: 'copy',
            value: function copy(other) {
                for (var i = 0; i < NR_COLS; i++) {
                    this.chars[i].copy(other.chars[i]);
                }
            }
        }, {
            key: 'isEmpty',
            value: function isEmpty() {
                var empty = true;
                for (var i = 0; i < NR_COLS; i++) {
                    if (!this.chars[i].isEmpty()) {
                        empty = false;
                        break;
                    }
                }
                return empty;
            }
    
            /**
             *  Set the cursor to a valid column.
             */
    
        }, {
            key: 'setCursor',
            value: function setCursor(absPos) {
                if (this.pos !== absPos) {
                    this.pos = absPos;
                }
                if (this.pos < 0) {
                    logger.log('ERROR', 'Negative cursor position ' + this.pos);
                    this.pos = 0;
                } else if (this.pos > NR_COLS) {
                    logger.log('ERROR', 'Too large cursor position ' + this.pos);
                    this.pos = NR_COLS;
                }
            }
    
            /**
             * Move the cursor relative to current position.
             */
    
        }, {
            key: 'moveCursor',
            value: function moveCursor(relPos) {
                var newPos = this.pos + relPos;
                if (relPos > 1) {
                    for (var i = this.pos + 1; i < newPos + 1; i++) {
                        this.chars[i].setPenState(this.currPenState);
                    }
                }
                this.setCursor(newPos);
            }
    
            /**
             * Backspace, move one step back and clear character.
             */
    
        }, {
            key: 'backSpace',
            value: function backSpace() {
                this.moveCursor(-1);
                this.chars[this.pos].setChar(' ', this.currPenState);
            }
        }, {
            key: 'insertChar',
            value: function insertChar(byte) {
                if (byte >= 0x90) {
                    //Extended char
                    this.backSpace();
                }
                var char = getCharForByte(byte);
                if (this.pos >= NR_COLS) {
                    logger.log('ERROR', 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');
                    return;
                }
                this.chars[this.pos].setChar(char, this.currPenState);
                this.moveCursor(1);
            }
        }, {
            key: 'clearFromPos',
            value: function clearFromPos(startPos) {
                var i;
                for (i = startPos; i < NR_COLS; i++) {
                    this.chars[i].reset();
                }
            }
        }, {
            key: 'clear',
            value: function clear() {
                this.clearFromPos(0);
                this.pos = 0;
                this.currPenState.reset();
            }
        }, {
            key: 'clearToEndOfRow',
            value: function clearToEndOfRow() {
                this.clearFromPos(this.pos);
            }
        }, {
            key: 'getTextString',
            value: function getTextString() {
                var chars = [];
                var empty = true;
                for (var i = 0; i < NR_COLS; i++) {
                    var char = this.chars[i].uchar;
                    if (char !== ' ') {
                        empty = false;
                    }
                    chars.push(char);
                }
                if (empty) {
                    return '';
                } else {
                    return chars.join('');
                }
            }
        }, {
            key: 'setPenStyles',
            value: function setPenStyles(styles) {
                this.currPenState.setStyles(styles);
                var currChar = this.chars[this.pos];
                currChar.setPenState(this.currPenState);
            }
        }]);
    
        return Row;
    }();
    
    /**
     * Keep a CEA-608 screen of 32x15 styled characters
     * @constructor
    */
    
    
    var CaptionScreen = function () {
        function CaptionScreen() {
            _classCallCheck(this, CaptionScreen);
    
            this.rows = [];
            for (var i = 0; i < NR_ROWS; i++) {
                this.rows.push(new Row()); // Note that we use zero-based numbering (0-14)
            }
            this.currRow = NR_ROWS - 1;
            this.nrRollUpRows = null;
            this.reset();
        }
    
        _createClass(CaptionScreen, [{
            key: 'reset',
            value: function reset() {
                for (var i = 0; i < NR_ROWS; i++) {
                    this.rows[i].clear();
                }
                this.currRow = NR_ROWS - 1;
            }
        }, {
            key: 'equals',
            value: function equals(other) {
                var equal = true;
                for (var i = 0; i < NR_ROWS; i++) {
                    if (!this.rows[i].equals(other.rows[i])) {
                        equal = false;
                        break;
                    }
                }
                return equal;
            }
        }, {
            key: 'copy',
            value: function copy(other) {
                for (var i = 0; i < NR_ROWS; i++) {
                    this.rows[i].copy(other.rows[i]);
                }
            }
        }, {
            key: 'isEmpty',
            value: function isEmpty() {
                var empty = true;
                for (var i = 0; i < NR_ROWS; i++) {
                    if (!this.rows[i].isEmpty()) {
                        empty = false;
                        break;
                    }
                }
                return empty;
            }
        }, {
            key: 'backSpace',
            value: function backSpace() {
                var row = this.rows[this.currRow];
                row.backSpace();
            }
        }, {
            key: 'clearToEndOfRow',
            value: function clearToEndOfRow() {
                var row = this.rows[this.currRow];
                row.clearToEndOfRow();
            }
    
            /**
             * Insert a character (without styling) in the current row.
             */
    
        }, {
            key: 'insertChar',
            value: function insertChar(char) {
                var row = this.rows[this.currRow];
                row.insertChar(char);
            }
        }, {
            key: 'setPen',
            value: function setPen(styles) {
                var row = this.rows[this.currRow];
                row.setPenStyles(styles);
            }
        }, {
            key: 'moveCursor',
            value: function moveCursor(relPos) {
                var row = this.rows[this.currRow];
                row.moveCursor(relPos);
            }
        }, {
            key: 'setCursor',
            value: function setCursor(absPos) {
                logger.log('INFO', 'setCursor: ' + absPos);
                var row = this.rows[this.currRow];
                row.setCursor(absPos);
            }
        }, {
            key: 'setPAC',
            value: function setPAC(pacData) {
                logger.log('INFO', 'pacData = ' + JSON.stringify(pacData));
                var newRow = pacData.row - 1;
                if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
                    newRow = this.nrRollUpRows - 1;
                }
    
                //Make sure this only affects Roll-up Captions by checking this.nrRollUpRows
                if (this.nrRollUpRows && this.currRow !== newRow) {
                    //clear all rows first
                    for (var i = 0; i < NR_ROWS; i++) {
                        this.rows[i].clear();
                    }
    
                    //Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location
                    //topRowIndex - the start of rows to copy (inclusive index)
                    var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                    //We only copy if the last position was already shown.
                    //We use the cueStartTime value to check this.
                    var lastOutputScreen = this.lastOutputScreen;
                    if (lastOutputScreen) {
                        var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
                        if (prevLineTime && prevLineTime < logger.time) {
                            for (var _i = 0; _i < this.nrRollUpRows; _i++) {
                                this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
                            }
                        }
                    }
                }
    
                this.currRow = newRow;
                var row = this.rows[this.currRow];
                if (pacData.indent !== null) {
                    var indent = pacData.indent;
                    var prevPos = Math.max(indent - 1, 0);
                    row.setCursor(pacData.indent);
                    pacData.color = row.chars[prevPos].penState.foreground;
                }
                var styles = { foreground: pacData.color, underline: pacData.underline, italics: pacData.italics, background: 'black', flash: false };
                this.setPen(styles);
            }
    
            /**
             * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).
             */
    
        }, {
            key: 'setBkgData',
            value: function setBkgData(bkgData) {
    
                logger.log('INFO', 'bkgData = ' + JSON.stringify(bkgData));
                this.backSpace();
                this.setPen(bkgData);
                this.insertChar(0x20); //Space
            }
        }, {
            key: 'setRollUpRows',
            value: function setRollUpRows(nrRows) {
                this.nrRollUpRows = nrRows;
            }
        }, {
            key: 'rollUp',
            value: function rollUp() {
                if (this.nrRollUpRows === null) {
                    logger.log('DEBUG', 'roll_up but nrRollUpRows not set yet');
                    return; //Not properly setup
                }
                logger.log('TEXT', this.getDisplayText());
                var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                var topRow = this.rows.splice(topRowIndex, 1)[0];
                topRow.clear();
                this.rows.splice(this.currRow, 0, topRow);
                logger.log('INFO', 'Rolling up');
                //logger.log('TEXT', this.get_display_text())
            }
    
            /**
             * Get all non-empty rows with as unicode text.
             */
    
        }, {
            key: 'getDisplayText',
            value: function getDisplayText(asOneRow) {
                asOneRow = asOneRow || false;
                var displayText = [];
                var text = '';
                var rowNr = -1;
                for (var i = 0; i < NR_ROWS; i++) {
                    var rowText = this.rows[i].getTextString();
                    if (rowText) {
                        rowNr = i + 1;
                        if (asOneRow) {
                            displayText.push('Row ' + rowNr + ': \'' + rowText + '\'');
                        } else {
                            displayText.push(rowText.trim());
                        }
                    }
                }
                if (displayText.length > 0) {
                    if (asOneRow) {
                        text = '[' + displayText.join(' | ') + ']';
                    } else {
                        text = displayText.join('\n');
                    }
                }
                return text;
            }
        }, {
            key: 'getTextAndFormat',
            value: function getTextAndFormat() {
                return this.rows;
            }
        }]);
    
        return CaptionScreen;
    }();
    
    //var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];
    
    var Cea608Channel = function () {
        function Cea608Channel(channelNumber, outputFilter) {
            _classCallCheck(this, Cea608Channel);
    
            this.chNr = channelNumber;
            this.outputFilter = outputFilter;
            this.mode = null;
            this.verbose = 0;
            this.displayedMemory = new CaptionScreen();
            this.nonDisplayedMemory = new CaptionScreen();
            this.lastOutputScreen = new CaptionScreen();
            this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
            this.writeScreen = this.displayedMemory;
            this.mode = null;
            this.cueStartTime = null; // Keeps track of where a cue started.
        }
    
        _createClass(Cea608Channel, [{
            key: 'reset',
            value: function reset() {
                this.mode = null;
                this.displayedMemory.reset();
                this.nonDisplayedMemory.reset();
                this.lastOutputScreen.reset();
                this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
                this.writeScreen = this.displayedMemory;
                this.mode = null;
                this.cueStartTime = null;
                this.lastCueEndTime = null;
            }
        }, {
            key: 'getHandler',
            value: function getHandler() {
                return this.outputFilter;
            }
        }, {
            key: 'setHandler',
            value: function setHandler(newHandler) {
                this.outputFilter = newHandler;
            }
        }, {
            key: 'setPAC',
            value: function setPAC(pacData) {
                this.writeScreen.setPAC(pacData);
            }
        }, {
            key: 'setBkgData',
            value: function setBkgData(bkgData) {
                this.writeScreen.setBkgData(bkgData);
            }
        }, {
            key: 'setMode',
            value: function setMode(newMode) {
                if (newMode === this.mode) {
                    return;
                }
                this.mode = newMode;
                logger.log('INFO', 'MODE=' + newMode);
                if (this.mode === 'MODE_POP-ON') {
                    this.writeScreen = this.nonDisplayedMemory;
                } else {
                    this.writeScreen = this.displayedMemory;
                    this.writeScreen.reset();
                }
                if (this.mode !== 'MODE_ROLL-UP') {
                    this.displayedMemory.nrRollUpRows = null;
                    this.nonDisplayedMemory.nrRollUpRows = null;
                }
                this.mode = newMode;
            }
        }, {
            key: 'insertChars',
            value: function insertChars(chars) {
                for (var i = 0; i < chars.length; i++) {
                    this.writeScreen.insertChar(chars[i]);
                }
                var screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';
                logger.log('INFO', screen + ': ' + this.writeScreen.getDisplayText(true));
                if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {
                    logger.log('TEXT', 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));
                    this.outputDataUpdate();
                }
            }
        }, {
            key: 'ccRCL',
            value: function ccRCL() {
                // Resume Caption Loading (switch mode to Pop On)
                logger.log('INFO', 'RCL - Resume Caption Loading');
                this.setMode('MODE_POP-ON');
            }
        }, {
            key: 'ccBS',
            value: function ccBS() {
                // BackSpace
                logger.log('INFO', 'BS - BackSpace');
                if (this.mode === 'MODE_TEXT') {
                    return;
                }
                this.writeScreen.backSpace();
                if (this.writeScreen === this.displayedMemory) {
                    this.outputDataUpdate();
                }
            }
        }, {
            key: 'ccAOF',
            value: function ccAOF() {
                // Reserved (formerly Alarm Off)
                return;
            }
        }, {
            key: 'ccAON',
            value: function ccAON() {
                // Reserved (formerly Alarm On)
                return;
            }
        }, {
            key: 'ccDER',
            value: function ccDER() {
                // Delete to End of Row
                logger.log('INFO', 'DER- Delete to End of Row');
                this.writeScreen.clearToEndOfRow();
                this.outputDataUpdate();
            }
        }, {
            key: 'ccRU',
            value: function ccRU(nrRows) {
                //Roll-Up Captions-2,3,or 4 Rows
                logger.log('INFO', 'RU(' + nrRows + ') - Roll Up');
                this.writeScreen = this.displayedMemory;
                this.setMode('MODE_ROLL-UP');
                this.writeScreen.setRollUpRows(nrRows);
            }
        }, {
            key: 'ccFON',
            value: function ccFON() {
                //Flash On
                logger.log('INFO', 'FON - Flash On');
                this.writeScreen.setPen({ flash: true });
            }
        }, {
            key: 'ccRDC',
            value: function ccRDC() {
                // Resume Direct Captioning (switch mode to PaintOn)
                logger.log('INFO', 'RDC - Resume Direct Captioning');
                this.setMode('MODE_PAINT-ON');
            }
        }, {
            key: 'ccTR',
            value: function ccTR() {
                // Text Restart in text mode (not supported, however)
                logger.log('INFO', 'TR');
                this.setMode('MODE_TEXT');
            }
        }, {
            key: 'ccRTD',
            value: function ccRTD() {
                // Resume Text Display in Text mode (not supported, however)
                logger.log('INFO', 'RTD');
                this.setMode('MODE_TEXT');
            }
        }, {
            key: 'ccEDM',
            value: function ccEDM() {
                // Erase Displayed Memory
                logger.log('INFO', 'EDM - Erase Displayed Memory');
                this.displayedMemory.reset();
                this.outputDataUpdate();
            }
        }, {
            key: 'ccCR',
            value: function ccCR() {
                // Carriage Return
                logger.log('CR - Carriage Return');
                this.writeScreen.rollUp();
                this.outputDataUpdate();
            }
        }, {
            key: 'ccENM',
            value: function ccENM() {
                //Erase Non-Displayed Memory
                logger.log('INFO', 'ENM - Erase Non-displayed Memory');
                this.nonDisplayedMemory.reset();
            }
        }, {
            key: 'ccEOC',
            value: function ccEOC() {
                //End of Caption (Flip Memories)
                logger.log('INFO', 'EOC - End Of Caption');
                if (this.mode === 'MODE_POP-ON') {
                    var tmp = this.displayedMemory;
                    this.displayedMemory = this.nonDisplayedMemory;
                    this.nonDisplayedMemory = tmp;
                    this.writeScreen = this.nonDisplayedMemory;
                    logger.log('TEXT', 'DISP: ' + this.displayedMemory.getDisplayText());
                }
                this.outputDataUpdate();
            }
        }, {
            key: 'ccTO',
            value: function ccTO(nrCols) {
                // Tab Offset 1,2, or 3 columns
                logger.log('INFO', 'TO(' + nrCols + ') - Tab Offset');
                this.writeScreen.moveCursor(nrCols);
            }
        }, {
            key: 'ccMIDROW',
            value: function ccMIDROW(secondByte) {
                // Parse MIDROW command
                var styles = { flash: false };
                styles.underline = secondByte % 2 === 1;
                styles.italics = secondByte >= 0x2e;
                if (!styles.italics) {
                    var colorIndex = Math.floor(secondByte / 2) - 0x10;
                    var colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];
                    styles.foreground = colors[colorIndex];
                } else {
                    styles.foreground = 'white';
                }
                logger.log('INFO', 'MIDROW: ' + JSON.stringify(styles));
                this.writeScreen.setPen(styles);
            }
        }, {
            key: 'outputDataUpdate',
            value: function outputDataUpdate() {
                var t = logger.time;
                if (t === null) {
                    return;
                }
                if (this.outputFilter) {
                    if (this.outputFilter.updateData) {
                        this.outputFilter.updateData(t, this.displayedMemory);
                    }
                    if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
                        // Start of a new cue
                        this.cueStartTime = t;
                    } else {
                        if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                            if (this.outputFilter.newCue) {
                                this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen);
                            }
                            this.cueStartTime = this.displayedMemory.isEmpty() ? null : t;
                        }
                    }
                    this.lastOutputScreen.copy(this.displayedMemory);
                }
            }
        }, {
            key: 'cueSplitAtTime',
            value: function cueSplitAtTime(t) {
                if (this.outputFilter) {
                    if (!this.displayedMemory.isEmpty()) {
                        if (this.outputFilter.newCue) {
                            this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                        }
                        this.cueStartTime = t;
                    }
                }
            }
        }]);
    
        return Cea608Channel;
    }();
    
    var Cea608Parser = function () {
        function Cea608Parser(field, out1, out2) {
            _classCallCheck(this, Cea608Parser);
    
            this.field = field || 1;
            this.outputs = [out1, out2];
            this.channels = [new Cea608Channel(1, out1), new Cea608Channel(2, out2)];
            this.currChNr = -1; // Will be 1 or 2
            this.lastCmdA = null; // First byte of last command
            this.lastCmdB = null; // Second byte of last command
            this.bufferedData = [];
            this.startTime = null;
            this.lastTime = null;
            this.dataCounters = { 'padding': 0, 'char': 0, 'cmd': 0, 'other': 0 };
        }
    
        _createClass(Cea608Parser, [{
            key: 'getHandler',
            value: function getHandler(index) {
                return this.channels[index].getHandler();
            }
        }, {
            key: 'setHandler',
            value: function setHandler(index, newHandler) {
                this.channels[index].setHandler(newHandler);
            }
    
            /**
             * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.
             */
    
        }, {
            key: 'addData',
            value: function addData(t, byteList) {
                var cmdFound,
                    a,
                    b,
                    charsFound = false;
    
                this.lastTime = t;
                logger.setTime(t);
    
                for (var i = 0; i < byteList.length; i += 2) {
                    a = byteList[i] & 0x7f;
                    b = byteList[i + 1] & 0x7f;
                    if (a === 0 && b === 0) {
                        this.dataCounters.padding += 2;
                        continue;
                    } else {
                        logger.log('DATA', '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');
                    }
                    cmdFound = this.parseCmd(a, b);
                    if (!cmdFound) {
                        cmdFound = this.parseMidrow(a, b);
                    }
                    if (!cmdFound) {
                        cmdFound = this.parsePAC(a, b);
                    }
                    if (!cmdFound) {
                        cmdFound = this.parseBackgroundAttributes(a, b);
                    }
                    if (!cmdFound) {
                        charsFound = this.parseChars(a, b);
                        if (charsFound) {
                            if (this.currChNr && this.currChNr >= 0) {
                                var channel = this.channels[this.currChNr - 1];
                                channel.insertChars(charsFound);
                            } else {
                                logger.log('WARNING', 'No channel found yet. TEXT-MODE?');
                            }
                        }
                    }
                    if (cmdFound) {
                        this.dataCounters.cmd += 2;
                    } else if (charsFound) {
                        this.dataCounters.char += 2;
                    } else {
                        this.dataCounters.other += 2;
                        logger.log('WARNING', 'Couldn\'t parse cleaned data ' + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));
                    }
                }
            }
    
            /**
             * Parse Command.
             * @returns {Boolean} Tells if a command was found
             */
    
        }, {
            key: 'parseCmd',
            value: function parseCmd(a, b) {
                var chNr = null;
    
                var cond1 = (a === 0x14 || a === 0x1C) && 0x20 <= b && b <= 0x2F;
                var cond2 = (a === 0x17 || a === 0x1F) && 0x21 <= b && b <= 0x23;
                if (!(cond1 || cond2)) {
                    return false;
                }
    
                if (a === this.lastCmdA && b === this.lastCmdB) {
                    this.lastCmdA = null;
                    this.lastCmdB = null; // Repeated commands are dropped (once)
                    logger.log('DEBUG', 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');
                    return true;
                }
    
                if (a === 0x14 || a === 0x17) {
                    chNr = 1;
                } else {
                    chNr = 2; // (a === 0x1C || a=== 0x1f)
                }
    
                var channel = this.channels[chNr - 1];
    
                if (a === 0x14 || a === 0x1C) {
                    if (b === 0x20) {
                        channel.ccRCL();
                    } else if (b === 0x21) {
                        channel.ccBS();
                    } else if (b === 0x22) {
                        channel.ccAOF();
                    } else if (b === 0x23) {
                        channel.ccAON();
                    } else if (b === 0x24) {
                        channel.ccDER();
                    } else if (b === 0x25) {
                        channel.ccRU(2);
                    } else if (b === 0x26) {
                        channel.ccRU(3);
                    } else if (b === 0x27) {
                        channel.ccRU(4);
                    } else if (b === 0x28) {
                        channel.ccFON();
                    } else if (b === 0x29) {
                        channel.ccRDC();
                    } else if (b === 0x2A) {
                        channel.ccTR();
                    } else if (b === 0x2B) {
                        channel.ccRTD();
                    } else if (b === 0x2C) {
                        channel.ccEDM();
                    } else if (b === 0x2D) {
                        channel.ccCR();
                    } else if (b === 0x2E) {
                        channel.ccENM();
                    } else if (b === 0x2F) {
                        channel.ccEOC();
                    }
                } else {
                    //a == 0x17 || a == 0x1F
                    channel.ccTO(b - 0x20);
                }
                this.lastCmdA = a;
                this.lastCmdB = b;
                this.currChNr = chNr;
                return true;
            }
    
            /**
             * Parse midrow styling command
             * @returns {Boolean}
             */
    
        }, {
            key: 'parseMidrow',
            value: function parseMidrow(a, b) {
                var chNr = null;
    
                if ((a === 0x11 || a === 0x19) && 0x20 <= b && b <= 0x2f) {
                    if (a === 0x11) {
                        chNr = 1;
                    } else {
                        chNr = 2;
                    }
                    if (chNr !== this.currChNr) {
                        logger.log('ERROR', 'Mismatch channel in midrow parsing');
                        return false;
                    }
                    var channel = this.channels[chNr - 1];
                    channel.ccMIDROW(b);
                    logger.log('DEBUG', 'MIDROW (' + numArrayToHexArray([a, b]) + ')');
                    return true;
                }
                return false;
            }
            /**
             * Parse Preable Access Codes (Table 53).
             * @returns {Boolean} Tells if PAC found
             */
    
        }, {
            key: 'parsePAC',
            value: function parsePAC(a, b) {
    
                var chNr = null;
                var row = null;
    
                var case1 = (0x11 <= a && a <= 0x17 || 0x19 <= a && a <= 0x1F) && 0x40 <= b && b <= 0x7F;
                var case2 = (a === 0x10 || a === 0x18) && 0x40 <= b && b <= 0x5F;
                if (!(case1 || case2)) {
                    return false;
                }
    
                if (a === this.lastCmdA && b === this.lastCmdB) {
                    this.lastCmdA = null;
                    this.lastCmdB = null;
                    return true; // Repeated commands are dropped (once)
                }
    
                chNr = a <= 0x17 ? 1 : 2;
    
                if (0x40 <= b && b <= 0x5F) {
                    row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
                } else {
                    // 0x60 <= b <= 0x7F
                    row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
                }
                var pacData = this.interpretPAC(row, b);
                var channel = this.channels[chNr - 1];
                channel.setPAC(pacData);
                this.lastCmdA = a;
                this.lastCmdB = b;
                this.currChNr = chNr;
                return true;
            }
    
            /**
             * Interpret the second byte of the pac, and return the information.
             * @returns {Object} pacData with style parameters.
             */
    
        }, {
            key: 'interpretPAC',
            value: function interpretPAC(row, byte) {
                var pacIndex = byte;
                var pacData = { color: null, italics: false, indent: null, underline: false, row: row };
    
                if (byte > 0x5F) {
                    pacIndex = byte - 0x60;
                } else {
                    pacIndex = byte - 0x40;
                }
                pacData.underline = (pacIndex & 1) === 1;
                if (pacIndex <= 0xd) {
                    pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];
                } else if (pacIndex <= 0xf) {
                    pacData.italics = true;
                    pacData.color = 'white';
                } else {
                    pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;
                }
                return pacData; // Note that row has zero offset. The spec uses 1.
            }
    
            /**
             * Parse characters.
             * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.
             */
    
        }, {
            key: 'parseChars',
            value: function parseChars(a, b) {
    
                var channelNr = null,
                    charCodes = null,
                    charCode1 = null;
    
                if (a >= 0x19) {
                    channelNr = 2;
                    charCode1 = a - 8;
                } else {
                    channelNr = 1;
                    charCode1 = a;
                }
                if (0x11 <= charCode1 && charCode1 <= 0x13) {
                    // Special character
                    var oneCode = b;
                    if (charCode1 === 0x11) {
                        oneCode = b + 0x50;
                    } else if (charCode1 === 0x12) {
                        oneCode = b + 0x70;
                    } else {
                        oneCode = b + 0x90;
                    }
                    logger.log('INFO', 'Special char \'' + getCharForByte(oneCode) + '\' in channel ' + channelNr);
                    charCodes = [oneCode];
                } else if (0x20 <= a && a <= 0x7f) {
                    charCodes = b === 0 ? [a] : [a, b];
                }
                if (charCodes) {
                    var hexCodes = numArrayToHexArray(charCodes);
                    logger.log('DEBUG', 'Char codes =  ' + hexCodes.join(','));
                    this.lastCmdA = null;
                    this.lastCmdB = null;
                }
                return charCodes;
            }
    
            /**
            * Parse extended background attributes as well as new foreground color black.
            * @returns{Boolean} Tells if background attributes are found
            */
    
        }, {
            key: 'parseBackgroundAttributes',
            value: function parseBackgroundAttributes(a, b) {
                var bkgData, index, chNr, channel;
    
                var case1 = (a === 0x10 || a === 0x18) && 0x20 <= b && b <= 0x2f;
                var case2 = (a === 0x17 || a === 0x1f) && 0x2d <= b && b <= 0x2f;
                if (!(case1 || case2)) {
                    return false;
                }
                bkgData = {};
                if (a === 0x10 || a === 0x18) {
                    index = Math.floor((b - 0x20) / 2);
                    bkgData.background = backgroundColors[index];
                    if (b % 2 === 1) {
                        bkgData.background = bkgData.background + '_semi';
                    }
                } else if (b === 0x2d) {
                    bkgData.background = 'transparent';
                } else {
                    bkgData.foreground = 'black';
                    if (b === 0x2f) {
                        bkgData.underline = true;
                    }
                }
                chNr = a < 0x18 ? 1 : 2;
                channel = this.channels[chNr - 1];
                channel.setBkgData(bkgData);
                this.lastCmdA = null;
                this.lastCmdB = null;
                return true;
            }
    
            /**
             * Reset state of parser and its channels.
             */
    
        }, {
            key: 'reset',
            value: function reset() {
                for (var i = 0; i < this.channels.length; i++) {
                    if (this.channels[i]) {
                        this.channels[i].reset();
                    }
                }
                this.lastCmdA = null;
                this.lastCmdB = null;
            }
    
            /**
             * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.
             */
    
        }, {
            key: 'cueSplitAtTime',
            value: function cueSplitAtTime(t) {
                for (var i = 0; i < this.channels.length; i++) {
                    if (this.channels[i]) {
                        this.channels[i].cueSplitAtTime(t);
                    }
                }
            }
        }]);
    
        return Cea608Parser;
    }();
    
    exports.default = Cea608Parser;
    
    },{}],48:[function(_dereq_,module,exports){
    'use strict';
    
    var _vttparser = _dereq_(54);
    
    var Cues = {
    
      newCue: function newCue(track, startTime, endTime, captionScreen) {
        var row;
        var cue;
        var indenting;
        var indent;
        var text;
        var VTTCue = window.VTTCue || window.TextTrackCue;
    
        for (var r = 0; r < captionScreen.rows.length; r++) {
          row = captionScreen.rows[r];
          indenting = true;
          indent = 0;
          text = '';
    
          if (!row.isEmpty()) {
            for (var c = 0; c < row.chars.length; c++) {
              if (row.chars[c].uchar.match(/\s/) && indenting) {
                indent++;
              } else {
                text += row.chars[c].uchar;
                indenting = false;
              }
            }
            //To be used for cleaning-up orphaned roll-up captions
            row.cueStartTime = startTime;
    
            // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE
            if (startTime === endTime) {
              endTime += 0.0001;
            }
    
            cue = new VTTCue(startTime, endTime, (0, _vttparser.fixLineBreaks)(text.trim()));
    
            if (indent >= 16) {
              indent--;
            } else {
              indent++;
            }
    
            // VTTCue.line get's flakey when using controls, so let's now include line 13&14
            // also, drop line 1 since it's to close to the top
            if (navigator.userAgent.match(/Firefox\//)) {
              cue.line = r + 1;
            } else {
              cue.line = r > 7 ? r - 2 : r + 1;
            }
            cue.align = 'left';
            // Clamp the position between 0 and 100 - if out of these bounds, Firefox throws an exception and captions break
            cue.position = Math.max(0, Math.min(100, 100 * (indent / 32) + (navigator.userAgent.match(/Firefox\//) ? 50 : 0)));
            track.addCue(cue);
          }
        }
      }
    
    };
    
    module.exports = Cues;
    
    },{"54":54}],49:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * EWMA Bandwidth Estimator
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *  - heavily inspired from shaka-player
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Tracks bandwidth samples and estimates available bandwidth.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Based on the minimum of two exponentially-weighted moving averages with
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * different half-lives.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */
    
    var _ewma = _dereq_(50);
    
    var _ewma2 = _interopRequireDefault(_ewma);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var EwmaBandWidthEstimator = function () {
      function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
        _classCallCheck(this, EwmaBandWidthEstimator);
    
        this.hls = hls;
        this.defaultEstimate_ = defaultEstimate;
        this.minWeight_ = 0.001;
        this.minDelayMs_ = 50;
        this.slow_ = new _ewma2.default(slow);
        this.fast_ = new _ewma2.default(fast);
      }
    
      _createClass(EwmaBandWidthEstimator, [{
        key: 'sample',
        value: function sample(durationMs, numBytes) {
          durationMs = Math.max(durationMs, this.minDelayMs_);
          var bandwidth = 8000 * numBytes / durationMs,
    
          //console.log('instant bw:'+ Math.round(bandwidth));
          // we weight sample using loading duration....
          weight = durationMs / 1000;
          this.fast_.sample(weight, bandwidth);
          this.slow_.sample(weight, bandwidth);
        }
      }, {
        key: 'canEstimate',
        value: function canEstimate() {
          var fast = this.fast_;
          return fast && fast.getTotalWeight() >= this.minWeight_;
        }
      }, {
        key: 'getEstimate',
        value: function getEstimate() {
          if (this.canEstimate()) {
            //console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));
            //console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));
            // Take the minimum of these two estimates.  This should have the effect of
            // adapting down quickly, but up more slowly.
            return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
          } else {
            return this.defaultEstimate_;
          }
        }
      }, {
        key: 'destroy',
        value: function destroy() {}
      }]);
    
      return EwmaBandWidthEstimator;
    }();
    
    exports.default = EwmaBandWidthEstimator;
    
    },{"50":50}],50:[function(_dereq_,module,exports){
    "use strict";
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    /*
     * compute an Exponential Weighted moving average
     * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
     *  - heavily inspired from shaka-player
     */
    
    var EWMA = function () {
    
      //  About half of the estimated value will be from the last |halfLife| samples by weight.
      function EWMA(halfLife) {
        _classCallCheck(this, EWMA);
    
        // Larger values of alpha expire historical data more slowly.
        this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
        this.estimate_ = 0;
        this.totalWeight_ = 0;
      }
    
      _createClass(EWMA, [{
        key: "sample",
        value: function sample(weight, value) {
          var adjAlpha = Math.pow(this.alpha_, weight);
          this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
          this.totalWeight_ += weight;
        }
      }, {
        key: "getTotalWeight",
        value: function getTotalWeight() {
          return this.totalWeight_;
        }
      }, {
        key: "getEstimate",
        value: function getEstimate() {
          if (this.alpha_) {
            var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
            return this.estimate_ / zeroFactor;
          } else {
            return this.estimate_;
          }
        }
      }]);
    
      return EWMA;
    }();
    
    exports.default = EWMA;
    
    },{}],51:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
    
    function noop() {}
    
    var fakeLogger = {
      trace: noop,
      debug: noop,
      log: noop,
      warn: noop,
      info: noop,
      error: noop
    };
    
    var exportedLogger = fakeLogger;
    
    /*globals self: false */
    
    //let lastCallTime;
    // function formatMsgWithTimeInfo(type, msg) {
    //   const now = Date.now();
    //   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';
    //   lastCallTime = now;
    //   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';
    //   return msg;
    // }
    
    function formatMsg(type, msg) {
      msg = '[' + type + '] > ' + msg;
      return msg;
    }
    
    function consolePrintFn(type) {
      var func = self.console[type];
      if (func) {
        return function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
    
          if (args[0]) {
            args[0] = formatMsg(type, args[0]);
          }
          func.apply(self.console, args);
        };
      }
      return noop;
    }
    
    function exportLoggerFunctions(debugConfig) {
      for (var _len2 = arguments.length, functions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        functions[_key2 - 1] = arguments[_key2];
      }
    
      functions.forEach(function (type) {
        exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
      });
    }
    
    var enableLogs = exports.enableLogs = function enableLogs(debugConfig) {
      if (debugConfig === true || (typeof debugConfig === 'undefined' ? 'undefined' : _typeof(debugConfig)) === 'object') {
        exportLoggerFunctions(debugConfig,
        // Remove out from list here to hard-disable a log-level
        //'trace',
        'debug', 'log', 'info', 'warn', 'error');
        // Some browsers don't allow to use bind on console object anyway
        // fallback to default if needed
        try {
          exportedLogger.log();
        } catch (e) {
          exportedLogger = fakeLogger;
        }
      } else {
        exportedLogger = fakeLogger;
      }
    };
    
    var logger = exports.logger = exportedLogger;
    
    },{}],52:[function(_dereq_,module,exports){
    'use strict';
    
    /**
     *  TimeRanges to string helper
     */
    
    var TimeRanges = {
      toString: function toString(r) {
        var log = '',
            len = r.length;
        for (var i = 0; i < len; i++) {
          log += '[' + r.start(i).toFixed(3) + ',' + r.end(i).toFixed(3) + ']';
        }
        return log;
      }
    };
    
    module.exports = TimeRanges;
    
    },{}],53:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    /**
     * Copyright 2013 vtt.js Contributors
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    exports.default = function () {
      if (typeof window !== 'undefined' && window.VTTCue) {
        return window.VTTCue;
      }
    
      var autoKeyword = 'auto';
      var directionSetting = {
        '': true,
        lr: true,
        rl: true
      };
      var alignSetting = {
        start: true,
        middle: true,
        end: true,
        left: true,
        right: true
      };
    
      function findDirectionSetting(value) {
        if (typeof value !== 'string') {
          return false;
        }
        var dir = directionSetting[value.toLowerCase()];
        return dir ? value.toLowerCase() : false;
      }
    
      function findAlignSetting(value) {
        if (typeof value !== 'string') {
          return false;
        }
        var align = alignSetting[value.toLowerCase()];
        return align ? value.toLowerCase() : false;
      }
    
      function extend(obj) {
        var i = 1;
        for (; i < arguments.length; i++) {
          var cobj = arguments[i];
          for (var p in cobj) {
            obj[p] = cobj[p];
          }
        }
    
        return obj;
      }
    
      function VTTCue(startTime, endTime, text) {
        var cue = this;
        var isIE8 = function () {
          if (typeof navigator === 'undefined') {
            return;
          }
          return (/MSIE\s8\.0/.test(navigator.userAgent)
          );
        }();
        var baseObj = {};
    
        if (isIE8) {
          cue = document.createElement('custom');
        } else {
          baseObj.enumerable = true;
        }
    
        /**
         * Shim implementation specific properties. These properties are not in
         * the spec.
         */
    
        // Lets us know when the VTTCue's data has changed in such a way that we need
        // to recompute its display state. This lets us compute its display state
        // lazily.
        cue.hasBeenReset = false;
    
        /**
         * VTTCue and TextTrackCue properties
         * http://dev.w3.org/html5/webvtt/#vttcue-interface
         */
    
        var _id = '';
        var _pauseOnExit = false;
        var _startTime = startTime;
        var _endTime = endTime;
        var _text = text;
        var _region = null;
        var _vertical = '';
        var _snapToLines = true;
        var _line = 'auto';
        var _lineAlign = 'start';
        var _position = 50;
        var _positionAlign = 'middle';
        var _size = 50;
        var _align = 'middle';
    
        Object.defineProperty(cue, 'id', extend({}, baseObj, {
          get: function get() {
            return _id;
          },
          set: function set(value) {
            _id = '' + value;
          }
        }));
    
        Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {
          get: function get() {
            return _pauseOnExit;
          },
          set: function set(value) {
            _pauseOnExit = !!value;
          }
        }));
    
        Object.defineProperty(cue, 'startTime', extend({}, baseObj, {
          get: function get() {
            return _startTime;
          },
          set: function set(value) {
            if (typeof value !== 'number') {
              throw new TypeError('Start time must be set to a number.');
            }
            _startTime = value;
            this.hasBeenReset = true;
          }
        }));
    
        Object.defineProperty(cue, 'endTime', extend({}, baseObj, {
          get: function get() {
            return _endTime;
          },
          set: function set(value) {
            if (typeof value !== 'number') {
              throw new TypeError('End time must be set to a number.');
            }
            _endTime = value;
            this.hasBeenReset = true;
          }
        }));
    
        Object.defineProperty(cue, 'text', extend({}, baseObj, {
          get: function get() {
            return _text;
          },
          set: function set(value) {
            _text = '' + value;
            this.hasBeenReset = true;
          }
        }));
    
        Object.defineProperty(cue, 'region', extend({}, baseObj, {
          get: function get() {
            return _region;
          },
          set: function set(value) {
            _region = value;
            this.hasBeenReset = true;
          }
        }));
    
        Object.defineProperty(cue, 'vertical', extend({}, baseObj, {
          get: function get() {
            return _vertical;
          },
          set: function set(value) {
            var setting = findDirectionSetting(value);
            // Have to check for false because the setting an be an empty string.
            if (setting === false) {
              throw new SyntaxError('An invalid or illegal string was specified.');
            }
            _vertical = setting;
            this.hasBeenReset = true;
          }
        }));
    
        Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {
          get: function get() {
            return _snapToLines;
          },
          set: function set(value) {
            _snapToLines = !!value;
            this.hasBeenReset = true;
          }
        }));
    
        Object.defineProperty(cue, 'line', extend({}, baseObj, {
          get: function get() {
            return _line;
          },
          set: function set(value) {
            if (typeof value !== 'number' && value !== autoKeyword) {
              throw new SyntaxError('An invalid number or illegal string was specified.');
            }
            _line = value;
            this.hasBeenReset = true;
          }
        }));
    
        Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {
          get: function get() {
            return _lineAlign;
          },
          set: function set(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError('An invalid or illegal string was specified.');
            }
            _lineAlign = setting;
            this.hasBeenReset = true;
          }
        }));
    
        Object.defineProperty(cue, 'position', extend({}, baseObj, {
          get: function get() {
            return _position;
          },
          set: function set(value) {
            if (value < 0 || value > 100) {
              throw new Error('Position must be between 0 and 100.');
            }
            _position = value;
            this.hasBeenReset = true;
          }
        }));
    
        Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {
          get: function get() {
            return _positionAlign;
          },
          set: function set(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError('An invalid or illegal string was specified.');
            }
            _positionAlign = setting;
            this.hasBeenReset = true;
          }
        }));
    
        Object.defineProperty(cue, 'size', extend({}, baseObj, {
          get: function get() {
            return _size;
          },
          set: function set(value) {
            if (value < 0 || value > 100) {
              throw new Error('Size must be between 0 and 100.');
            }
            _size = value;
            this.hasBeenReset = true;
          }
        }));
    
        Object.defineProperty(cue, 'align', extend({}, baseObj, {
          get: function get() {
            return _align;
          },
          set: function set(value) {
            var setting = findAlignSetting(value);
            if (!setting) {
              throw new SyntaxError('An invalid or illegal string was specified.');
            }
            _align = setting;
            this.hasBeenReset = true;
          }
        }));
    
        /**
         * Other <track> spec defined properties
         */
    
        // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
        cue.displayState = undefined;
    
        if (isIE8) {
          return cue;
        }
      }
    
      /**
       * VTTCue methods
       */
    
      VTTCue.prototype.getCueAsHTML = function () {
        // Assume WebVTT.convertCueToDOMTree is on the global.
        var WebVTT = window.WebVTT;
        return WebVTT.convertCueToDOMTree(window, this.text);
      };
    
      return VTTCue;
    }();
    
    },{}],54:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.fixLineBreaks = undefined;
    
    var _vttcue = _dereq_(53);
    
    var _vttcue2 = _interopRequireDefault(_vttcue);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    var StringDecoder = function StringDecoder() {
      return {
        decode: function decode(data) {
          if (!data) {
            return '';
          }
          if (typeof data !== 'string') {
            throw new Error('Error - expected string data.');
          }
          return decodeURIComponent(encodeURIComponent(data));
        }
      };
    }; /*
        * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js#L1716
        */
    
    function VTTParser() {
      this.window = window;
      this.state = 'INITIAL';
      this.buffer = '';
      this.decoder = new StringDecoder();
      this.regionList = [];
    }
    
    // Try to parse input as a time stamp.
    function parseTimeStamp(input) {
    
      function computeSeconds(h, m, s, f) {
        return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
      }
    
      var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
      if (!m) {
        return null;
      }
    
      if (m[3]) {
        // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
        return computeSeconds(m[1], m[2], m[3].replace(':', ''), m[4]);
      } else if (m[1] > 59) {
        // Timestamp takes the form of [hours]:[minutes].[milliseconds]
        // First position is hours as it's over 59.
        return computeSeconds(m[1], m[2], 0, m[4]);
      } else {
        // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
        return computeSeconds(0, m[1], m[2], m[4]);
      }
    }
    
    // A settings object holds key/value pairs and will ignore anything but the first
    // assignment to a specific key.
    function Settings() {
      this.values = Object.create(null);
    }
    
    Settings.prototype = {
      // Only accept the first assignment to any key.
      set: function set(k, v) {
        if (!this.get(k) && v !== '') {
          this.values[k] = v;
        }
      },
      // Return the value for a key, or a default value.
      // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
      // a number of possible default values as properties where 'defaultKey' is
      // the key of the property that will be chosen; otherwise it's assumed to be
      // a single value.
      get: function get(k, dflt, defaultKey) {
        if (defaultKey) {
          return this.has(k) ? this.values[k] : dflt[defaultKey];
        }
        return this.has(k) ? this.values[k] : dflt;
      },
      // Check whether we have a value for a key.
      has: function has(k) {
        return k in this.values;
      },
      // Accept a setting if its one of the given alternatives.
      alt: function alt(k, v, a) {
        for (var n = 0; n < a.length; ++n) {
          if (v === a[n]) {
            this.set(k, v);
            break;
          }
        }
      },
      // Accept a setting if its a valid (signed) integer.
      integer: function integer(k, v) {
        if (/^-?\d+$/.test(v)) {
          // integer
          this.set(k, parseInt(v, 10));
        }
      },
      // Accept a setting if its a valid percentage.
      percent: function percent(k, v) {
        var m;
        if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
          v = parseFloat(v);
          if (v >= 0 && v <= 100) {
            this.set(k, v);
            return true;
          }
        }
        return false;
      }
    };
    
    // Helper function to parse input into groups separated by 'groupDelim', and
    // interprete each group as a key/value pair separated by 'keyValueDelim'.
    function parseOptions(input, callback, keyValueDelim, groupDelim) {
      var groups = groupDelim ? input.split(groupDelim) : [input];
      for (var i in groups) {
        if (typeof groups[i] !== 'string') {
          continue;
        }
        var kv = groups[i].split(keyValueDelim);
        if (kv.length !== 2) {
          continue;
        }
        var k = kv[0];
        var v = kv[1];
        callback(k, v);
      }
    }
    
    var defaults = new _vttcue2.default(0, 0, 0);
    // 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244
    // Chrome and Safari don't yet support this change, but FF does
    var center = defaults.align === 'middle' ? 'middle' : 'center';
    
    function parseCue(input, cue, regionList) {
      // Remember the original input if we need to throw an error.
      var oInput = input;
      // 4.1 WebVTT timestamp
      function consumeTimeStamp() {
        var ts = parseTimeStamp(input);
        if (ts === null) {
          throw new Error('Malformed timestamp: ' + oInput);
        }
        // Remove time stamp from input.
        input = input.replace(/^[^\sa-zA-Z-]+/, '');
        return ts;
      }
    
      // 4.4.2 WebVTT cue settings
      function consumeCueSettings(input, cue) {
        var settings = new Settings();
    
        parseOptions(input, function (k, v) {
          switch (k) {
            case 'region':
              // Find the last region we parsed with the same region id.
              for (var i = regionList.length - 1; i >= 0; i--) {
                if (regionList[i].id === v) {
                  settings.set(k, regionList[i].region);
                  break;
                }
              }
              break;
            case 'vertical':
              settings.alt(k, v, ['rl', 'lr']);
              break;
            case 'line':
              var vals = v.split(','),
                  vals0 = vals[0];
              settings.integer(k, vals0);
              if (settings.percent(k, vals0)) {
                settings.set('snapToLines', false);
              }
              settings.alt(k, vals0, ['auto']);
              if (vals.length === 2) {
                settings.alt('lineAlign', vals[1], ['start', center, 'end']);
              }
              break;
            case 'position':
              vals = v.split(',');
              settings.percent(k, vals[0]);
              if (vals.length === 2) {
                settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);
              }
              break;
            case 'size':
              settings.percent(k, v);
              break;
            case 'align':
              settings.alt(k, v, ['start', center, 'end', 'left', 'right']);
              break;
          }
        }, /:/, /\s/);
    
        // Apply default values for any missing fields.
        cue.region = settings.get('region', null);
        cue.vertical = settings.get('vertical', '');
        var line = settings.get('line', 'auto');
        if (line === 'auto' && defaults.line === -1) {
          // set numeric line number for Safari
          line = -1;
        }
        cue.line = line;
        cue.lineAlign = settings.get('lineAlign', 'start');
        cue.snapToLines = settings.get('snapToLines', true);
        cue.size = settings.get('size', 100);
        cue.align = settings.get('align', center);
        var position = settings.get('position', 'auto');
        if (position === 'auto' && defaults.position === 50) {
          // set numeric position for Safari
          position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;
        }
        cue.position = position;
      }
    
      function skipWhitespace() {
        input = input.replace(/^\s+/, '');
      }
    
      // 4.1 WebVTT cue timings.
      skipWhitespace();
      cue.startTime = consumeTimeStamp(); // (1) collect cue start time
      skipWhitespace();
      if (input.substr(0, 3) !== '-->') {
        // (3) next characters must match '-->'
        throw new Error('Malformed time stamp (time stamps must be separated by \'-->\'): ' + oInput);
      }
      input = input.substr(3);
      skipWhitespace();
      cue.endTime = consumeTimeStamp(); // (5) collect cue end time
    
      // 4.1 WebVTT cue settings list.
      skipWhitespace();
      consumeCueSettings(input, cue);
    }
    
    function fixLineBreaks(input) {
      return input.replace(/<br(?: \/)?>/gi, '\n');
    }
    
    VTTParser.prototype = {
      parse: function parse(data) {
        var self = this;
    
        // If there is no data then we won't decode it, but will just try to parse
        // whatever is in buffer already. This may occur in circumstances, for
        // example when flush() is called.
        if (data) {
          // Try to decode the data that we received.
          self.buffer += self.decoder.decode(data, { stream: true });
        }
    
        function collectNextLine() {
          var buffer = self.buffer;
          var pos = 0;
    
          buffer = fixLineBreaks(buffer);
    
          while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
            ++pos;
          }
          var line = buffer.substr(0, pos);
          // Advance the buffer early in case we fail below.
          if (buffer[pos] === '\r') {
            ++pos;
          }
          if (buffer[pos] === '\n') {
            ++pos;
          }
          self.buffer = buffer.substr(pos);
          return line;
        }
    
        // 3.2 WebVTT metadata header syntax
        function parseHeader(input) {
          parseOptions(input, function (k, v) {
            switch (k) {
              case 'Region':
                // 3.3 WebVTT region metadata header syntax
                console.log('parse region', v);
                //parseRegion(v);
                break;
            }
          }, /:/);
        }
    
        // 5.1 WebVTT file parsing.
        try {
          var line;
          if (self.state === 'INITIAL') {
            // We can't start parsing until we have the first line.
            if (!/\r\n|\n/.test(self.buffer)) {
              return this;
            }
    
            line = collectNextLine();
    
            var m = line.match(/^WEBVTT([ \t].*)?$/);
            if (!m || !m[0]) {
              throw new Error('Malformed WebVTT signature.');
            }
    
            self.state = 'HEADER';
          }
    
          var alreadyCollectedLine = false;
          while (self.buffer) {
            // We can't parse a line until we have the full line.
            if (!/\r\n|\n/.test(self.buffer)) {
              return this;
            }
    
            if (!alreadyCollectedLine) {
              line = collectNextLine();
            } else {
              alreadyCollectedLine = false;
            }
    
            switch (self.state) {
              case 'HEADER':
                // 13-18 - Allow a header (metadata) under the WEBVTT line.
                if (/:/.test(line)) {
                  parseHeader(line);
                } else if (!line) {
                  // An empty line terminates the header and starts the body (cues).
                  self.state = 'ID';
                }
                continue;
              case 'NOTE':
                // Ignore NOTE blocks.
                if (!line) {
                  self.state = 'ID';
                }
                continue;
              case 'ID':
                // Check for the start of NOTE blocks.
                if (/^NOTE($|[ \t])/.test(line)) {
                  self.state = 'NOTE';
                  break;
                }
                // 19-29 - Allow any number of line terminators, then initialize new cue values.
                if (!line) {
                  continue;
                }
                self.cue = new _vttcue2.default(0, 0, '');
                self.state = 'CUE';
                // 30-39 - Check if self line contains an optional identifier or timing data.
                if (line.indexOf('-->') === -1) {
                  self.cue.id = line;
                  continue;
                }
              // Process line as start of a cue.
              /*falls through*/
              case 'CUE':
                // 40 - Collect cue timings and settings.
                try {
                  parseCue(line, self.cue, self.regionList);
                } catch (e) {
                  // In case of an error ignore rest of the cue.
                  self.cue = null;
                  self.state = 'BADCUE';
                  continue;
                }
                self.state = 'CUETEXT';
                continue;
              case 'CUETEXT':
                var hasSubstring = line.indexOf('-->') !== -1;
                // 34 - If we have an empty line then report the cue.
                // 35 - If we have the special substring '-->' then report the cue,
                // but do not collect the line as we need to process the current
                // one as a new cue.
                if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                  // We are done parsing self cue.
                  if (self.oncue) {
                    self.oncue(self.cue);
                  }
                  self.cue = null;
                  self.state = 'ID';
                  continue;
                }
                if (self.cue.text) {
                  self.cue.text += '\n';
                }
                self.cue.text += line;
                continue;
              case 'BADCUE':
                // BADCUE
                // 54-62 - Collect and discard the remaining cue.
                if (!line) {
                  self.state = 'ID';
                }
                continue;
            }
          }
        } catch (e) {
    
          // If we are currently parsing a cue, report what we have.
          if (self.state === 'CUETEXT' && self.cue && self.oncue) {
            self.oncue(self.cue);
          }
          self.cue = null;
          // Enter BADWEBVTT state if header was not parsed correctly otherwise
          // another exception occurred so enter BADCUE state.
          self.state = self.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';
        }
        return this;
      },
      flush: function flush() {
        var self = this;
        try {
          // Finish decoding the stream.
          self.buffer += self.decoder.decode();
          // Synthesize the end of the current cue or region.
          if (self.cue || self.state === 'HEADER') {
            self.buffer += '\n\n';
            self.parse();
          }
          // If we've flushed, parsed, and we're still on the INITIAL state then
          // that means we don't have enough of the stream to parse the first
          // line.
          if (self.state === 'INITIAL') {
            throw new Error('Malformed WebVTT signature.');
          }
        } catch (e) {
          throw e;
        }
        if (self.onflush) {
          self.onflush();
        }
        return this;
      }
    };
    
    exports.fixLineBreaks = fixLineBreaks;
    exports.default = VTTParser;
    
    },{"53":53}],55:[function(_dereq_,module,exports){
    'use strict';
    
    var _vttparser = _dereq_(54);
    
    var _vttparser2 = _interopRequireDefault(_vttparser);
    
    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
    
    var cueString2millis = function cueString2millis(timeString) {
        var ts = parseInt(timeString.substr(-3));
        var secs = parseInt(timeString.substr(-6, 2));
        var mins = parseInt(timeString.substr(-9, 2));
        var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(':'))) : 0;
    
        if (isNaN(ts) || isNaN(secs) || isNaN(mins) || isNaN(hours)) {
            return -1;
        }
    
        ts += 1000 * secs;
        ts += 60 * 1000 * mins;
        ts += 60 * 60 * 1000 * hours;
    
        return ts;
    };
    
    var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
        var currCC = vttCCs[cc];
        var prevCC = vttCCs[currCC.prevCC];
    
        // This is the first discontinuity or cues have been processed since the last discontinuity
        // Offset = current discontinuity time
        if (!prevCC || !prevCC.new && currCC.new) {
            vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
            currCC.new = false;
            return;
        }
    
        // There have been discontinuities since cues were last parsed.
        // Offset = time elapsed
        while (prevCC && prevCC.new) {
            vttCCs.ccOffset += currCC.start - prevCC.start;
            currCC.new = false;
            currCC = prevCC;
            prevCC = vttCCs[currCC.prevCC];
        }
    
        vttCCs.presentationOffset = presentationTime;
    };
    
    var WebVTTParser = {
        parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
            // Convert byteArray into string, replacing any somewhat exotic linefeeds with "\n", then split on that character.
            var re = /\r\n|\n\r|\n|\r/g;
            var vttLines = String.fromCharCode.apply(null, new Uint8Array(vttByteArray)).trim().replace(re, '\n').split('\n');
            var cueTime = '00:00.000';
            var mpegTs = 0;
            var localTime = 0;
            var presentationTime = 0;
            var cues = [];
            var parsingError = void 0;
            var inHeader = true;
            // let VTTCue = VTTCue || window.TextTrackCue;
    
            // Create parser object using VTTCue with TextTrackCue fallback on certain browsers.
            var parser = new _vttparser2.default();
    
            parser.oncue = function (cue) {
                // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.
                var currCC = vttCCs[cc];
                var cueOffset = vttCCs.ccOffset;
    
                // Update offsets for new discontinuities
                if (currCC && currCC.new) {
                    if (localTime) {
                        // When local time is provided, offset = discontinuity start time - local time
                        cueOffset = vttCCs.ccOffset = currCC.start;
                    } else {
                        calculateOffset(vttCCs, cc, presentationTime);
                    }
                }
    
                if (presentationTime && !localTime) {
                    // If we have MPEGTS but no LOCAL time, offset = presentation time + discontinuity offset
                    cueOffset = presentationTime + vttCCs.ccOffset - vttCCs.presentationOffset;
                }
    
                cue.startTime += cueOffset - localTime;
                cue.endTime += cueOffset - localTime;
    
                // Fix encoding of special characters. TODO: Test with all sorts of weird characters.
                cue.text = decodeURIComponent(escape(cue.text));
                if (cue.endTime > 0) {
                    cues.push(cue);
                }
            };
    
            parser.onparsingerror = function (e) {
                parsingError = e;
            };
    
            parser.onflush = function () {
                if (parsingError && errorCallBack) {
                    errorCallBack(parsingError);
                    return;
                }
                callBack(cues);
            };
    
            // Go through contents line by line.
            vttLines.forEach(function (line) {
                if (inHeader) {
                    // Look for X-TIMESTAMP-MAP in header.
                    if (line.startsWith('X-TIMESTAMP-MAP=')) {
                        // Once found, no more are allowed anyway, so stop searching.
                        inHeader = false;
                        // Extract LOCAL and MPEGTS.
                        line.substr(16).split(',').forEach(function (timestamp) {
                            if (timestamp.startsWith('LOCAL:')) {
                                cueTime = timestamp.substr(6);
                            } else if (timestamp.startsWith('MPEGTS:')) {
                                mpegTs = parseInt(timestamp.substr(7));
                            }
                        });
                        try {
                            // Calculate subtitle offset in milliseconds.
                            // If sync PTS is less than zero, we have a 33-bit wraparound, which is fixed by adding 2^33 = 8589934592.
                            syncPTS = syncPTS < 0 ? syncPTS + 8589934592 : syncPTS;
                            // Adjust MPEGTS by sync PTS.
                            mpegTs -= syncPTS;
                            // Convert cue time to seconds
                            localTime = cueString2millis(cueTime) / 1000;
                            // Convert MPEGTS to seconds from 90kHz.
                            presentationTime = mpegTs / 90000;
    
                            if (localTime === -1) {
                                parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
                            }
                        } catch (e) {
                            parsingError = new Error('Malformed X-TIMESTAMP-MAP: ' + line);
                        }
                        // Return without parsing X-TIMESTAMP-MAP line.
                        return;
                    } else if (line === '') {
                        inHeader = false;
                    }
                }
                // Parse line by default.
                parser.parse(line + '\n');
            });
    
            parser.flush();
        }
    };
    
    module.exports = WebVTTParser;
    
    },{"54":54}],56:[function(_dereq_,module,exports){
    'use strict';
    
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    
    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * XHR based logger
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         */
    
    var _logger = _dereq_(51);
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    var XhrLoader = function () {
      function XhrLoader(config) {
        _classCallCheck(this, XhrLoader);
    
        if (config && config.xhrSetup) {
          this.xhrSetup = config.xhrSetup;
        }
      }
    
      _createClass(XhrLoader, [{
        key: 'destroy',
        value: function destroy() {
          this.abort();
          this.loader = null;
        }
      }, {
        key: 'abort',
        value: function abort() {
          var loader = this.loader;
          if (loader && loader.readyState !== 4) {
            this.stats.aborted = true;
            loader.abort();
          }
    
          window.clearTimeout(this.requestTimeout);
          this.requestTimeout = null;
          window.clearTimeout(this.retryTimeout);
          this.retryTimeout = null;
        }
      }, {
        key: 'load',
        value: function load(context, config, callbacks) {
          this.context = context;
          this.config = config;
          this.callbacks = callbacks;
          this.stats = { trequest: performance.now(), retry: 0 };
          this.retryDelay = config.retryDelay;
          this.loadInternal();
        }
      }, {
        key: 'loadInternal',
        value: function loadInternal() {
          var xhr,
              context = this.context;
    
          if (typeof XDomainRequest !== 'undefined') {
            xhr = this.loader = new XDomainRequest();
          } else {
            xhr = this.loader = new XMLHttpRequest();
          }
          var stats = this.stats;
          stats.tfirst = 0;
          stats.loaded = 0;
          var xhrSetup = this.xhrSetup;
          if (xhrSetup) {
            try {
              xhrSetup(xhr, context.url);
            } catch (e) {
              // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader("Content-Language", "test");}
              // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN
              xhr.open('GET', context.url, true);
              xhrSetup(xhr, context.url);
            }
          }
    
          if (!xhr.readyState) {
            xhr.open('GET', context.url, true);
          }
          if (context.rangeEnd) {
            xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));
          }
          xhr.onreadystatechange = this.readystatechange.bind(this);
          xhr.onprogress = this.loadprogress.bind(this);
          xhr.responseType = context.responseType;
    
          // setup timeout before we perform request
          this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
          xhr.send();
        }
      }, {
        key: 'readystatechange',
        value: function readystatechange(event) {
          var xhr = event.currentTarget,
              readyState = xhr.readyState,
              stats = this.stats,
              context = this.context,
              config = this.config;
    
          // don't proceed if xhr has been aborted
          if (stats.aborted) {
            return;
          }
    
          // >= HEADERS_RECEIVED
          if (readyState >= 2) {
            // clear xhr timeout and rearm it if readyState less than 4
            window.clearTimeout(this.requestTimeout);
            if (stats.tfirst === 0) {
              stats.tfirst = Math.max(performance.now(), stats.trequest);
            }
            if (readyState === 4) {
              var status = xhr.status;
              // http status between 200 to 299 are all successful
              if (status >= 200 && status < 300) {
                stats.tload = Math.max(stats.tfirst, performance.now());
                var data = void 0,
                    len = void 0;
                if (context.responseType === 'arraybuffer') {
                  data = xhr.response;
                  len = data.byteLength;
                } else {
                  data = xhr.responseText;
                  len = data.length;
                }
                stats.loaded = stats.total = len;
                var response = { url: xhr.responseURL, data: data };
                this.callbacks.onSuccess(response, stats, context);
              } else {
                // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error
                if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
                  _logger.logger.error(status + ' while loading ' + context.url);
                  this.callbacks.onError({ code: status, text: xhr.statusText }, context);
                } else {
                  // retry
                  _logger.logger.warn(status + ' while loading ' + context.url + ', retrying in ' + this.retryDelay + '...');
                  // aborts and resets internal state
                  this.destroy();
                  // schedule retry
                  this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
                  // set exponential backoff
                  this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
                  stats.retry++;
                }
              }
            } else {
              // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet
              this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
            }
          }
        }
      }, {
        key: 'loadtimeout',
        value: function loadtimeout() {
          _logger.logger.warn('timeout while loading ' + this.context.url);
          this.callbacks.onTimeout(this.stats, this.context);
        }
      }, {
        key: 'loadprogress',
        value: function loadprogress(event) {
          var stats = this.stats;
          stats.loaded = event.loaded;
          if (event.lengthComputable) {
            stats.total = event.total;
          }
          var onProgress = this.callbacks.onProgress;
          if (onProgress) {
            // last args is to provide on progress data
            onProgress(stats, this.context, null);
          }
        }
      }]);
    
      return XhrLoader;
    }();
    
    exports.default = XhrLoader;
    
    },{"51":51}]},{},[38])(38)
    });
    //# sourceMappingURL=hls.js.map
"object"==typeof navigator&&function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define("Plyr",t):(e=e||self).Plyr=t()}(this,(function(){"use strict";function e(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function t(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function i(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}function n(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function a(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function s(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?a(Object(i),!0).forEach((function(t){n(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function r(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var i=[],n=!0,a=!1,s=void 0;try{for(var r,o=e[Symbol.iterator]();!(n=(r=o.next()).done)&&(i.push(r.value),!t||i.length!==t);n=!0);}catch(e){a=!0,s=e}finally{try{n||null==o.return||o.return()}finally{if(a)throw s}}return i}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function o(e){return function(e){if(Array.isArray(e)){for(var t=0,i=new Array(e.length);t<e.length;t++)i[t]=e[t];return i}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}var l={addCSS:!0,thumbWidth:15,watch:!0};function c(e,t){return function(){return Array.from(document.querySelectorAll(t)).includes(this)}.call(e,t)}var u=function(e){return null!=e?e.constructor:null},d=function(e,t){return Boolean(e&&t&&e instanceof t)},h=function(e){return null==e},p=function(e){return u(e)===Object},m=function(e){return u(e)===String},f=function(e){return Array.isArray(e)},g=function(e){return d(e,NodeList)},y=m,v=f,b=g,w=function(e){return d(e,Element)},k=function(e){return d(e,Event)},T=function(e){return h(e)||(m(e)||f(e)||g(e))&&!e.length||p(e)&&!Object.keys(e).length};function C(e,t){if(t<1){var i=(n="".concat(t).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/))?Math.max(0,(n[1]?n[1].length:0)-(n[2]?+n[2]:0)):0;return parseFloat(e.toFixed(i))}var n;return Math.round(e/t)*t}var A,E,S,P=function(){function t(i,n){e(this,t),w(i)?this.element=i:y(i)&&(this.element=document.querySelector(i)),w(this.element)&&T(this.element.rangeTouch)&&(this.config=Object.assign({},l,n),this.init())}return i(t,[{key:"init",value:function(){t.enabled&&(this.config.addCSS&&(this.element.style.userSelect="none",this.element.style.webKitUserSelect="none",this.element.style.touchAction="manipulation"),this.listeners(!0),this.element.rangeTouch=this)}},{key:"destroy",value:function(){t.enabled&&(this.listeners(!1),this.element.rangeTouch=null)}},{key:"listeners",value:function(e){var t=this,i=e?"addEventListener":"removeEventListener";["touchstart","touchmove","touchend"].forEach((function(e){t.element[i](e,(function(e){return t.set(e)}),!1)}))}},{key:"get",value:function(e){if(!t.enabled||!k(e))return null;var i,n=e.target,a=e.changedTouches[0],s=parseFloat(n.getAttribute("min"))||0,r=parseFloat(n.getAttribute("max"))||100,o=parseFloat(n.getAttribute("step"))||1,l=r-s,c=n.getBoundingClientRect(),u=100/c.width*(this.config.thumbWidth/2)/100;return(i=100/c.width*(a.clientX-c.left))<0?i=0:i>100&&(i=100),i<50?i-=(100-2*i)*u:i>50&&(i+=2*(i-50)*u),s+C(l*(i/100),o)}},{key:"set",value:function(e){t.enabled&&k(e)&&!e.target.disabled&&(e.preventDefault(),e.target.value=this.get(e),function(e,t){if(e&&t){var i=new Event(t);e.dispatchEvent(i)}}(e.target,"touchend"===e.type?"change":"input"))}}],[{key:"setup",value:function(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=null;if(T(e)||y(e)?n=Array.from(document.querySelectorAll(y(e)?e:'input[type="range"]')):w(e)?n=[e]:b(e)?n=Array.from(e):v(e)&&(n=e.filter(w)),T(n))return null;var a=Object.assign({},l,i);if(y(e)&&a.watch){var s=new MutationObserver((function(i){Array.from(i).forEach((function(i){Array.from(i.addedNodes).forEach((function(i){if(w(i)&&c(i,e))new t(i,a)}))}))}));s.observe(document.body,{childList:!0,subtree:!0})}return n.map((function(e){return new t(e,i)}))}},{key:"enabled",get:function(){return"ontouchstart"in document.documentElement}}]),t}(),M=function(e){return null!=e?e.constructor:null},N=function(e,t){return Boolean(e&&t&&e instanceof t)},x=function(e){return null==e},I=function(e){return M(e)===Object},L=function(e){return M(e)===String},_=function(e){return Array.isArray(e)},O=function(e){return N(e,NodeList)},j=function(e){return x(e)||(L(e)||_(e)||O(e))&&!e.length||I(e)&&!Object.keys(e).length},q=x,H=I,D=function(e){return M(e)===Number&&!Number.isNaN(e)},F=L,R=function(e){return M(e)===Boolean},V=function(e){return M(e)===Function},B=_,U=O,W=function(e){return N(e,Element)},z=function(e){return N(e,Event)},K=function(e){return N(e,KeyboardEvent)},Y=function(e){return N(e,TextTrack)||!x(e)&&L(e.kind)},Q=function(e){if(N(e,window.URL))return!0;if(!L(e))return!1;var t=e;e.startsWith("http://")&&e.startsWith("https://")||(t="http://".concat(e));try{return!j(new URL(t).hostname)}catch(e){return!1}},X=j,J=(A=document.createElement("span"),E={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"},S=Object.keys(E).find((function(e){return void 0!==A.style[e]})),!!F(S)&&E[S]);function $(e,t){setTimeout((function(){try{e.hidden=!0,e.offsetHeight,e.hidden=!1}catch(e){}}),t)}var G={isIE:
/* @cc_on!@ */
!!document.documentMode,isEdge:window.navigator.userAgent.includes("Edge"),isWebkit:"WebkitAppearance"in document.documentElement.style&&!/Edge/.test(navigator.userAgent),isIPhone:/(iPhone|iPod)/gi.test(navigator.platform),isIos:/(iPad|iPhone|iPod)/gi.test(navigator.platform)};function Z(e,t){return t.split(".").reduce((function(e,t){return e&&e[t]}),e)}function ee(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length,i=new Array(t>1?t-1:0),a=1;a<t;a++)i[a-1]=arguments[a];if(!i.length)return e;var s=i.shift();return H(s)?(Object.keys(s).forEach((function(t){H(s[t])?(Object.keys(e).includes(t)||Object.assign(e,n({},t,{})),ee(e[t],s[t])):Object.assign(e,n({},t,s[t]))})),ee.apply(void 0,[e].concat(i))):e}function te(e,t){var i=e.length?e:[e];Array.from(i).reverse().forEach((function(e,i){var n=i>0?t.cloneNode(!0):t,a=e.parentNode,s=e.nextSibling;n.appendChild(e),s?a.insertBefore(n,s):a.appendChild(n)}))}function ie(e,t){W(e)&&!X(t)&&Object.entries(t).filter((function(e){var t=r(e,2)[1];return!q(t)})).forEach((function(t){var i=r(t,2),n=i[0],a=i[1];return e.setAttribute(n,a)}))}function ne(e,t,i){var n=document.createElement(e);return H(t)&&ie(n,t),F(i)&&(n.innerText=i),n}function ae(e,t,i,n){W(t)&&t.appendChild(ne(e,i,n))}function se(e){U(e)||B(e)?Array.from(e).forEach(se):W(e)&&W(e.parentNode)&&e.parentNode.removeChild(e)}function re(e){if(W(e))for(var t=e.childNodes.length;t>0;)e.removeChild(e.lastChild),t-=1}function oe(e,t){return W(t)&&W(t.parentNode)&&W(e)?(t.parentNode.replaceChild(e,t),e):null}function le(e,t){if(!F(e)||X(e))return{};var i={},n=ee({},t);return e.split(",").forEach((function(e){var t=e.trim(),a=t.replace(".",""),s=t.replace(/[[\]]/g,"").split("="),o=r(s,1)[0],l=s.length>1?s[1].replace(/["']/g,""):"";switch(t.charAt(0)){case".":F(n.class)?i.class="".concat(n.class," ").concat(a):i.class=a;break;case"#":i.id=t.replace("#","");break;case"[":i[o]=l}})),ee(n,i)}function ce(e,t){if(W(e)){var i=t;R(i)||(i=!e.hidden),e.hidden=i}}function ue(e,t,i){if(U(e))return Array.from(e).map((function(e){return ue(e,t,i)}));if(W(e)){var n="toggle";return void 0!==i&&(n=i?"add":"remove"),e.classList[n](t),e.classList.contains(t)}return!1}function de(e,t){return W(e)&&e.classList.contains(t)}function he(e,t){return function(){return Array.from(document.querySelectorAll(t)).includes(this)}.call(e,t)}function pe(e){return this.elements.container.querySelectorAll(e)}function me(e){return this.elements.container.querySelector(e)}function fe(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];W(e)&&(e.focus({preventScroll:!0}),t&&ue(e,this.config.classNames.tabFocus))}var ge,ye={"audio/ogg":"vorbis","audio/wav":"1","video/webm":"vp8, vorbis","video/mp4":"avc1.42E01E, mp4a.40.2","video/ogg":"theora"},ve={audio:"canPlayType"in document.createElement("audio"),video:"canPlayType"in document.createElement("video"),check:function(e,t,i){var n=G.isIPhone&&i&&ve.playsinline,a=ve[e]||"html5"!==t;return{api:a,ui:a&&ve.rangeInput&&("video"!==e||!G.isIPhone||n)}},pip:!(G.isIPhone||!V(ne("video").webkitSetPresentationMode)&&(!document.pictureInPictureEnabled||ne("video").disablePictureInPicture)),airplay:V(window.WebKitPlaybackTargetAvailabilityEvent),playsinline:"playsInline"in document.createElement("video"),mime:function(e){if(X(e))return!1;var t=r(e.split("/"),1)[0],i=e;if(!this.isHTML5||t!==this.type)return!1;Object.keys(ye).includes(i)&&(i+='; codecs="'.concat(ye[e],'"'));try{return Boolean(i&&this.media.canPlayType(i).replace(/no/,""))}catch(e){return!1}},textTracks:"textTracks"in document.createElement("video"),rangeInput:(ge=document.createElement("input"),ge.type="range","range"===ge.type),touch:"ontouchstart"in document.documentElement,transitions:!1!==J,reducedMotion:"matchMedia"in window&&window.matchMedia("(prefers-reduced-motion)").matches},be=function(){var e=!1;try{var t=Object.defineProperty({},"passive",{get:function(){return e=!0,null}});window.addEventListener("test",null,t),window.removeEventListener("test",null,t)}catch(e){}return e}();function we(e,t,i){var n=this,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=arguments.length>5&&void 0!==arguments[5]&&arguments[5];if(e&&"addEventListener"in e&&!X(t)&&V(i)){var o=t.split(" "),l=r;be&&(l={passive:s,capture:r}),o.forEach((function(t){n&&n.eventListeners&&a&&n.eventListeners.push({element:e,type:t,callback:i,options:l}),e[a?"addEventListener":"removeEventListener"](t,i,l)}))}}function ke(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",i=arguments.length>2?arguments[2]:void 0,n=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];we.call(this,e,t,i,!0,n,a)}function Te(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",i=arguments.length>2?arguments[2]:void 0,n=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];we.call(this,e,t,i,!1,n,a)}function Ce(e){var t=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=function r(){Te(e,i,r,a,s);for(var o=arguments.length,l=new Array(o),c=0;c<o;c++)l[c]=arguments[c];n.apply(t,l)};we.call(this,e,i,r,!0,a,s)}function Ae(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(W(e)&&!X(t)){var a=new CustomEvent(t,{bubbles:i,detail:s({},n,{plyr:this})});e.dispatchEvent(a)}}function Ee(){this&&this.eventListeners&&(this.eventListeners.forEach((function(e){var t=e.element,i=e.type,n=e.callback,a=e.options;t.removeEventListener(i,n,a)})),this.eventListeners=[])}function Se(){var e=this;return new Promise((function(t){return e.ready?setTimeout(t,0):ke.call(e,e.elements.container,"ready",t)})).then((function(){}))}function Pe(e){return!!(B(e)||F(e)&&e.includes(":"))&&(B(e)?e:e.split(":")).map(Number).every(D)}function Me(e){if(!B(e)||!e.every(D))return null;var t=r(e,2),i=t[0],n=t[1],a=function e(t,i){return 0===i?t:e(i,t%i)}(i,n);return[i/a,n/a]}function Ne(e){var t=function(e){return Pe(e)?e.split(":").map(Number):null},i=t(e);if(null===i&&(i=t(this.config.ratio)),null===i&&!X(this.embed)&&B(this.embed.ratio)&&(i=this.embed.ratio),null===i&&this.isHTML5){var n=this.media;i=Me([n.videoWidth,n.videoHeight])}return i}function xe(e){if(!this.isVideo)return{};var t=this.elements.wrapper,i=Ne.call(this,e),n=r(B(i)?i:[0,0],2),a=100/n[0]*n[1];if(t.style.paddingBottom="".concat(a,"%"),this.isVimeo&&this.supported.ui){var s=(240-a)/4.8;this.media.style.transform="translateY(-".concat(s,"%)")}else this.isHTML5&&t.classList.toggle(this.config.classNames.videoFixedRatio,null!==i);return{padding:a,ratio:i}}var Ie={getSources:function(){var e=this;return this.isHTML5?Array.from(this.media.querySelectorAll("source")).filter((function(t){var i=t.getAttribute("type");return!!X(i)||ve.mime.call(e,i)})):[]},getQualityOptions:function(){return this.config.quality.forced?this.config.quality.options:Ie.getSources.call(this).map((function(e){return Number(e.getAttribute("size"))})).filter(Boolean)},setup:function(){if(this.isHTML5){var e=this;e.options.speed=e.config.speed.options,X(this.config.ratio)||xe.call(e),Object.defineProperty(e.media,"quality",{get:function(){var t=Ie.getSources.call(e).find((function(t){return t.getAttribute("src")===e.source}));return t&&Number(t.getAttribute("size"))},set:function(t){if(e.quality!==t){if(e.config.quality.forced&&V(e.config.quality.onChange))e.config.quality.onChange(t);else{var i=Ie.getSources.call(e).find((function(e){return Number(e.getAttribute("size"))===t}));if(!i)return;var n=e.media,a=n.currentTime,s=n.paused,r=n.preload,o=n.readyState,l=n.playbackRate;e.media.src=i.getAttribute("src"),("none"!==r||o)&&(e.once("loadedmetadata",(function(){e.speed=l,e.currentTime=a,s||e.play()})),e.media.load())}Ae.call(e,e.media,"qualitychange",!1,{quality:t})}}})}},cancelRequests:function(){this.isHTML5&&(se(Ie.getSources.call(this)),this.media.setAttribute("src",this.config.blankVideo),this.media.load(),this.debug.log("Cancelled network requests"))}};function Le(e){return B(e)?e.filter((function(t,i){return e.indexOf(t)===i})):e}function _e(e){for(var t=arguments.length,i=new Array(t>1?t-1:0),n=1;n<t;n++)i[n-1]=arguments[n];return X(e)?e:e.toString().replace(/{(\d+)}/g,(function(e,t){return i[t].toString()}))}function Oe(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return e.replace(new RegExp(t.toString().replace(/([.*+?^=!:${}()|[\]/\\])/g,"\\$1"),"g"),i.toString())}function je(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e.toString().replace(/\w\S*/g,(function(e){return e.charAt(0).toUpperCase()+e.substr(1).toLowerCase()}))}function qe(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=e.toString();return t=Oe(t,"-"," "),t=Oe(t,"_"," "),Oe(t=je(t)," ","")}function He(e){var t=document.createElement("div");return t.appendChild(e),t.innerHTML}var De={pip:"PIP",airplay:"AirPlay",html5:"HTML5",vimeo:"Vimeo",youtube:"YouTube"},Fe=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(X(e)||X(t))return"";var i=Z(t.i18n,e);if(X(i))return Object.keys(De).includes(e)?De[e]:"";var n={"{seektime}":t.seekTime,"{title}":t.title};return Object.entries(n).forEach((function(e){var t=r(e,2),n=t[0],a=t[1];i=Oe(i,n,a)})),i},Re=function(){function t(i){e(this,t),this.enabled=i.config.storage.enabled,this.key=i.config.storage.key}return i(t,[{key:"get",value:function(e){if(!t.supported||!this.enabled)return null;var i=window.localStorage.getItem(this.key);if(X(i))return null;var n=JSON.parse(i);return F(e)&&e.length?n[e]:n}},{key:"set",value:function(e){if(t.supported&&this.enabled&&H(e)){var i=this.get();X(i)&&(i={}),ee(i,e),window.localStorage.setItem(this.key,JSON.stringify(i))}}}],[{key:"supported",get:function(){try{if(!("localStorage"in window))return!1;return window.localStorage.setItem("___test","___test"),window.localStorage.removeItem("___test"),!0}catch(e){return!1}}}]),t}();function Ve(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"text";return new Promise((function(i,n){try{var a=new XMLHttpRequest;if(!("withCredentials"in a))return;a.addEventListener("load",(function(){if("text"===t)try{i(JSON.parse(a.responseText))}catch(e){i(a.responseText)}else i(a.response)})),a.addEventListener("error",(function(){throw new Error(a.status)})),a.open("GET",e,!0),a.responseType=t,a.send()}catch(e){n(e)}}))}function Be(e,t){if(F(e)){var i=F(t),n=function(){return null!==document.getElementById(t)},a=function(e,t){e.innerHTML=t,i&&n()||document.body.insertAdjacentElement("afterbegin",e)};if(!i||!n()){var s=Re.supported,r=document.createElement("div");if(r.setAttribute("hidden",""),i&&r.setAttribute("id",t),s){var o=window.localStorage.getItem("".concat("cache","-").concat(t));if(null!==o){var l=JSON.parse(o);a(r,l.content)}}Ve(e).then((function(e){X(e)||(s&&window.localStorage.setItem("".concat("cache","-").concat(t),JSON.stringify({content:e})),a(r,e))})).catch((function(){}))}}}var Ue=function(e){return Math.trunc(e/60/60%60,10)},We=function(e){return Math.trunc(e/60%60,10)},ze=function(e){return Math.trunc(e%60,10)};function Ke(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!D(e))return Ke(void 0,t,i);var n=function(e){return"0".concat(e).slice(-2)},a=Ue(e),s=We(e),r=ze(e);return a=t||a>0?"".concat(a,":"):"","".concat(i&&e>0?"-":"").concat(a).concat(n(s),":").concat(n(r))}var Ye={getIconUrl:function(){var e=new URL(this.config.iconUrl,window.location).host!==window.location.host||G.isIE&&!window.svg4everybody;return{url:this.config.iconUrl,cors:e}},findElements:function(){try{return this.elements.controls=me.call(this,this.config.selectors.controls.wrapper),this.elements.buttons={play:pe.call(this,this.config.selectors.buttons.play),pause:me.call(this,this.config.selectors.buttons.pause),restart:me.call(this,this.config.selectors.buttons.restart),rewind:me.call(this,this.config.selectors.buttons.rewind),fastForward:me.call(this,this.config.selectors.buttons.fastForward),mute:me.call(this,this.config.selectors.buttons.mute),pip:me.call(this,this.config.selectors.buttons.pip),airplay:me.call(this,this.config.selectors.buttons.airplay),settings:me.call(this,this.config.selectors.buttons.settings),captions:me.call(this,this.config.selectors.buttons.captions),fullscreen:me.call(this,this.config.selectors.buttons.fullscreen)},this.elements.progress=me.call(this,this.config.selectors.progress),this.elements.inputs={seek:me.call(this,this.config.selectors.inputs.seek),volume:me.call(this,this.config.selectors.inputs.volume)},this.elements.display={buffer:me.call(this,this.config.selectors.display.buffer),currentTime:me.call(this,this.config.selectors.display.currentTime),duration:me.call(this,this.config.selectors.display.duration)},W(this.elements.progress)&&(this.elements.display.seekTooltip=this.elements.progress.querySelector(".".concat(this.config.classNames.tooltip))),!0}catch(e){return this.debug.warn("It looks like there is a problem with your custom controls HTML",e),this.toggleNativeControls(!0),!1}},createIcon:function(e,t){var i=Ye.getIconUrl.call(this),n="".concat(i.cors?"":i.url,"#").concat(this.config.iconPrefix),a=document.createElementNS("http://www.w3.org/2000/svg","svg");ie(a,ee(t,{role:"presentation",focusable:"false"}));var s=document.createElementNS("http://www.w3.org/2000/svg","use"),r="".concat(n,"-").concat(e);return"href"in s&&s.setAttributeNS("http://www.w3.org/1999/xlink","href",r),s.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",r),a.appendChild(s),a},createLabel:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=Fe(e,this.config),n=s({},t,{class:[t.class,this.config.classNames.hidden].filter(Boolean).join(" ")});return ne("span",n,i)},createBadge:function(e){if(X(e))return null;var t=ne("span",{class:this.config.classNames.menu.value});return t.appendChild(ne("span",{class:this.config.classNames.menu.badge},e)),t},createButton:function(e,t){var i=this,n=ee({},t),a=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=e.toString();return(t=qe(t)).charAt(0).toLowerCase()+t.slice(1)}(e),s={element:"button",toggle:!1,label:null,icon:null,labelPressed:null,iconPressed:null};switch(["element","icon","label"].forEach((function(e){Object.keys(n).includes(e)&&(s[e]=n[e],delete n[e])})),"button"!==s.element||Object.keys(n).includes("type")||(n.type="button"),Object.keys(n).includes("class")?n.class.split(" ").some((function(e){return e===i.config.classNames.control}))||ee(n,{class:"".concat(n.class," ").concat(this.config.classNames.control)}):n.class=this.config.classNames.control,e){case"play":s.toggle=!0,s.label="play",s.labelPressed="pause",s.icon="play",s.iconPressed="pause";break;case"mute":s.toggle=!0,s.label="mute",s.labelPressed="unmute",s.icon="volume",s.iconPressed="muted";break;case"captions":s.toggle=!0,s.label="enableCaptions",s.labelPressed="disableCaptions",s.icon="captions-off",s.iconPressed="captions-on";break;case"fullscreen":s.toggle=!0,s.label="enterFullscreen",s.labelPressed="exitFullscreen",s.icon="enter-fullscreen",s.iconPressed="exit-fullscreen";break;case"play-large":n.class+=" ".concat(this.config.classNames.control,"--overlaid"),a="play",s.label="play",s.icon="play";break;default:X(s.label)&&(s.label=a),X(s.icon)&&(s.icon=e)}var r=ne(s.element);return s.toggle?(r.appendChild(Ye.createIcon.call(this,s.iconPressed,{class:"icon--pressed"})),r.appendChild(Ye.createIcon.call(this,s.icon,{class:"icon--not-pressed"})),r.appendChild(Ye.createLabel.call(this,s.labelPressed,{class:"label--pressed"})),r.appendChild(Ye.createLabel.call(this,s.label,{class:"label--not-pressed"}))):(r.appendChild(Ye.createIcon.call(this,s.icon)),r.appendChild(Ye.createLabel.call(this,s.label))),ee(n,le(this.config.selectors.buttons[a],n)),ie(r,n),"play"===a?(B(this.elements.buttons[a])||(this.elements.buttons[a]=[]),this.elements.buttons[a].push(r)):this.elements.buttons[a]=r,r},createRange:function(e,t){var i=ne("input",ee(le(this.config.selectors.inputs[e]),{type:"range",min:0,max:100,step:.01,value:0,autocomplete:"off",role:"slider","aria-label":Fe(e,this.config),"aria-valuemin":0,"aria-valuemax":100,"aria-valuenow":0},t));return this.elements.inputs[e]=i,Ye.updateRangeFill.call(this,i),P.setup(i),i},createProgress:function(e,t){var i=ne("progress",ee(le(this.config.selectors.display[e]),{min:0,max:100,value:0,role:"progressbar","aria-hidden":!0},t));if("volume"!==e){i.appendChild(ne("span",null,"0"));var n={played:"played",buffer:"buffered"}[e],a=n?Fe(n,this.config):"";i.innerText="% ".concat(a.toLowerCase())}return this.elements.display[e]=i,i},createTime:function(e,t){var i=le(this.config.selectors.display[e],t),n=ne("div",ee(i,{class:"".concat(i.class?i.class:""," ").concat(this.config.classNames.display.time," ").trim(),"aria-label":Fe(e,this.config)}),"00:00");return this.elements.display[e]=n,n},bindMenuItemShortcuts:function(e,t){var i=this;ke.call(this,e,"keydown keyup",(function(n){if([32,38,39,40].includes(n.which)&&(n.preventDefault(),n.stopPropagation(),"keydown"!==n.type)){var a,s=he(e,'[role="menuitemradio"]');if(!s&&[32,39].includes(n.which))Ye.showMenuPanel.call(i,t,!0);else 32!==n.which&&(40===n.which||s&&39===n.which?(a=e.nextElementSibling,W(a)||(a=e.parentNode.firstElementChild)):(a=e.previousElementSibling,W(a)||(a=e.parentNode.lastElementChild)),fe.call(i,a,!0))}}),!1),ke.call(this,e,"keyup",(function(e){13===e.which&&Ye.focusFirstMenuItem.call(i,null,!0)}))},createMenuItem:function(e){var t=this,i=e.value,n=e.list,a=e.type,s=e.title,r=e.badge,o=void 0===r?null:r,l=e.checked,c=void 0!==l&&l,u=le(this.config.selectors.inputs[a]),d=ne("button",ee(u,{type:"button",role:"menuitemradio",class:"".concat(this.config.classNames.control," ").concat(u.class?u.class:"").trim(),"aria-checked":c,value:i})),h=ne("span");h.innerHTML=s,W(o)&&h.appendChild(o),d.appendChild(h),Object.defineProperty(d,"checked",{enumerable:!0,get:function(){return"true"===d.getAttribute("aria-checked")},set:function(e){e&&Array.from(d.parentNode.children).filter((function(e){return he(e,'[role="menuitemradio"]')})).forEach((function(e){return e.setAttribute("aria-checked","false")})),d.setAttribute("aria-checked",e?"true":"false")}}),this.listeners.bind(d,"click keyup",(function(e){if(!K(e)||32===e.which){switch(e.preventDefault(),e.stopPropagation(),d.checked=!0,a){case"language":t.currentTrack=Number(i);break;case"quality":t.quality=i;break;case"speed":t.speed=parseFloat(i)}Ye.showMenuPanel.call(t,"home",K(e))}}),a,!1),Ye.bindMenuItemShortcuts.call(this,d,a),n.appendChild(d)},formatTime:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!D(e))return e;var i=Ue(this.duration)>0;return Ke(e,i,t)},updateTimeDisplay:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];W(e)&&D(t)&&(e.innerText=Ye.formatTime(t,i))},updateVolume:function(){this.supported.ui&&(W(this.elements.inputs.volume)&&Ye.setRange.call(this,this.elements.inputs.volume,this.muted?0:this.volume),W(this.elements.buttons.mute)&&(this.elements.buttons.mute.pressed=this.muted||0===this.volume))},setRange:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;W(e)&&(e.value=t,Ye.updateRangeFill.call(this,e))},updateProgress:function(e){var t=this;if(this.supported.ui&&z(e)){var i,n,a=0;if(e)switch(e.type){case"timeupdate":case"seeking":case"seeked":i=this.currentTime,n=this.duration,a=0===i||0===n||Number.isNaN(i)||Number.isNaN(n)?0:(i/n*100).toFixed(2),"timeupdate"===e.type&&Ye.setRange.call(this,this.elements.inputs.seek,a);break;case"playing":case"progress":!function(e,i){var n=D(i)?i:0,a=W(e)?e:t.elements.display.buffer;if(W(a)){a.value=n;var s=a.getElementsByTagName("span")[0];W(s)&&(s.childNodes[0].nodeValue=n)}}(this.elements.display.buffer,100*this.buffered)}}},updateRangeFill:function(e){var t=z(e)?e.target:e;if(W(t)&&"range"===t.getAttribute("type")){if(he(t,this.config.selectors.inputs.seek)){t.setAttribute("aria-valuenow",this.currentTime);var i=Ye.formatTime(this.currentTime),n=Ye.formatTime(this.duration),a=Fe("seekLabel",this.config);t.setAttribute("aria-valuetext",a.replace("{currentTime}",i).replace("{duration}",n))}else if(he(t,this.config.selectors.inputs.volume)){var s=100*t.value;t.setAttribute("aria-valuenow",s),t.setAttribute("aria-valuetext","".concat(s.toFixed(1),"%"))}else t.setAttribute("aria-valuenow",t.value);G.isWebkit&&t.style.setProperty("--value","".concat(t.value/t.max*100,"%"))}},updateSeekTooltip:function(e){var t=this;if(this.config.tooltips.seek&&W(this.elements.inputs.seek)&&W(this.elements.display.seekTooltip)&&0!==this.duration){var i="".concat(this.config.classNames.tooltip,"--visible"),n=function(e){return ue(t.elements.display.seekTooltip,i,e)};if(this.touch)n(!1);else{var a=0,s=this.elements.progress.getBoundingClientRect();if(z(e))a=100/s.width*(e.pageX-s.left);else{if(!de(this.elements.display.seekTooltip,i))return;a=parseFloat(this.elements.display.seekTooltip.style.left,10)}a<0?a=0:a>100&&(a=100),Ye.updateTimeDisplay.call(this,this.elements.display.seekTooltip,this.duration/100*a),this.elements.display.seekTooltip.style.left="".concat(a,"%"),z(e)&&["mouseenter","mouseleave"].includes(e.type)&&n("mouseenter"===e.type)}}},timeUpdate:function(e){var t=!W(this.elements.display.duration)&&this.config.invertTime;Ye.updateTimeDisplay.call(this,this.elements.display.currentTime,t?this.duration-this.currentTime:this.currentTime,t),e&&"timeupdate"===e.type&&this.media.seeking||Ye.updateProgress.call(this,e)},durationUpdate:function(){if(this.supported.ui&&(this.config.invertTime||!this.currentTime)){if(this.duration>=Math.pow(2,32))return ce(this.elements.display.currentTime,!0),void ce(this.elements.progress,!0);W(this.elements.inputs.seek)&&this.elements.inputs.seek.setAttribute("aria-valuemax",this.duration);var e=W(this.elements.display.duration);!e&&this.config.displayDuration&&this.paused&&Ye.updateTimeDisplay.call(this,this.elements.display.currentTime,this.duration),e&&Ye.updateTimeDisplay.call(this,this.elements.display.duration,this.duration),Ye.updateSeekTooltip.call(this)}},toggleMenuButton:function(e,t){ce(this.elements.settings.buttons[e],!t)},updateSetting:function(e,t,i){var n=this.elements.settings.panels[e],a=null,s=t;if("captions"===e)a=this.currentTrack;else{if(a=X(i)?this[e]:i,X(a)&&(a=this.config[e].default),!X(this.options[e])&&!this.options[e].includes(a))return void this.debug.warn("Unsupported value of '".concat(a,"' for ").concat(e));if(!this.config[e].options.includes(a))return void this.debug.warn("Disabled value of '".concat(a,"' for ").concat(e))}if(W(s)||(s=n&&n.querySelector('[role="menu"]')),W(s)){this.elements.settings.buttons[e].querySelector(".".concat(this.config.classNames.menu.value)).innerHTML=Ye.getLabel.call(this,e,a);var r=s&&s.querySelector('[value="'.concat(a,'"]'));W(r)&&(r.checked=!0)}},getLabel:function(e,t){switch(e){case"speed":return 1===t?Fe("normal",this.config):"".concat(t,"&times;");case"quality":if(D(t)){var i=Fe("qualityLabel.".concat(t),this.config);return i.length?i:"".concat(t,"p")}return je(t);case"captions":return Je.getLabel.call(this);default:return null}},setQualityMenu:function(e){var t=this;if(W(this.elements.settings.panels.quality)){var i=this.elements.settings.panels.quality.querySelector('[role="menu"]');B(e)&&(this.options.quality=Le(e).filter((function(e){return t.config.quality.options.includes(e)})));var n=!X(this.options.quality)&&this.options.quality.length>1;if(Ye.toggleMenuButton.call(this,"quality",n),re(i),Ye.checkMenu.call(this),n){var a=function(e){var i=Fe("qualityBadge.".concat(e),t.config);return i.length?Ye.createBadge.call(t,i):null};this.options.quality.sort((function(e,i){var n=t.config.quality.options;return n.indexOf(e)>n.indexOf(i)?1:-1})).forEach((function(e){Ye.createMenuItem.call(t,{value:e,list:i,type:"quality",title:Ye.getLabel.call(t,"quality",e),badge:a(e)})})),Ye.updateSetting.call(this,"quality",i)}}},setCaptionsMenu:function(){var e=this;if(W(this.elements.settings.panels.captions)){var t=this.elements.settings.panels.captions.querySelector('[role="menu"]'),i=Je.getTracks.call(this),n=Boolean(i.length);if(Ye.toggleMenuButton.call(this,"captions",n),re(t),Ye.checkMenu.call(this),n){var a=i.map((function(i,n){return{value:n,checked:e.captions.toggled&&e.currentTrack===n,title:Je.getLabel.call(e,i),badge:i.language&&Ye.createBadge.call(e,i.language.toUpperCase()),list:t,type:"language"}}));a.unshift({value:-1,checked:!this.captions.toggled,title:Fe("disabled",this.config),list:t,type:"language"}),a.forEach(Ye.createMenuItem.bind(this)),Ye.updateSetting.call(this,"captions",t)}}},setSpeedMenu:function(){var e=this;if(W(this.elements.settings.panels.speed)){var t=this.elements.settings.panels.speed.querySelector('[role="menu"]');this.options.speed=this.options.speed.filter((function(t){return t>=e.minimumSpeed&&t<=e.maximumSpeed}));var i=!X(this.options.speed)&&this.options.speed.length>1;Ye.toggleMenuButton.call(this,"speed",i),re(t),Ye.checkMenu.call(this),i&&(this.options.speed.forEach((function(i){Ye.createMenuItem.call(e,{value:i,list:t,type:"speed",title:Ye.getLabel.call(e,"speed",i)})})),Ye.updateSetting.call(this,"speed",t))}},checkMenu:function(){var e=this.elements.settings.buttons,t=!X(e)&&Object.values(e).some((function(e){return!e.hidden}));ce(this.elements.settings.menu,!t)},focusFirstMenuItem:function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this.elements.settings.popup.hidden){var i=e;W(i)||(i=Object.values(this.elements.settings.panels).find((function(e){return!e.hidden})));var n=i.querySelector('[role^="menuitem"]');fe.call(this,n,t)}},toggleMenu:function(e){var t=this.elements.settings.popup,i=this.elements.buttons.settings;if(W(t)&&W(i)){var n=t.hidden,a=n;if(R(e))a=e;else if(K(e)&&27===e.which)a=!1;else if(z(e)){var s=V(e.composedPath)?e.composedPath()[0]:e.target,r=t.contains(s);if(r||!r&&e.target!==i&&a)return}i.setAttribute("aria-expanded",a),ce(t,!a),ue(this.elements.container,this.config.classNames.menu.open,a),a&&K(e)?Ye.focusFirstMenuItem.call(this,null,!0):a||n||fe.call(this,i,K(e))}},getMenuSize:function(e){var t=e.cloneNode(!0);t.style.position="absolute",t.style.opacity=0,t.removeAttribute("hidden"),e.parentNode.appendChild(t);var i=t.scrollWidth,n=t.scrollHeight;return se(t),{width:i,height:n}},showMenuPanel:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=this.elements.container.querySelector("#plyr-settings-".concat(this.id,"-").concat(t));if(W(n)){var a=n.parentNode,s=Array.from(a.children).find((function(e){return!e.hidden}));if(ve.transitions&&!ve.reducedMotion){a.style.width="".concat(s.scrollWidth,"px"),a.style.height="".concat(s.scrollHeight,"px");var r=Ye.getMenuSize.call(this,n),o=function t(i){i.target===a&&["width","height"].includes(i.propertyName)&&(a.style.width="",a.style.height="",Te.call(e,a,J,t))};ke.call(this,a,J,o),a.style.width="".concat(r.width,"px"),a.style.height="".concat(r.height,"px")}ce(s,!0),ce(n,!1),Ye.focusFirstMenuItem.call(this,n,i)}},setDownloadUrl:function(){var e=this.elements.buttons.download;W(e)&&e.setAttribute("href",this.download)},create:function(e){var t=this,i=Ye.bindMenuItemShortcuts,n=Ye.createButton,a=Ye.createProgress,s=Ye.createRange,r=Ye.createTime,o=Ye.setQualityMenu,l=Ye.setSpeedMenu,c=Ye.showMenuPanel;this.elements.controls=null,this.config.controls.includes("play-large")&&this.elements.container.appendChild(n.call(this,"play-large"));var u=ne("div",le(this.config.selectors.controls.wrapper));this.elements.controls=u;var d={class:"plyr__controls__item"};return Le(this.config.controls).forEach((function(o){if("restart"===o&&u.appendChild(n.call(t,"restart",d)),"rewind"===o&&u.appendChild(n.call(t,"rewind",d)),"play"===o&&u.appendChild(n.call(t,"play",d)),"fast-forward"===o&&u.appendChild(n.call(t,"fast-forward",d)),"progress"===o){var l=ne("div",{class:"".concat(d.class," plyr__progress__container")}),h=ne("div",le(t.config.selectors.progress));if(h.appendChild(s.call(t,"seek",{id:"plyr-seek-".concat(e.id)})),h.appendChild(a.call(t,"buffer")),t.config.tooltips.seek){var p=ne("span",{class:t.config.classNames.tooltip},"00:00");h.appendChild(p),t.elements.display.seekTooltip=p}t.elements.progress=h,l.appendChild(t.elements.progress),u.appendChild(l)}if("current-time"===o&&u.appendChild(r.call(t,"currentTime",d)),"duration"===o&&u.appendChild(r.call(t,"duration",d)),"mute"===o||"volume"===o){var m=t.elements.volume;if(W(m)&&u.contains(m)||(m=ne("div",ee({},d,{class:"".concat(d.class," plyr__volume").trim()})),t.elements.volume=m,u.appendChild(m)),"mute"===o&&m.appendChild(n.call(t,"mute")),"volume"===o&&!G.isIos){var f={max:1,step:.05,value:t.config.volume};m.appendChild(s.call(t,"volume",ee(f,{id:"plyr-volume-".concat(e.id)})))}}if("captions"===o&&u.appendChild(n.call(t,"captions",d)),"settings"===o&&!X(t.config.settings)){var g=ne("div",ee({},d,{class:"".concat(d.class," plyr__menu").trim(),hidden:""}));g.appendChild(n.call(t,"settings",{"aria-haspopup":!0,"aria-controls":"plyr-settings-".concat(e.id),"aria-expanded":!1}));var y=ne("div",{class:"plyr__menu__container",id:"plyr-settings-".concat(e.id),hidden:""}),v=ne("div"),b=ne("div",{id:"plyr-settings-".concat(e.id,"-home")}),w=ne("div",{role:"menu"});b.appendChild(w),v.appendChild(b),t.elements.settings.panels.home=b,t.config.settings.forEach((function(n){var a=ne("button",ee(le(t.config.selectors.buttons.settings),{type:"button",class:"".concat(t.config.classNames.control," ").concat(t.config.classNames.control,"--forward"),role:"menuitem","aria-haspopup":!0,hidden:""}));i.call(t,a,n),ke.call(t,a,"click",(function(){c.call(t,n,!1)}));var s=ne("span",null,Fe(n,t.config)),r=ne("span",{class:t.config.classNames.menu.value});r.innerHTML=e[n],s.appendChild(r),a.appendChild(s),w.appendChild(a);var o=ne("div",{id:"plyr-settings-".concat(e.id,"-").concat(n),hidden:""}),l=ne("button",{type:"button",class:"".concat(t.config.classNames.control," ").concat(t.config.classNames.control,"--back")});l.appendChild(ne("span",{"aria-hidden":!0},Fe(n,t.config))),l.appendChild(ne("span",{class:t.config.classNames.hidden},Fe("menuBack",t.config))),ke.call(t,o,"keydown",(function(e){37===e.which&&(e.preventDefault(),e.stopPropagation(),c.call(t,"home",!0))}),!1),ke.call(t,l,"click",(function(){c.call(t,"home",!1)})),o.appendChild(l),o.appendChild(ne("div",{role:"menu"})),v.appendChild(o),t.elements.settings.buttons[n]=a,t.elements.settings.panels[n]=o})),y.appendChild(v),g.appendChild(y),u.appendChild(g),t.elements.settings.popup=y,t.elements.settings.menu=g}if("pip"===o&&ve.pip&&u.appendChild(n.call(t,"pip",d)),"airplay"===o&&ve.airplay&&u.appendChild(n.call(t,"airplay",d)),"download"===o){var k=ee({},d,{element:"a",href:t.download,target:"_blank"});t.isHTML5&&(k.download="");var T=t.config.urls.download;!Q(T)&&t.isEmbed&&ee(k,{icon:"logo-".concat(t.provider),label:t.provider}),u.appendChild(n.call(t,"download",k))}"fullscreen"===o&&u.appendChild(n.call(t,"fullscreen",d))})),this.isHTML5&&o.call(this,Ie.getQualityOptions.call(this)),l.call(this),u},inject:function(){var e=this;if(this.config.loadSprite){var t=Ye.getIconUrl.call(this);t.cors&&Be(t.url,"sprite-plyr")}this.id=Math.floor(1e4*Math.random());var i=null;this.elements.controls=null;var n={id:this.id,seektime:this.config.seekTime,title:this.config.title},a=!0;V(this.config.controls)&&(this.config.controls=this.config.controls.call(this,n)),this.config.controls||(this.config.controls=[]),W(this.config.controls)||F(this.config.controls)?i=this.config.controls:(i=Ye.create.call(this,{id:this.id,seektime:this.config.seekTime,speed:this.speed,quality:this.quality,captions:Je.getLabel.call(this)}),a=!1);var s,o=function(e){var t=e;return Object.entries(n).forEach((function(e){var i=r(e,2),n=i[0],a=i[1];t=Oe(t,"{".concat(n,"}"),a)})),t};if(a&&(F(this.config.controls)?i=o(i):W(i)&&(i.innerHTML=o(i.innerHTML))),F(this.config.selectors.controls.container)&&(s=document.querySelector(this.config.selectors.controls.container)),W(s)||(s=this.elements.container),s[W(i)?"insertAdjacentElement":"insertAdjacentHTML"]("afterbegin",i),W(this.elements.controls)||Ye.findElements.call(this),!X(this.elements.buttons)){var l=function(t){var i=e.config.classNames.controlPressed;Object.defineProperty(t,"pressed",{enumerable:!0,get:function(){return de(t,i)},set:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];ue(t,i,e)}})};Object.values(this.elements.buttons).filter(Boolean).forEach((function(e){B(e)||U(e)?Array.from(e).filter(Boolean).forEach(l):l(e)}))}if(G.isEdge&&$(s),this.config.tooltips.controls){var c=this.config,u=c.classNames,d=c.selectors,h="".concat(d.controls.wrapper," ").concat(d.labels," .").concat(u.hidden),p=pe.call(this,h);Array.from(p).forEach((function(t){ue(t,e.config.classNames.hidden,!1),ue(t,e.config.classNames.tooltip,!0)}))}}};function Qe(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=e;if(t){var n=document.createElement("a");n.href=i,i=n.href}try{return new URL(i)}catch(e){return null}}function Xe(e){var t=new URLSearchParams;return H(e)&&Object.entries(e).forEach((function(e){var i=r(e,2),n=i[0],a=i[1];t.set(n,a)})),t}var Je={setup:function(){if(this.supported.ui)if(!this.isVideo||this.isYouTube||this.isHTML5&&!ve.textTracks)B(this.config.controls)&&this.config.controls.includes("settings")&&this.config.settings.includes("captions")&&Ye.setCaptionsMenu.call(this);else{if(W(this.elements.captions)||(this.elements.captions=ne("div",le(this.config.selectors.captions)),function(e,t){W(e)&&W(t)&&t.parentNode.insertBefore(e,t.nextSibling)}(this.elements.captions,this.elements.wrapper)),G.isIE&&window.URL){var e=this.media.querySelectorAll("track");Array.from(e).forEach((function(e){var t=e.getAttribute("src"),i=Qe(t);null!==i&&i.hostname!==window.location.href.hostname&&["http:","https:"].includes(i.protocol)&&Ve(t,"blob").then((function(t){e.setAttribute("src",window.URL.createObjectURL(t))})).catch((function(){se(e)}))}))}var t=Le((navigator.languages||[navigator.language||navigator.userLanguage||"en"]).map((function(e){return e.split("-")[0]}))),i=(this.storage.get("language")||this.config.captions.language||"auto").toLowerCase();if("auto"===i)i=r(t,1)[0];var n=this.storage.get("captions");if(R(n)||(n=this.config.captions.active),Object.assign(this.captions,{toggled:!1,active:n,language:i,languages:t}),this.isHTML5){var a=this.config.captions.update?"addtrack removetrack":"removetrack";ke.call(this,this.media.textTracks,a,Je.update.bind(this))}setTimeout(Je.update.bind(this),0)}},update:function(){var e=this,t=Je.getTracks.call(this,!0),i=this.captions,n=i.active,a=i.language,s=i.meta,r=i.currentTrackNode,o=Boolean(t.find((function(e){return e.language===a})));this.isHTML5&&this.isVideo&&t.filter((function(e){return!s.get(e)})).forEach((function(t){e.debug.log("Track added",t),s.set(t,{default:"showing"===t.mode}),t.mode="hidden",ke.call(e,t,"cuechange",(function(){return Je.updateCues.call(e)}))})),(o&&this.language!==a||!t.includes(r))&&(Je.setLanguage.call(this,a),Je.toggle.call(this,n&&o)),ue(this.elements.container,this.config.classNames.captions.enabled,!X(t)),(this.config.controls||[]).includes("settings")&&this.config.settings.includes("captions")&&Ye.setCaptionsMenu.call(this)},toggle:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(this.supported.ui){var i=this.captions.toggled,n=this.config.classNames.captions.active,a=q(e)?!i:e;if(a!==i){if(t||(this.captions.active=a,this.storage.set({captions:a})),!this.language&&a&&!t){var s=Je.getTracks.call(this),r=Je.findTrack.call(this,[this.captions.language].concat(o(this.captions.languages)),!0);return this.captions.language=r.language,void Je.set.call(this,s.indexOf(r))}this.elements.buttons.captions&&(this.elements.buttons.captions.pressed=a),ue(this.elements.container,n,a),this.captions.toggled=a,Ye.updateSetting.call(this,"captions"),Ae.call(this,this.media,a?"captionsenabled":"captionsdisabled")}}},set:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=Je.getTracks.call(this);if(-1!==e)if(D(e))if(e in i){if(this.captions.currentTrack!==e){this.captions.currentTrack=e;var n=i[e],a=n||{},s=a.language;this.captions.currentTrackNode=n,Ye.updateSetting.call(this,"captions"),t||(this.captions.language=s,this.storage.set({language:s})),this.isVimeo&&this.embed.enableTextTrack(s),Ae.call(this,this.media,"languagechange")}Je.toggle.call(this,!0,t),this.isHTML5&&this.isVideo&&Je.updateCues.call(this)}else this.debug.warn("Track not found",e);else this.debug.warn("Invalid caption argument",e);else Je.toggle.call(this,!1,t)},setLanguage:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(F(e)){var i=e.toLowerCase();this.captions.language=i;var n=Je.getTracks.call(this),a=Je.findTrack.call(this,[i]);Je.set.call(this,n.indexOf(a),t)}else this.debug.warn("Invalid language argument",e)},getTracks:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=Array.from((this.media||{}).textTracks||[]);return i.filter((function(i){return!e.isHTML5||t||e.captions.meta.has(i)})).filter((function(e){return["captions","subtitles"].includes(e.kind)}))},findTrack:function(e){var t,i=this,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=Je.getTracks.call(this),s=function(e){return Number((i.captions.meta.get(e)||{}).default)},r=Array.from(a).sort((function(e,t){return s(t)-s(e)}));return e.every((function(e){return!(t=r.find((function(t){return t.language===e})))})),t||(n?r[0]:void 0)},getCurrentTrack:function(){return Je.getTracks.call(this)[this.currentTrack]},getLabel:function(e){var t=e;return!Y(t)&&ve.textTracks&&this.captions.toggled&&(t=Je.getCurrentTrack.call(this)),Y(t)?X(t.label)?X(t.language)?Fe("enabled",this.config):e.language.toUpperCase():t.label:Fe("disabled",this.config)},updateCues:function(e){if(this.supported.ui)if(W(this.elements.captions))if(q(e)||Array.isArray(e)){var t=e;if(!t){var i=Je.getCurrentTrack.call(this);t=Array.from((i||{}).activeCues||[]).map((function(e){return e.getCueAsHTML()})).map(He)}var n=t.map((function(e){return e.trim()})).join("\n");if(n!==this.elements.captions.innerHTML){re(this.elements.captions);var a=ne("span",le(this.config.selectors.caption));a.innerHTML=n,this.elements.captions.appendChild(a),Ae.call(this,this.media,"cuechange")}}else this.debug.warn("updateCues: Invalid input",e);else this.debug.warn("No captions element to render to")}},$e={enabled:!0,title:"",debug:!1,autoplay:!1,autopause:!0,playsinline:!0,seekTime:10,volume:1,muted:!1,duration:null,displayDuration:!0,invertTime:!0,toggleInvert:!0,ratio:null,clickToPlay:!0,hideControls:!0,resetOnEnd:!1,disableContextMenu:!0,loadSprite:!0,iconPrefix:"plyr",iconUrl:"https://cdn.plyr.io/3.5.10/plyr.svg",blankVideo:"https://cdn.plyr.io/static/blank.mp4",quality:{default:576,options:[4320,2880,2160,1440,1080,720,576,480,360,240],forced:!1,onChange:null},loop:{active:!1},speed:{selected:1,options:[.5,.75,1,1.25,1.5,1.75,2,4]},keyboard:{focused:!0,global:!1},tooltips:{controls:!1,seek:!0},captions:{active:!1,language:"auto",update:!1},fullscreen:{enabled:!0,fallback:!0,iosNative:!1},storage:{enabled:!0,key:"plyr"},controls:["play-large","play","progress","current-time","mute","volume","captions","settings","pip","airplay","fullscreen"],settings:["captions","quality","speed"],i18n:{restart:"Restart",rewind:"Rewind {seektime}s",play:"Play",pause:"Pause",fastForward:"Forward {seektime}s",seek:"Seek",seekLabel:"{currentTime} of {duration}",played:"Played",buffered:"Buffered",currentTime:"Current time",duration:"Duration",volume:"Volume",mute:"Mute",unmute:"Unmute",enableCaptions:"Enable captions",disableCaptions:"Disable captions",download:"Download",enterFullscreen:"Enter fullscreen",exitFullscreen:"Exit fullscreen",frameTitle:"Player for {title}",captions:"Captions",settings:"Settings",pip:"PIP",menuBack:"Go back to previous menu",speed:"Speed",normal:"Normal",quality:"Quality",loop:"Loop",start:"Start",end:"End",all:"All",reset:"Reset",disabled:"Disabled",enabled:"Enabled",advertisement:"Ad",qualityBadge:{2160:"4K",1440:"HD",1080:"HD",720:"HD",576:"SD",480:"SD"}},urls:{download:null,vimeo:{sdk:"https://player.vimeo.com/api/player.js",iframe:"https://player.vimeo.com/video/{0}?{1}",api:"https://vimeo.com/api/v2/video/{0}.json"},youtube:{sdk:"https://www.youtube.com/iframe_api",api:"https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}"},googleIMA:{sdk:"https://imasdk.googleapis.com/js/sdkloader/ima3.js"}},listeners:{seek:null,play:null,pause:null,restart:null,rewind:null,fastForward:null,mute:null,volume:null,captions:null,download:null,fullscreen:null,pip:null,airplay:null,speed:null,quality:null,loop:null,language:null},events:["ended","progress","stalled","playing","waiting","canplay","canplaythrough","loadstart","loadeddata","loadedmetadata","timeupdate","volumechange","play","pause","error","seeking","seeked","emptied","ratechange","cuechange","download","enterfullscreen","exitfullscreen","captionsenabled","captionsdisabled","languagechange","controlshidden","controlsshown","ready","statechange","qualitychange","adsloaded","adscontentpause","adscontentresume","adstarted","adsmidpoint","adscomplete","adsallcomplete","adsimpression","adsclick"],selectors:{editable:"input, textarea, select, [contenteditable]",container:".plyr",controls:{container:null,wrapper:".plyr__controls"},labels:"[data-plyr]",buttons:{play:'[data-plyr="play"]',pause:'[data-plyr="pause"]',restart:'[data-plyr="restart"]',rewind:'[data-plyr="rewind"]',fastForward:'[data-plyr="fast-forward"]',mute:'[data-plyr="mute"]',captions:'[data-plyr="captions"]',download:'[data-plyr="download"]',fullscreen:'[data-plyr="fullscreen"]',pip:'[data-plyr="pip"]',airplay:'[data-plyr="airplay"]',settings:'[data-plyr="settings"]',loop:'[data-plyr="loop"]'},inputs:{seek:'[data-plyr="seek"]',volume:'[data-plyr="volume"]',speed:'[data-plyr="speed"]',language:'[data-plyr="language"]',quality:'[data-plyr="quality"]'},display:{currentTime:".plyr__time--current",duration:".plyr__time--duration",buffer:".plyr__progress__buffer",loop:".plyr__progress__loop",volume:".plyr__volume--display"},progress:".plyr__progress",captions:".plyr__captions",caption:".plyr__caption"},classNames:{type:"plyr--{0}",provider:"plyr--{0}",video:"plyr__video-wrapper",embed:"plyr__video-embed",videoFixedRatio:"plyr__video-wrapper--fixed-ratio",embedContainer:"plyr__video-embed__container",poster:"plyr__poster",posterEnabled:"plyr__poster-enabled",ads:"plyr__ads",control:"plyr__control",controlPressed:"plyr__control--pressed",playing:"plyr--playing",paused:"plyr--paused",stopped:"plyr--stopped",loading:"plyr--loading",hover:"plyr--hover",tooltip:"plyr__tooltip",cues:"plyr__cues",hidden:"plyr__sr-only",hideControls:"plyr--hide-controls",isIos:"plyr--is-ios",isTouch:"plyr--is-touch",uiSupported:"plyr--full-ui",noTransition:"plyr--no-transition",display:{time:"plyr__time"},menu:{value:"plyr__menu__value",badge:"plyr__badge",open:"plyr--menu-open"},captions:{enabled:"plyr--captions-enabled",active:"plyr--captions-active"},fullscreen:{enabled:"plyr--fullscreen-enabled",fallback:"plyr--fullscreen-fallback"},pip:{supported:"plyr--pip-supported",active:"plyr--pip-active"},airplay:{supported:"plyr--airplay-supported",active:"plyr--airplay-active"},tabFocus:"plyr__tab-focus",previewThumbnails:{thumbContainer:"plyr__preview-thumb",thumbContainerShown:"plyr__preview-thumb--is-shown",imageContainer:"plyr__preview-thumb__image-container",timeContainer:"plyr__preview-thumb__time-container",scrubbingContainer:"plyr__preview-scrubbing",scrubbingContainerShown:"plyr__preview-scrubbing--is-shown"}},attributes:{embed:{provider:"data-plyr-provider",id:"data-plyr-embed-id"}},ads:{enabled:!1,publisherId:"",tagUrl:""},previewThumbnails:{enabled:!1,src:""},vimeo:{byline:!1,portrait:!1,title:!1,speed:!0,transparent:!1,sidedock:!1,controls:!1,referrerPolicy:null},youtube:{noCookie:!1,rel:0,showinfo:0,iv_load_policy:3,modestbranding:1}},Ge="picture-in-picture",Ze="inline",et={html5:"html5",youtube:"youtube",vimeo:"vimeo"},tt="audio",it="video";var nt=function(){},at=function(){function t(){var i=arguments.length>0&&void 0!==arguments[0]&&arguments[0];e(this,t),this.enabled=window.console&&i,this.enabled&&this.log("Debugging enabled")}return i(t,[{key:"log",get:function(){return this.enabled?Function.prototype.bind.call(console.log,console):nt}},{key:"warn",get:function(){return this.enabled?Function.prototype.bind.call(console.warn,console):nt}},{key:"error",get:function(){return this.enabled?Function.prototype.bind.call(console.error,console):nt}}]),t}(),st=function(){function t(i){var n=this;e(this,t),this.player=i,this.prefix=t.prefix,this.property=t.property,this.scrollPosition={x:0,y:0},this.forceFallback="force"===i.config.fullscreen.fallback,ke.call(this.player,document,"ms"===this.prefix?"MSFullscreenChange":"".concat(this.prefix,"fullscreenchange"),(function(){n.onChange()})),ke.call(this.player,this.player.elements.container,"dblclick",(function(e){W(n.player.elements.controls)&&n.player.elements.controls.contains(e.target)||n.toggle()})),ke.call(this,this.player.elements.container,"keydown",(function(e){return n.trapFocus(e)})),this.update()}return i(t,[{key:"onChange",value:function(){if(this.enabled){var e=this.player.elements.buttons.fullscreen;W(e)&&(e.pressed=this.active),Ae.call(this.player,this.target,this.active?"enterfullscreen":"exitfullscreen",!0)}}},{key:"toggleFallback",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(e?this.scrollPosition={x:window.scrollX||0,y:window.scrollY||0}:window.scrollTo(this.scrollPosition.x,this.scrollPosition.y),document.body.style.overflow=e?"hidden":"",ue(this.target,this.player.config.classNames.fullscreen.fallback,e),G.isIos){var t=document.head.querySelector('meta[name="viewport"]'),i="viewport-fit=cover";t||(t=document.createElement("meta")).setAttribute("name","viewport");var n=F(t.content)&&t.content.includes(i);e?(this.cleanupViewport=!n,n||(t.content+=",".concat(i))):this.cleanupViewport&&(t.content=t.content.split(",").filter((function(e){return e.trim()!==i})).join(","))}this.onChange()}},{key:"trapFocus",value:function(e){if(!G.isIos&&this.active&&"Tab"===e.key&&9===e.keyCode){var t=document.activeElement,i=pe.call(this.player,"a[href], button:not(:disabled), input:not(:disabled), [tabindex]"),n=r(i,1)[0],a=i[i.length-1];t!==a||e.shiftKey?t===n&&e.shiftKey&&(a.focus(),e.preventDefault()):(n.focus(),e.preventDefault())}}},{key:"update",value:function(){var e;this.enabled?(e=this.forceFallback?"Fallback (forced)":t.native?"Native":"Fallback",this.player.debug.log("".concat(e," fullscreen enabled"))):this.player.debug.log("Fullscreen not supported and fallback disabled");ue(this.player.elements.container,this.player.config.classNames.fullscreen.enabled,this.enabled)}},{key:"enter",value:function(){this.enabled&&(G.isIos&&this.player.config.fullscreen.iosNative?this.target.webkitEnterFullscreen():!t.native||this.forceFallback?this.toggleFallback(!0):this.prefix?X(this.prefix)||this.target["".concat(this.prefix,"Request").concat(this.property)]():this.target.requestFullscreen({navigationUI:"hide"}))}},{key:"exit",value:function(){if(this.enabled)if(G.isIos&&this.player.config.fullscreen.iosNative)this.target.webkitExitFullscreen(),this.player.play();else if(!t.native||this.forceFallback)this.toggleFallback(!1);else if(this.prefix){if(!X(this.prefix)){var e="moz"===this.prefix?"Cancel":"Exit";document["".concat(this.prefix).concat(e).concat(this.property)]()}}else(document.cancelFullScreen||document.exitFullscreen).call(document)}},{key:"toggle",value:function(){this.active?this.exit():this.enter()}},{key:"usingNative",get:function(){return t.native&&!this.forceFallback}},{key:"enabled",get:function(){return(t.native||this.player.config.fullscreen.fallback)&&this.player.config.fullscreen.enabled&&this.player.supported.ui&&this.player.isVideo}},{key:"active",get:function(){return!!this.enabled&&(!t.native||this.forceFallback?de(this.target,this.player.config.classNames.fullscreen.fallback):(this.prefix?document["".concat(this.prefix).concat(this.property,"Element")]:document.fullscreenElement)===this.target)}},{key:"target",get:function(){return G.isIos&&this.player.config.fullscreen.iosNative?this.player.media:this.player.elements.container}}],[{key:"native",get:function(){return!!(document.fullscreenEnabled||document.webkitFullscreenEnabled||document.mozFullScreenEnabled||document.msFullscreenEnabled)}},{key:"prefix",get:function(){if(V(document.exitFullscreen))return"";var e="";return["webkit","moz","ms"].some((function(t){return!(!V(document["".concat(t,"ExitFullscreen")])&&!V(document["".concat(t,"CancelFullScreen")]))&&(e=t,!0)})),e}},{key:"property",get:function(){return"moz"===this.prefix?"FullScreen":"Fullscreen"}}]),t}();function rt(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Promise((function(i,n){var a=new Image,s=function(){delete a.onload,delete a.onerror,(a.naturalWidth>=t?i:n)(a)};Object.assign(a,{onload:s,onerror:s,src:e})}))}var ot={addStyleHook:function(){ue(this.elements.container,this.config.selectors.container.replace(".",""),!0),ue(this.elements.container,this.config.classNames.uiSupported,this.supported.ui)},toggleNativeControls:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];e&&this.isHTML5?this.media.setAttribute("controls",""):this.media.removeAttribute("controls")},build:function(){var e=this;if(this.listeners.media(),!this.supported.ui)return this.debug.warn("Basic support only for ".concat(this.provider," ").concat(this.type)),void ot.toggleNativeControls.call(this,!0);W(this.elements.controls)||(Ye.inject.call(this),this.listeners.controls()),ot.toggleNativeControls.call(this),this.isHTML5&&Je.setup.call(this),this.volume=null,this.muted=null,this.loop=null,this.quality=null,this.speed=null,Ye.updateVolume.call(this),Ye.timeUpdate.call(this),ot.checkPlaying.call(this),ue(this.elements.container,this.config.classNames.pip.supported,ve.pip&&this.isHTML5&&this.isVideo),ue(this.elements.container,this.config.classNames.airplay.supported,ve.airplay&&this.isHTML5),ue(this.elements.container,this.config.classNames.isIos,G.isIos),ue(this.elements.container,this.config.classNames.isTouch,this.touch),this.ready=!0,setTimeout((function(){Ae.call(e,e.media,"ready")}),0),ot.setTitle.call(this),this.poster&&ot.setPoster.call(this,this.poster,!1).catch((function(){})),this.config.duration&&Ye.durationUpdate.call(this)},setTitle:function(){var e=Fe("play",this.config);if(F(this.config.title)&&!X(this.config.title)&&(e+=", ".concat(this.config.title)),Array.from(this.elements.buttons.play||[]).forEach((function(t){t.setAttribute("aria-label",e)})),this.isEmbed){var t=me.call(this,"iframe");if(!W(t))return;var i=X(this.config.title)?"video":this.config.title,n=Fe("frameTitle",this.config);t.setAttribute("title",n.replace("{title}",i))}},togglePoster:function(e){ue(this.elements.container,this.config.classNames.posterEnabled,e)},setPoster:function(e){var t=this,i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return i&&this.poster?Promise.reject(new Error("Poster already set")):(this.media.setAttribute("poster",e),this.isHTML5?Promise.resolve(e):Se.call(this).then((function(){return rt(e)})).catch((function(i){throw e===t.poster&&ot.togglePoster.call(t,!1),i})).then((function(){if(e!==t.poster)throw new Error("setPoster cancelled by later call to setPoster")})).then((function(){return Object.assign(t.elements.poster.style,{backgroundImage:"url('".concat(e,"')"),backgroundSize:""}),ot.togglePoster.call(t,!0),e})))},checkPlaying:function(e){var t=this;ue(this.elements.container,this.config.classNames.playing,this.playing),ue(this.elements.container,this.config.classNames.paused,this.paused),ue(this.elements.container,this.config.classNames.stopped,this.stopped),Array.from(this.elements.buttons.play||[]).forEach((function(e){Object.assign(e,{pressed:t.playing}),e.setAttribute("aria-label",Fe(t.playing?"pause":"play",t.config))})),z(e)&&"timeupdate"===e.type||ot.toggleControls.call(this)},checkLoading:function(e){var t=this;this.loading=["stalled","waiting"].includes(e.type),clearTimeout(this.timers.loading),this.timers.loading=setTimeout((function(){ue(t.elements.container,t.config.classNames.loading,t.loading),ot.toggleControls.call(t)}),this.loading?250:0)},toggleControls:function(e){var t=this.elements.controls;if(t&&this.config.hideControls){var i=this.touch&&this.lastSeekTime+2e3>Date.now();this.toggleControls(Boolean(e||this.loading||this.paused||t.pressed||t.hover||i))}}},lt=function(){function t(i){e(this,t),this.player=i,this.lastKey=null,this.focusTimer=null,this.lastKeyDown=null,this.handleKey=this.handleKey.bind(this),this.toggleMenu=this.toggleMenu.bind(this),this.setTabFocus=this.setTabFocus.bind(this),this.firstTouch=this.firstTouch.bind(this)}return i(t,[{key:"handleKey",value:function(e){var t=this.player,i=t.elements,n=e.keyCode?e.keyCode:e.which,a="keydown"===e.type,s=a&&n===this.lastKey;if(!(e.altKey||e.ctrlKey||e.metaKey||e.shiftKey)&&D(n)){if(a){var r=document.activeElement;if(W(r)){var o=t.config.selectors.editable;if(r!==i.inputs.seek&&he(r,o))return;if(32===e.which&&he(r,'button, [role^="menuitem"]'))return}switch([32,37,38,39,40,48,49,50,51,52,53,54,56,57,67,70,73,75,76,77,79].includes(n)&&(e.preventDefault(),e.stopPropagation()),n){case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:s||(t.currentTime=t.duration/10*(n-48));break;case 32:case 75:s||t.togglePlay();break;case 38:t.increaseVolume(.1);break;case 40:t.decreaseVolume(.1);break;case 77:s||(t.muted=!t.muted);break;case 39:t.forward();break;case 37:t.rewind();break;case 70:t.fullscreen.toggle();break;case 67:s||t.toggleCaptions();break;case 76:t.loop=!t.loop}27===n&&!t.fullscreen.usingNative&&t.fullscreen.active&&t.fullscreen.toggle(),this.lastKey=n}else this.lastKey=null}}},{key:"toggleMenu",value:function(e){Ye.toggleMenu.call(this.player,e)}},{key:"firstTouch",value:function(){var e=this.player,t=e.elements;e.touch=!0,ue(t.container,e.config.classNames.isTouch,!0)}},{key:"setTabFocus",value:function(e){var t=this.player,i=t.elements;if(clearTimeout(this.focusTimer),"keydown"!==e.type||9===e.which){"keydown"===e.type&&(this.lastKeyDown=e.timeStamp);var n,a=e.timeStamp-this.lastKeyDown<=20;if("focus"!==e.type||a)n=t.config.classNames.tabFocus,ue(pe.call(t,".".concat(n)),n,!1),this.focusTimer=setTimeout((function(){var e=document.activeElement;i.container.contains(e)&&ue(document.activeElement,t.config.classNames.tabFocus,!0)}),10)}}},{key:"global",value:function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=this.player;t.config.keyboard.global&&we.call(t,window,"keydown keyup",this.handleKey,e,!1),we.call(t,document.body,"click",this.toggleMenu,e),Ce.call(t,document.body,"touchstart",this.firstTouch),we.call(t,document.body,"keydown focus blur",this.setTabFocus,e,!1,!0)}},{key:"container",value:function(){var e=this.player,t=e.config,i=e.elements,n=e.timers;!t.keyboard.global&&t.keyboard.focused&&ke.call(e,i.container,"keydown keyup",this.handleKey,!1),ke.call(e,i.container,"mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen",(function(t){var a=i.controls;a&&"enterfullscreen"===t.type&&(a.pressed=!1,a.hover=!1);var s=0;["touchstart","touchmove","mousemove"].includes(t.type)&&(ot.toggleControls.call(e,!0),s=e.touch?3e3:2e3),clearTimeout(n.controls),n.controls=setTimeout((function(){return ot.toggleControls.call(e,!1)}),s)}));var a=function(t){if(!t)return xe.call(e);var n=i.container.getBoundingClientRect(),a=n.width,s=n.height;return xe.call(e,"".concat(a,":").concat(s))},s=function(){clearTimeout(n.resized),n.resized=setTimeout(a,50)};ke.call(e,i.container,"enterfullscreen exitfullscreen",(function(t){var n=e.fullscreen,o=n.target,l=n.usingNative;if(o===i.container&&(e.isEmbed||!X(e.config.ratio))){var c="enterfullscreen"===t.type,u=a(c);u.padding;!function(t,i,n){if(e.isVimeo){var a=e.elements.wrapper.firstChild,s=r(t,2)[1],o=r(Ne.call(e),2),l=o[0],c=o[1];a.style.maxWidth=n?"".concat(s/c*l,"px"):null,a.style.margin=n?"0 auto":null}}(u.ratio,0,c),l||(c?ke.call(e,window,"resize",s):Te.call(e,window,"resize",s))}}))}},{key:"media",value:function(){var e=this,t=this.player,i=t.elements;if(ke.call(t,t.media,"timeupdate seeking seeked",(function(e){return Ye.timeUpdate.call(t,e)})),ke.call(t,t.media,"durationchange loadeddata loadedmetadata",(function(e){return Ye.durationUpdate.call(t,e)})),ke.call(t,t.media,"ended",(function(){t.isHTML5&&t.isVideo&&t.config.resetOnEnd&&(t.restart(),t.pause())})),ke.call(t,t.media,"progress playing seeking seeked",(function(e){return Ye.updateProgress.call(t,e)})),ke.call(t,t.media,"volumechange",(function(e){return Ye.updateVolume.call(t,e)})),ke.call(t,t.media,"playing play pause ended emptied timeupdate",(function(e){return ot.checkPlaying.call(t,e)})),ke.call(t,t.media,"waiting canplay seeked playing",(function(e){return ot.checkLoading.call(t,e)})),t.supported.ui&&t.config.clickToPlay&&!t.isAudio){var n=me.call(t,".".concat(t.config.classNames.video));if(!W(n))return;ke.call(t,i.container,"click",(function(a){([i.container,n].includes(a.target)||n.contains(a.target))&&(t.touch&&t.config.hideControls||(t.ended?(e.proxy(a,t.restart,"restart"),e.proxy(a,t.play,"play")):e.proxy(a,t.togglePlay,"play")))}))}t.supported.ui&&t.config.disableContextMenu&&ke.call(t,i.wrapper,"contextmenu",(function(e){e.preventDefault()}),!1),ke.call(t,t.media,"volumechange",(function(){t.storage.set({volume:t.volume,muted:t.muted})})),ke.call(t,t.media,"ratechange",(function(){Ye.updateSetting.call(t,"speed"),t.storage.set({speed:t.speed})})),ke.call(t,t.media,"qualitychange",(function(e){Ye.updateSetting.call(t,"quality",null,e.detail.quality)})),ke.call(t,t.media,"ready qualitychange",(function(){Ye.setDownloadUrl.call(t)}));var a=t.config.events.concat(["keyup","keydown"]).join(" ");ke.call(t,t.media,a,(function(e){var n=e.detail,a=void 0===n?{}:n;"error"===e.type&&(a=t.media.error),Ae.call(t,i.container,e.type,!0,a)}))}},{key:"proxy",value:function(e,t,i){var n=this.player,a=n.config.listeners[i],s=!0;V(a)&&(s=a.call(n,e)),!1!==s&&V(t)&&t.call(n,e)}},{key:"bind",value:function(e,t,i,n){var a=this,s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=this.player,o=r.config.listeners[n],l=V(o);ke.call(r,e,t,(function(e){return a.proxy(e,i,n)}),s&&!l)}},{key:"controls",value:function(){var e=this,t=this.player,i=t.elements,n=G.isIE?"change":"input";if(i.buttons.play&&Array.from(i.buttons.play).forEach((function(i){e.bind(i,"click",t.togglePlay,"play")})),this.bind(i.buttons.restart,"click",t.restart,"restart"),this.bind(i.buttons.rewind,"click",t.rewind,"rewind"),this.bind(i.buttons.fastForward,"click",t.forward,"fastForward"),this.bind(i.buttons.mute,"click",(function(){t.muted=!t.muted}),"mute"),this.bind(i.buttons.captions,"click",(function(){return t.toggleCaptions()})),this.bind(i.buttons.download,"click",(function(){Ae.call(t,t.media,"download")}),"download"),this.bind(i.buttons.fullscreen,"click",(function(){t.fullscreen.toggle()}),"fullscreen"),this.bind(i.buttons.pip,"click",(function(){t.pip="toggle"}),"pip"),this.bind(i.buttons.airplay,"click",t.airplay,"airplay"),this.bind(i.buttons.settings,"click",(function(e){e.stopPropagation(),e.preventDefault(),Ye.toggleMenu.call(t,e)}),null,!1),this.bind(i.buttons.settings,"keyup",(function(e){var i=e.which;[13,32].includes(i)&&(13!==i?(e.preventDefault(),e.stopPropagation(),Ye.toggleMenu.call(t,e)):Ye.focusFirstMenuItem.call(t,null,!0))}),null,!1),this.bind(i.settings.menu,"keydown",(function(e){27===e.which&&Ye.toggleMenu.call(t,e)})),this.bind(i.inputs.seek,"mousedown mousemove",(function(e){var t=i.progress.getBoundingClientRect(),n=100/t.width*(e.pageX-t.left);e.currentTarget.setAttribute("seek-value",n)})),this.bind(i.inputs.seek,"mousedown mouseup keydown keyup touchstart touchend",(function(e){var i=e.currentTarget,n=e.keyCode?e.keyCode:e.which;if(!K(e)||39===n||37===n){t.lastSeekTime=Date.now();var a=i.hasAttribute("play-on-seeked"),s=["mouseup","touchend","keyup"].includes(e.type);a&&s?(i.removeAttribute("play-on-seeked"),t.play()):!s&&t.playing&&(i.setAttribute("play-on-seeked",""),t.pause())}})),G.isIos){var a=pe.call(t,'input[type="range"]');Array.from(a).forEach((function(t){return e.bind(t,n,(function(e){return $(e.target)}))}))}this.bind(i.inputs.seek,n,(function(e){var i=e.currentTarget,n=i.getAttribute("seek-value");X(n)&&(n=i.value),i.removeAttribute("seek-value"),t.currentTime=n/i.max*t.duration}),"seek"),this.bind(i.progress,"mouseenter mouseleave mousemove",(function(e){return Ye.updateSeekTooltip.call(t,e)})),this.bind(i.progress,"mousemove touchmove",(function(e){var i=t.previewThumbnails;i&&i.loaded&&i.startMove(e)})),this.bind(i.progress,"mouseleave touchend click",(function(){var e=t.previewThumbnails;e&&e.loaded&&e.endMove(!1,!0)})),this.bind(i.progress,"mousedown touchstart",(function(e){var i=t.previewThumbnails;i&&i.loaded&&i.startScrubbing(e)})),this.bind(i.progress,"mouseup touchend",(function(e){var i=t.previewThumbnails;i&&i.loaded&&i.endScrubbing(e)})),G.isWebkit&&Array.from(pe.call(t,'input[type="range"]')).forEach((function(i){e.bind(i,"input",(function(e){return Ye.updateRangeFill.call(t,e.target)}))})),t.config.toggleInvert&&!W(i.display.duration)&&this.bind(i.display.currentTime,"click",(function(){0!==t.currentTime&&(t.config.invertTime=!t.config.invertTime,Ye.timeUpdate.call(t))})),this.bind(i.inputs.volume,n,(function(e){t.volume=e.target.value}),"volume"),this.bind(i.controls,"mouseenter mouseleave",(function(e){i.controls.hover=!t.touch&&"mouseenter"===e.type})),this.bind(i.controls,"mousedown mouseup touchstart touchend touchcancel",(function(e){i.controls.pressed=["mousedown","touchstart"].includes(e.type)})),this.bind(i.controls,"focusin",(function(){var n=t.config,a=t.timers;ue(i.controls,n.classNames.noTransition,!0),ot.toggleControls.call(t,!0),setTimeout((function(){ue(i.controls,n.classNames.noTransition,!1)}),0);var s=e.touch?3e3:4e3;clearTimeout(a.controls),a.controls=setTimeout((function(){return ot.toggleControls.call(t,!1)}),s)})),this.bind(i.inputs.volume,"wheel",(function(e){var i=e.webkitDirectionInvertedFromDevice,n=r([e.deltaX,-e.deltaY].map((function(e){return i?-e:e})),2),a=n[0],s=n[1],o=Math.sign(Math.abs(a)>Math.abs(s)?a:s);t.increaseVolume(o/50);var l=t.media.volume;(1===o&&l<1||-1===o&&l>0)&&e.preventDefault()}),"volume",!1)}}]),t}();"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var ct=function(e,t){return e(t={exports:{}},t.exports),t.exports}((function(e,t){e.exports=function(){var e=function(){},t={},i={},n={};function a(e,t){if(e){var a=n[e];if(i[e]=t,a)for(;a.length;)a[0](e,t),a.splice(0,1)}}function s(t,i){t.call&&(t={success:t}),i.length?(t.error||e)(i):(t.success||e)(t)}function r(t,i,n,a){var s,o,l=document,c=n.async,u=(n.numRetries||0)+1,d=n.before||e,h=t.replace(/[\?|#].*$/,""),p=t.replace(/^(css|img)!/,"");a=a||0,/(^css!|\.css$)/.test(h)?((o=l.createElement("link")).rel="stylesheet",o.href=p,(s="hideFocus"in o)&&o.relList&&(s=0,o.rel="preload",o.as="style")):/(^img!|\.(png|gif|jpg|svg|webp)$)/.test(h)?(o=l.createElement("img")).src=p:((o=l.createElement("script")).src=t,o.async=void 0===c||c),o.onload=o.onerror=o.onbeforeload=function(e){var l=e.type[0];if(s)try{o.sheet.cssText.length||(l="e")}catch(e){18!=e.code&&(l="e")}if("e"==l){if((a+=1)<u)return r(t,i,n,a)}else if("preload"==o.rel&&"style"==o.as)return o.rel="stylesheet";i(t,l,e.defaultPrevented)},!1!==d(t,o)&&l.head.appendChild(o)}function o(e,i,n){var o,l;if(i&&i.trim&&(o=i),l=(o?n:i)||{},o){if(o in t)throw"LoadJS";t[o]=!0}function c(t,i){!function(e,t,i){var n,a,s=(e=e.push?e:[e]).length,o=s,l=[];for(n=function(e,i,n){if("e"==i&&l.push(e),"b"==i){if(!n)return;l.push(e)}--s||t(l)},a=0;a<o;a++)r(e[a],n,i)}(e,(function(e){s(l,e),t&&s({success:t,error:i},e),a(o,e)}),l)}if(l.returnPromise)return new Promise(c);c()}return o.ready=function(e,t){return function(e,t){e=e.push?e:[e];var a,s,r,o=[],l=e.length,c=l;for(a=function(e,i){i.length&&o.push(e),--c||t(o)};l--;)s=e[l],(r=i[s])?a(s,r):(n[s]=n[s]||[]).push(a)}(e,(function(e){s(t,e)})),o},o.done=function(e){a(e,[])},o.reset=function(){t={},i={},n={}},o.isDefined=function(e){return e in t},o}()}));function ut(e){return new Promise((function(t,i){ct(e,{success:t,error:i})}))}function dt(e){e&&!this.embed.hasPlayed&&(this.embed.hasPlayed=!0),this.media.paused===e&&(this.media.paused=!e,Ae.call(this,this.media,e?"play":"pause"))}var ht={setup:function(){var e=this;ue(e.elements.wrapper,e.config.classNames.embed,!0),e.options.speed=e.config.speed.options,xe.call(e),H(window.Vimeo)?ht.ready.call(e):ut(e.config.urls.vimeo.sdk).then((function(){ht.ready.call(e)})).catch((function(t){e.debug.warn("Vimeo SDK (player.js) failed to load",t)}))},ready:function(){var e=this,t=this,i=t.config.vimeo,n=Xe(ee({},{loop:t.config.loop.active,autoplay:t.autoplay,muted:t.muted,gesture:"media",playsinline:!this.config.fullscreen.iosNative},i)),a=t.media.getAttribute("src");X(a)&&(a=t.media.getAttribute(t.config.attributes.embed.id));var s,o=X(s=a)?null:D(Number(s))?s:s.match(/^.*(vimeo.com\/|video\/)(\d+).*/)?RegExp.$2:s,l=ne("iframe"),c=_e(t.config.urls.vimeo.iframe,o,n);l.setAttribute("src",c),l.setAttribute("allowfullscreen",""),l.setAttribute("allowtransparency",""),l.setAttribute("allow","autoplay"),X(i.referrerPolicy)||l.setAttribute("referrerPolicy",i.referrerPolicy);var u=ne("div",{poster:t.poster,class:t.config.classNames.embedContainer});u.appendChild(l),t.media=oe(u,t.media),Ve(_e(t.config.urls.vimeo.api,o),"json").then((function(e){if(!X(e)){var i=new URL(e[0].thumbnail_large);i.pathname="".concat(i.pathname.split("_")[0],".jpg"),ot.setPoster.call(t,i.href).catch((function(){}))}})),t.embed=new window.Vimeo.Player(l,{autopause:t.config.autopause,muted:t.muted}),t.media.paused=!0,t.media.currentTime=0,t.supported.ui&&t.embed.disableTextTrack(),t.media.play=function(){return dt.call(t,!0),t.embed.play()},t.media.pause=function(){return dt.call(t,!1),t.embed.pause()},t.media.stop=function(){t.pause(),t.currentTime=0};var d=t.media.currentTime;Object.defineProperty(t.media,"currentTime",{get:function(){return d},set:function(e){var i=t.embed,n=t.media,a=t.paused,s=t.volume,r=a&&!i.hasPlayed;n.seeking=!0,Ae.call(t,n,"seeking"),Promise.resolve(r&&i.setVolume(0)).then((function(){return i.setCurrentTime(e)})).then((function(){return r&&i.pause()})).then((function(){return r&&i.setVolume(s)})).catch((function(){}))}});var h=t.config.speed.selected;Object.defineProperty(t.media,"playbackRate",{get:function(){return h},set:function(e){t.embed.setPlaybackRate(e).then((function(){h=e,Ae.call(t,t.media,"ratechange")}))}});var p=t.config.volume;Object.defineProperty(t.media,"volume",{get:function(){return p},set:function(e){t.embed.setVolume(e).then((function(){p=e,Ae.call(t,t.media,"volumechange")}))}});var m=t.config.muted;Object.defineProperty(t.media,"muted",{get:function(){return m},set:function(e){var i=!!R(e)&&e;t.embed.setVolume(i?0:t.config.volume).then((function(){m=i,Ae.call(t,t.media,"volumechange")}))}});var f,g=t.config.loop;Object.defineProperty(t.media,"loop",{get:function(){return g},set:function(e){var i=R(e)?e:t.config.loop.active;t.embed.setLoop(i).then((function(){g=i}))}}),t.embed.getVideoUrl().then((function(e){f=e,Ye.setDownloadUrl.call(t)})).catch((function(t){e.debug.warn(t)})),Object.defineProperty(t.media,"currentSrc",{get:function(){return f}}),Object.defineProperty(t.media,"ended",{get:function(){return t.currentTime===t.duration}}),Promise.all([t.embed.getVideoWidth(),t.embed.getVideoHeight()]).then((function(i){var n=r(i,2),a=n[0],s=n[1];t.embed.ratio=[a,s],xe.call(e)})),t.embed.setAutopause(t.config.autopause).then((function(e){t.config.autopause=e})),t.embed.getVideoTitle().then((function(i){t.config.title=i,ot.setTitle.call(e)})),t.embed.getCurrentTime().then((function(e){d=e,Ae.call(t,t.media,"timeupdate")})),t.embed.getDuration().then((function(e){t.media.duration=e,Ae.call(t,t.media,"durationchange")})),t.embed.getTextTracks().then((function(e){t.media.textTracks=e,Je.setup.call(t)})),t.embed.on("cuechange",(function(e){var i=e.cues,n=(void 0===i?[]:i).map((function(e){return function(e){var t=document.createDocumentFragment(),i=document.createElement("div");return t.appendChild(i),i.innerHTML=e,t.firstChild.innerText}(e.text)}));Je.updateCues.call(t,n)})),t.embed.on("loaded",(function(){(t.embed.getPaused().then((function(e){dt.call(t,!e),e||Ae.call(t,t.media,"playing")})),W(t.embed.element)&&t.supported.ui)&&t.embed.element.setAttribute("tabindex",-1)})),t.embed.on("bufferstart",(function(){Ae.call(t,t.media,"waiting")})),t.embed.on("bufferend",(function(){Ae.call(t,t.media,"playing")})),t.embed.on("play",(function(){dt.call(t,!0),Ae.call(t,t.media,"playing")})),t.embed.on("pause",(function(){dt.call(t,!1)})),t.embed.on("timeupdate",(function(e){t.media.seeking=!1,d=e.seconds,Ae.call(t,t.media,"timeupdate")})),t.embed.on("progress",(function(e){t.media.buffered=e.percent,Ae.call(t,t.media,"progress"),1===parseInt(e.percent,10)&&Ae.call(t,t.media,"canplaythrough"),t.embed.getDuration().then((function(e){e!==t.media.duration&&(t.media.duration=e,Ae.call(t,t.media,"durationchange"))}))})),t.embed.on("seeked",(function(){t.media.seeking=!1,Ae.call(t,t.media,"seeked")})),t.embed.on("ended",(function(){t.media.paused=!0,Ae.call(t,t.media,"ended")})),t.embed.on("error",(function(e){t.media.error=e,Ae.call(t,t.media,"error")})),setTimeout((function(){return ot.build.call(t)}),0)}};function pt(e){e&&!this.embed.hasPlayed&&(this.embed.hasPlayed=!0),this.media.paused===e&&(this.media.paused=!e,Ae.call(this,this.media,e?"play":"pause"))}function mt(e){return e.noCookie?"https://www.youtube-nocookie.com":"http:"===window.location.protocol?"http://www.youtube.com":void 0}var ft={setup:function(){var e=this;if(ue(this.elements.wrapper,this.config.classNames.embed,!0),H(window.YT)&&V(window.YT.Player))ft.ready.call(this);else{var t=window.onYouTubeIframeAPIReady;window.onYouTubeIframeAPIReady=function(){V(t)&&t(),ft.ready.call(e)},ut(this.config.urls.youtube.sdk).catch((function(t){e.debug.warn("YouTube API failed to load",t)}))}},getTitle:function(e){var t=this;Ve(_e(this.config.urls.youtube.api,e)).then((function(e){if(H(e)){var i=e.title,n=e.height,a=e.width;t.config.title=i,ot.setTitle.call(t),t.embed.ratio=[a,n]}xe.call(t)})).catch((function(){xe.call(t)}))},ready:function(){var e=this,t=e.media&&e.media.getAttribute("id");if(X(t)||!t.startsWith("youtube-")){var i=e.media.getAttribute("src");X(i)&&(i=e.media.getAttribute(this.config.attributes.embed.id));var n,a,s=X(n=i)?null:n.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/)?RegExp.$2:n,r=(a=e.provider,"".concat(a,"-").concat(Math.floor(1e4*Math.random()))),o=ne("div",{id:r,poster:e.poster});e.media=oe(o,e.media);var l=function(e){return"https://i.ytimg.com/vi/".concat(s,"/").concat(e,"default.jpg")};rt(l("maxres"),121).catch((function(){return rt(l("sd"),121)})).catch((function(){return rt(l("hq"))})).then((function(t){return ot.setPoster.call(e,t.src)})).then((function(t){t.includes("maxres")||(e.elements.poster.style.backgroundSize="cover")})).catch((function(){}));var c=e.config.youtube;e.embed=new window.YT.Player(r,{videoId:s,host:mt(c),playerVars:ee({},{autoplay:e.config.autoplay?1:0,hl:e.config.hl,controls:e.supported.ui?0:1,disablekb:1,playsinline:e.config.fullscreen.iosNative?0:1,cc_load_policy:e.captions.active?1:0,cc_lang_pref:e.config.captions.language,widget_referrer:window?window.location.href:null},c),events:{onError:function(t){if(!e.media.error){var i=t.data,n={2:"The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.",5:"The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.",100:"The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.",101:"The owner of the requested video does not allow it to be played in embedded players.",150:"The owner of the requested video does not allow it to be played in embedded players."}[i]||"An unknown error occured";e.media.error={code:i,message:n},Ae.call(e,e.media,"error")}},onPlaybackRateChange:function(t){var i=t.target;e.media.playbackRate=i.getPlaybackRate(),Ae.call(e,e.media,"ratechange")},onReady:function(t){if(!V(e.media.play)){var i=t.target;ft.getTitle.call(e,s),e.media.play=function(){pt.call(e,!0),i.playVideo()},e.media.pause=function(){pt.call(e,!1),i.pauseVideo()},e.media.stop=function(){i.stopVideo()},e.media.duration=i.getDuration(),e.media.paused=!0,e.media.currentTime=0,Object.defineProperty(e.media,"currentTime",{get:function(){return Number(i.getCurrentTime())},set:function(t){e.paused&&!e.embed.hasPlayed&&e.embed.mute(),e.media.seeking=!0,Ae.call(e,e.media,"seeking"),i.seekTo(t)}}),Object.defineProperty(e.media,"playbackRate",{get:function(){return i.getPlaybackRate()},set:function(e){i.setPlaybackRate(e)}});var n=e.config.volume;Object.defineProperty(e.media,"volume",{get:function(){return n},set:function(t){n=t,i.setVolume(100*n),Ae.call(e,e.media,"volumechange")}});var a=e.config.muted;Object.defineProperty(e.media,"muted",{get:function(){return a},set:function(t){var n=R(t)?t:a;a=n,i[n?"mute":"unMute"](),Ae.call(e,e.media,"volumechange")}}),Object.defineProperty(e.media,"currentSrc",{get:function(){return i.getVideoUrl()}}),Object.defineProperty(e.media,"ended",{get:function(){return e.currentTime===e.duration}});var r=i.getAvailablePlaybackRates();e.options.speed=r.filter((function(t){return e.config.speed.options.includes(t)})),e.supported.ui&&e.media.setAttribute("tabindex",-1),Ae.call(e,e.media,"timeupdate"),Ae.call(e,e.media,"durationchange"),clearInterval(e.timers.buffering),e.timers.buffering=setInterval((function(){e.media.buffered=i.getVideoLoadedFraction(),(null===e.media.lastBuffered||e.media.lastBuffered<e.media.buffered)&&Ae.call(e,e.media,"progress"),e.media.lastBuffered=e.media.buffered,1===e.media.buffered&&(clearInterval(e.timers.buffering),Ae.call(e,e.media,"canplaythrough"))}),200),setTimeout((function(){return ot.build.call(e)}),50)}},onStateChange:function(t){var i=t.target;switch(clearInterval(e.timers.playing),e.media.seeking&&[1,2].includes(t.data)&&(e.media.seeking=!1,Ae.call(e,e.media,"seeked")),t.data){case-1:Ae.call(e,e.media,"timeupdate"),e.media.buffered=i.getVideoLoadedFraction(),Ae.call(e,e.media,"progress");break;case 0:pt.call(e,!1),e.media.loop?(i.stopVideo(),i.playVideo()):Ae.call(e,e.media,"ended");break;case 1:e.config.autoplay||!e.media.paused||e.embed.hasPlayed?(pt.call(e,!0),Ae.call(e,e.media,"playing"),e.timers.playing=setInterval((function(){Ae.call(e,e.media,"timeupdate")}),50),e.media.duration!==i.getDuration()&&(e.media.duration=i.getDuration(),Ae.call(e,e.media,"durationchange"))):e.media.pause();break;case 2:e.muted||e.embed.unMute(),pt.call(e,!1);break;case 3:Ae.call(e,e.media,"waiting")}Ae.call(e,e.elements.container,"statechange",!1,{code:t.data})}}})}}},gt={setup:function(){this.media?(ue(this.elements.container,this.config.classNames.type.replace("{0}",this.type),!0),ue(this.elements.container,this.config.classNames.provider.replace("{0}",this.provider),!0),this.isEmbed&&ue(this.elements.container,this.config.classNames.type.replace("{0}","video"),!0),this.isVideo&&(this.elements.wrapper=ne("div",{class:this.config.classNames.video}),te(this.media,this.elements.wrapper),this.isEmbed&&(this.elements.poster=ne("div",{class:this.config.classNames.poster}),this.elements.wrapper.appendChild(this.elements.poster))),this.isHTML5?Ie.setup.call(this):this.isYouTube?ft.setup.call(this):this.isVimeo&&ht.setup.call(this)):this.debug.warn("No media element found!")}},yt=function(){function t(i){var n=this;e(this,t),this.player=i,this.config=i.config.ads,this.playing=!1,this.initialized=!1,this.elements={container:null,displayContainer:null},this.manager=null,this.loader=null,this.cuePoints=null,this.events={},this.safetyTimer=null,this.countdownTimer=null,this.managerPromise=new Promise((function(e,t){n.on("loaded",e),n.on("error",t)})),this.load()}return i(t,[{key:"load",value:function(){var e=this;this.enabled&&(H(window.google)&&H(window.google.ima)?this.ready():ut(this.player.config.urls.googleIMA.sdk).then((function(){e.ready()})).catch((function(){e.trigger("error",new Error("Google IMA SDK failed to load"))})))}},{key:"ready",value:function(){var e,t=this;this.enabled||((e=this).manager&&e.manager.destroy(),e.elements.displayContainer&&e.elements.displayContainer.destroy(),e.elements.container.remove()),this.startSafetyTimer(12e3,"ready()"),this.managerPromise.then((function(){t.clearSafetyTimer("onAdsManagerLoaded()")})),this.listeners(),this.setupIMA()}},{key:"setupIMA",value:function(){this.elements.container=ne("div",{class:this.player.config.classNames.ads}),this.player.elements.container.appendChild(this.elements.container),google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED),google.ima.settings.setLocale(this.player.config.ads.language),google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline),this.elements.displayContainer=new google.ima.AdDisplayContainer(this.elements.container,this.player.media),this.requestAds()}},{key:"requestAds",value:function(){var e=this,t=this.player.elements.container;try{this.loader=new google.ima.AdsLoader(this.elements.displayContainer),this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED,(function(t){return e.onAdsManagerLoaded(t)}),!1),this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR,(function(t){return e.onAdError(t)}),!1);var i=new google.ima.AdsRequest;i.adTagUrl=this.tagUrl,i.linearAdSlotWidth=t.offsetWidth,i.linearAdSlotHeight=t.offsetHeight,i.nonLinearAdSlotWidth=t.offsetWidth,i.nonLinearAdSlotHeight=t.offsetHeight,i.forceNonLinearFullSlot=!1,i.setAdWillPlayMuted(!this.player.muted),this.loader.requestAds(i)}catch(e){this.onAdError(e)}}},{key:"pollCountdown",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!t)return clearInterval(this.countdownTimer),void this.elements.container.removeAttribute("data-badge-text");var i=function(){var t=Ke(Math.max(e.manager.getRemainingTime(),0)),i="".concat(Fe("advertisement",e.player.config)," - ").concat(t);e.elements.container.setAttribute("data-badge-text",i)};this.countdownTimer=setInterval(i,100)}},{key:"onAdsManagerLoaded",value:function(e){var t=this;if(this.enabled){var i=new google.ima.AdsRenderingSettings;i.restoreCustomPlaybackStateOnAdBreakComplete=!0,i.enablePreloading=!0,this.manager=e.getAdsManager(this.player,i),this.cuePoints=this.manager.getCuePoints(),this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR,(function(e){return t.onAdError(e)})),Object.keys(google.ima.AdEvent.Type).forEach((function(e){t.manager.addEventListener(google.ima.AdEvent.Type[e],(function(e){return t.onAdEvent(e)}))})),this.trigger("loaded")}}},{key:"addCuePoints",value:function(){var e=this;X(this.cuePoints)||this.cuePoints.forEach((function(t){if(0!==t&&-1!==t&&t<e.player.duration){var i=e.player.elements.progress;if(W(i)){var n=100/e.player.duration*t,a=ne("span",{class:e.player.config.classNames.cues});a.style.left="".concat(n.toString(),"%"),i.appendChild(a)}}}))}},{key:"onAdEvent",value:function(e){var t=this,i=this.player.elements.container,n=e.getAd(),a=e.getAdData();switch(function(e){Ae.call(t.player,t.player.media,"ads".concat(e.replace(/_/g,"").toLowerCase()))}(e.type),e.type){case google.ima.AdEvent.Type.LOADED:this.trigger("loaded"),this.pollCountdown(!0),n.isLinear()||(n.width=i.offsetWidth,n.height=i.offsetHeight);break;case google.ima.AdEvent.Type.STARTED:this.manager.setVolume(this.player.volume);break;case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:this.loadAds();break;case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:this.pauseContent();break;case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:this.pollCountdown(),this.resumeContent();break;case google.ima.AdEvent.Type.LOG:a.adError&&this.player.debug.warn("Non-fatal ad error: ".concat(a.adError.getMessage()))}}},{key:"onAdError",value:function(e){this.cancel(),this.player.debug.warn("Ads error",e)}},{key:"listeners",value:function(){var e,t=this,i=this.player.elements.container;this.player.on("canplay",(function(){t.addCuePoints()})),this.player.on("ended",(function(){t.loader.contentComplete()})),this.player.on("timeupdate",(function(){e=t.player.currentTime})),this.player.on("seeked",(function(){var i=t.player.currentTime;X(t.cuePoints)||t.cuePoints.forEach((function(n,a){e<n&&n<i&&(t.manager.discardAdBreak(),t.cuePoints.splice(a,1))}))})),window.addEventListener("resize",(function(){t.manager&&t.manager.resize(i.offsetWidth,i.offsetHeight,google.ima.ViewMode.NORMAL)}))}},{key:"play",value:function(){var e=this,t=this.player.elements.container;this.managerPromise||this.resumeContent(),this.managerPromise.then((function(){e.manager.setVolume(e.player.volume),e.elements.displayContainer.initialize();try{e.initialized||(e.manager.init(t.offsetWidth,t.offsetHeight,google.ima.ViewMode.NORMAL),e.manager.start()),e.initialized=!0}catch(t){e.onAdError(t)}})).catch((function(){}))}},{key:"resumeContent",value:function(){this.elements.container.style.zIndex="",this.playing=!1,this.player.media.play()}},{key:"pauseContent",value:function(){this.elements.container.style.zIndex=3,this.playing=!0,this.player.media.pause()}},{key:"cancel",value:function(){this.initialized&&this.resumeContent(),this.trigger("error"),this.loadAds()}},{key:"loadAds",value:function(){var e=this;this.managerPromise.then((function(){e.manager&&e.manager.destroy(),e.managerPromise=new Promise((function(t){e.on("loaded",t),e.player.debug.log(e.manager)})),e.requestAds()})).catch((function(){}))}},{key:"trigger",value:function(e){for(var t=this,i=arguments.length,n=new Array(i>1?i-1:0),a=1;a<i;a++)n[a-1]=arguments[a];var s=this.events[e];B(s)&&s.forEach((function(e){V(e)&&e.apply(t,n)}))}},{key:"on",value:function(e,t){return B(this.events[e])||(this.events[e]=[]),this.events[e].push(t),this}},{key:"startSafetyTimer",value:function(e,t){var i=this;this.player.debug.log("Safety timer invoked from: ".concat(t)),this.safetyTimer=setTimeout((function(){i.cancel(),i.clearSafetyTimer("startSafetyTimer()")}),e)}},{key:"clearSafetyTimer",value:function(e){q(this.safetyTimer)||(this.player.debug.log("Safety timer cleared from: ".concat(e)),clearTimeout(this.safetyTimer),this.safetyTimer=null)}},{key:"enabled",get:function(){var e=this.config;return this.player.isHTML5&&this.player.isVideo&&e.enabled&&(!X(e.publisherId)||Q(e.tagUrl))}},{key:"tagUrl",get:function(){var e=this.config;if(Q(e.tagUrl))return e.tagUrl;var t={AV_PUBLISHERID:"58c25bb0073ef448b1087ad6",AV_CHANNELID:"5a0458dc28a06145e4519d21",AV_URL:window.location.hostname,cb:Date.now(),AV_WIDTH:640,AV_HEIGHT:480,AV_CDIM2:e.publisherId};return"".concat("https://go.aniview.com/api/adserver6/vast/","?").concat(Xe(t))}}]),t}(),vt=function(e,t){var i={};return e>t.width/t.height?(i.width=t.width,i.height=1/e*t.width):(i.height=t.height,i.width=e*t.height),i},bt=function(){function t(i){e(this,t),this.player=i,this.thumbnails=[],this.loaded=!1,this.lastMouseMoveTime=Date.now(),this.mouseDown=!1,this.loadedImages=[],this.elements={thumb:{},scrubbing:{}},this.load()}return i(t,[{key:"load",value:function(){var e=this;this.player.elements.display.seekTooltip&&(this.player.elements.display.seekTooltip.hidden=this.enabled),this.enabled&&this.getThumbnails().then((function(){e.enabled&&(e.render(),e.determineContainerAutoSizing(),e.loaded=!0)}))}},{key:"getThumbnails",value:function(){var e=this;return new Promise((function(t){var i=e.player.config.previewThumbnails.src;if(X(i))throw new Error("Missing previewThumbnails.src config attribute");var n=(F(i)?[i]:i).map((function(t){return e.getThumbnail(t)}));Promise.all(n).then((function(){e.thumbnails.sort((function(e,t){return e.height-t.height})),e.player.debug.log("Preview thumbnails",e.thumbnails),t()}))}))}},{key:"getThumbnail",value:function(e){var t=this;return new Promise((function(i){Ve(e).then((function(n){var a,s,o={frames:(a=n,s=[],a.split(/\r\n\r\n|\n\n|\r\r/).forEach((function(e){var t={};e.split(/\r\n|\n|\r/).forEach((function(e){if(D(t.startTime)){if(!X(e.trim())&&X(t.text)){var i=e.trim().split("#xywh="),n=r(i,1);if(t.text=n[0],i[1]){var a=r(i[1].split(","),4);t.x=a[0],t.y=a[1],t.w=a[2],t.h=a[3]}}}else{var s=e.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/);s&&(t.startTime=60*Number(s[1]||0)*60+60*Number(s[2])+Number(s[3])+Number("0.".concat(s[4])),t.endTime=60*Number(s[6]||0)*60+60*Number(s[7])+Number(s[8])+Number("0.".concat(s[9])))}})),t.text&&s.push(t)})),s),height:null,urlPrefix:""};o.frames[0].text.startsWith("/")||o.frames[0].text.startsWith("http://")||o.frames[0].text.startsWith("https://")||(o.urlPrefix=e.substring(0,e.lastIndexOf("/")+1));var l=new Image;l.onload=function(){o.height=l.naturalHeight,o.width=l.naturalWidth,t.thumbnails.push(o),i()},l.src=o.urlPrefix+o.frames[0].text}))}))}},{key:"startMove",value:function(e){if(this.loaded&&z(e)&&["touchmove","mousemove"].includes(e.type)&&this.player.media.duration){if("touchmove"===e.type)this.seekTime=this.player.media.duration*(this.player.elements.inputs.seek.value/100);else{var t=this.player.elements.progress.getBoundingClientRect(),i=100/t.width*(e.pageX-t.left);this.seekTime=this.player.media.duration*(i/100),this.seekTime<0&&(this.seekTime=0),this.seekTime>this.player.media.duration-1&&(this.seekTime=this.player.media.duration-1),this.mousePosX=e.pageX,this.elements.thumb.time.innerText=Ke(this.seekTime)}this.showImageAtCurrentTime()}}},{key:"endMove",value:function(){this.toggleThumbContainer(!1,!0)}},{key:"startScrubbing",value:function(e){(q(e.button)||!1===e.button||0===e.button)&&(this.mouseDown=!0,this.player.media.duration&&(this.toggleScrubbingContainer(!0),this.toggleThumbContainer(!1,!0),this.showImageAtCurrentTime()))}},{key:"endScrubbing",value:function(){var e=this;this.mouseDown=!1,Math.ceil(this.lastTime)===Math.ceil(this.player.media.currentTime)?this.toggleScrubbingContainer(!1):Ce.call(this.player,this.player.media,"timeupdate",(function(){e.mouseDown||e.toggleScrubbingContainer(!1)}))}},{key:"listeners",value:function(){var e=this;this.player.on("play",(function(){e.toggleThumbContainer(!1,!0)})),this.player.on("seeked",(function(){e.toggleThumbContainer(!1)})),this.player.on("timeupdate",(function(){e.lastTime=e.player.media.currentTime}))}},{key:"render",value:function(){this.elements.thumb.container=ne("div",{class:this.player.config.classNames.previewThumbnails.thumbContainer}),this.elements.thumb.imageContainer=ne("div",{class:this.player.config.classNames.previewThumbnails.imageContainer}),this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);var e=ne("div",{class:this.player.config.classNames.previewThumbnails.timeContainer});this.elements.thumb.time=ne("span",{},"00:00"),e.appendChild(this.elements.thumb.time),this.elements.thumb.container.appendChild(e),W(this.player.elements.progress)&&this.player.elements.progress.appendChild(this.elements.thumb.container),this.elements.scrubbing.container=ne("div",{class:this.player.config.classNames.previewThumbnails.scrubbingContainer}),this.player.elements.wrapper.appendChild(this.elements.scrubbing.container)}},{key:"destroy",value:function(){this.elements.thumb.container&&this.elements.thumb.container.remove(),this.elements.scrubbing.container&&this.elements.scrubbing.container.remove()}},{key:"showImageAtCurrentTime",value:function(){var e=this;this.mouseDown?this.setScrubbingContainerSize():this.setThumbContainerSizeAndPos();var t=this.thumbnails[0].frames.findIndex((function(t){return e.seekTime>=t.startTime&&e.seekTime<=t.endTime})),i=t>=0,n=0;this.mouseDown||this.toggleThumbContainer(i),i&&(this.thumbnails.forEach((function(i,a){e.loadedImages.includes(i.frames[t].text)&&(n=a)})),t!==this.showingThumb&&(this.showingThumb=t,this.loadImage(n)))}},{key:"loadImage",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=this.showingThumb,n=this.thumbnails[t],a=n.urlPrefix,s=n.frames[i],r=n.frames[i].text,o=a+r;if(this.currentImageElement&&this.currentImageElement.dataset.filename===r)this.showImage(this.currentImageElement,s,t,i,r,!1),this.currentImageElement.dataset.index=i,this.removeOldImages(this.currentImageElement);else{this.loadingImage&&this.usingSprites&&(this.loadingImage.onload=null);var l=new Image;l.src=o,l.dataset.index=i,l.dataset.filename=r,this.showingThumbFilename=r,this.player.debug.log("Loading image: ".concat(o)),l.onload=function(){return e.showImage(l,s,t,i,r,!0)},this.loadingImage=l,this.removeOldImages(l)}}},{key:"showImage",value:function(e,t,i,n,a){var s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];this.player.debug.log("Showing thumb: ".concat(a,". num: ").concat(n,". qual: ").concat(i,". newimg: ").concat(s)),this.setImageSizeAndOffset(e,t),s&&(this.currentImageContainer.appendChild(e),this.currentImageElement=e,this.loadedImages.includes(a)||this.loadedImages.push(a)),this.preloadNearby(n,!0).then(this.preloadNearby(n,!1)).then(this.getHigherQuality(i,e,t,a))}},{key:"removeOldImages",value:function(e){var t=this;Array.from(this.currentImageContainer.children).forEach((function(i){if("img"===i.tagName.toLowerCase()){var n=t.usingSprites?500:1e3;if(i.dataset.index!==e.dataset.index&&!i.dataset.deleting){i.dataset.deleting=!0;var a=t.currentImageContainer;setTimeout((function(){a.removeChild(i),t.player.debug.log("Removing thumb: ".concat(i.dataset.filename))}),n)}}}))}},{key:"preloadNearby",value:function(e){var t=this,i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return new Promise((function(n){setTimeout((function(){var a=t.thumbnails[0].frames[e].text;if(t.showingThumbFilename===a){var s;s=i?t.thumbnails[0].frames.slice(e):t.thumbnails[0].frames.slice(0,e).reverse();var r=!1;s.forEach((function(e){var i=e.text;if(i!==a&&!t.loadedImages.includes(i)){r=!0,t.player.debug.log("Preloading thumb filename: ".concat(i));var s=t.thumbnails[0].urlPrefix+i,o=new Image;o.src=s,o.onload=function(){t.player.debug.log("Preloaded thumb filename: ".concat(i)),t.loadedImages.includes(i)||t.loadedImages.push(i),n()}}})),r||n()}}),300)}))}},{key:"getHigherQuality",value:function(e,t,i,n){var a=this;if(e<this.thumbnails.length-1){var s=t.naturalHeight;this.usingSprites&&(s=i.h),s<this.thumbContainerHeight&&setTimeout((function(){a.showingThumbFilename===n&&(a.player.debug.log("Showing higher quality thumb for: ".concat(n)),a.loadImage(e+1))}),300)}}},{key:"toggleThumbContainer",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=this.player.config.classNames.previewThumbnails.thumbContainerShown;this.elements.thumb.container.classList.toggle(i,e),!e&&t&&(this.showingThumb=null,this.showingThumbFilename=null)}},{key:"toggleScrubbingContainer",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=this.player.config.classNames.previewThumbnails.scrubbingContainerShown;this.elements.scrubbing.container.classList.toggle(t,e),e||(this.showingThumb=null,this.showingThumbFilename=null)}},{key:"determineContainerAutoSizing",value:function(){(this.elements.thumb.imageContainer.clientHeight>20||this.elements.thumb.imageContainer.clientWidth>20)&&(this.sizeSpecifiedInCSS=!0)}},{key:"setThumbContainerSizeAndPos",value:function(){if(this.sizeSpecifiedInCSS){if(this.elements.thumb.imageContainer.clientHeight>20&&this.elements.thumb.imageContainer.clientWidth<20){var e=Math.floor(this.elements.thumb.imageContainer.clientHeight*this.thumbAspectRatio);this.elements.thumb.imageContainer.style.width="".concat(e,"px")}else if(this.elements.thumb.imageContainer.clientHeight<20&&this.elements.thumb.imageContainer.clientWidth>20){var t=Math.floor(this.elements.thumb.imageContainer.clientWidth/this.thumbAspectRatio);this.elements.thumb.imageContainer.style.height="".concat(t,"px")}}else{var i=Math.floor(this.thumbContainerHeight*this.thumbAspectRatio);this.elements.thumb.imageContainer.style.height="".concat(this.thumbContainerHeight,"px"),this.elements.thumb.imageContainer.style.width="".concat(i,"px")}this.setThumbContainerPos()}},{key:"setThumbContainerPos",value:function(){var e=this.player.elements.progress.getBoundingClientRect(),t=this.player.elements.container.getBoundingClientRect(),i=this.elements.thumb.container,n=t.left-e.left+10,a=t.right-e.left-i.clientWidth-10,s=this.mousePosX-e.left-i.clientWidth/2;s<n&&(s=n),s>a&&(s=a),i.style.left="".concat(s,"px")}},{key:"setScrubbingContainerSize",value:function(){var e=vt(this.thumbAspectRatio,{width:this.player.media.clientWidth,height:this.player.media.clientHeight}),t=e.width,i=e.height;this.elements.scrubbing.container.style.width="".concat(t,"px"),this.elements.scrubbing.container.style.height="".concat(i,"px")}},{key:"setImageSizeAndOffset",value:function(e,t){if(this.usingSprites){var i=this.thumbContainerHeight/t.h;e.style.height="".concat(e.naturalHeight*i,"px"),e.style.width="".concat(e.naturalWidth*i,"px"),e.style.left="-".concat(t.x*i,"px"),e.style.top="-".concat(t.y*i,"px")}}},{key:"enabled",get:function(){return this.player.isHTML5&&this.player.isVideo&&this.player.config.previewThumbnails.enabled}},{key:"currentImageContainer",get:function(){return this.mouseDown?this.elements.scrubbing.container:this.elements.thumb.imageContainer}},{key:"usingSprites",get:function(){return Object.keys(this.thumbnails[0].frames[0]).includes("w")}},{key:"thumbAspectRatio",get:function(){return this.usingSprites?this.thumbnails[0].frames[0].w/this.thumbnails[0].frames[0].h:this.thumbnails[0].width/this.thumbnails[0].height}},{key:"thumbContainerHeight",get:function(){return this.mouseDown?vt(this.thumbAspectRatio,{width:this.player.media.clientWidth,height:this.player.media.clientHeight}).height:this.sizeSpecifiedInCSS?this.elements.thumb.imageContainer.clientHeight:Math.floor(this.player.media.clientWidth/this.thumbAspectRatio/4)}},{key:"currentImageElement",get:function(){return this.mouseDown?this.currentScrubbingImageElement:this.currentThumbnailImageElement},set:function(e){this.mouseDown?this.currentScrubbingImageElement=e:this.currentThumbnailImageElement=e}}]),t}(),wt={insertElements:function(e,t){var i=this;F(t)?ae(e,this.media,{src:t}):B(t)&&t.forEach((function(t){ae(e,i.media,t)}))},change:function(e){var t=this;Z(e,"sources.length")?(Ie.cancelRequests.call(this),this.destroy.call(this,(function(){t.options.quality=[],se(t.media),t.media=null,W(t.elements.container)&&t.elements.container.removeAttribute("class");var i=e.sources,n=e.type,a=r(i,1)[0],s=a.provider,o=void 0===s?et.html5:s,l=a.src,c="html5"===o?n:"div",u="html5"===o?{}:{src:l};Object.assign(t,{provider:o,type:n,supported:ve.check(n,o,t.config.playsinline),media:ne(c,u)}),t.elements.container.appendChild(t.media),R(e.autoplay)&&(t.config.autoplay=e.autoplay),t.isHTML5&&(t.config.crossorigin&&t.media.setAttribute("crossorigin",""),t.config.autoplay&&t.media.setAttribute("autoplay",""),X(e.poster)||(t.poster=e.poster),t.config.loop.active&&t.media.setAttribute("loop",""),t.config.muted&&t.media.setAttribute("muted",""),t.config.playsinline&&t.media.setAttribute("playsinline","")),ot.addStyleHook.call(t),t.isHTML5&&wt.insertElements.call(t,"source",i),t.config.title=e.title,gt.setup.call(t),t.isHTML5&&Object.keys(e).includes("tracks")&&wt.insertElements.call(t,"track",e.tracks),(t.isHTML5||t.isEmbed&&!t.supported.ui)&&ot.build.call(t),t.isHTML5&&t.media.load(),X(e.previewThumbnails)||(Object.assign(t.config.previewThumbnails,e.previewThumbnails),t.previewThumbnails&&t.previewThumbnails.loaded&&(t.previewThumbnails.destroy(),t.previewThumbnails=null),t.config.previewThumbnails.enabled&&(t.previewThumbnails=new bt(t))),t.fullscreen.update()}),!0)):this.debug.warn("Invalid source format")}};var kt,Tt=function(){function t(i,n){var a=this;if(e(this,t),this.timers={},this.ready=!1,this.loading=!1,this.failed=!1,this.touch=ve.touch,this.media=i,F(this.media)&&(this.media=document.querySelectorAll(this.media)),(window.jQuery&&this.media instanceof jQuery||U(this.media)||B(this.media))&&(this.media=this.media[0]),this.config=ee({},$e,t.defaults,n||{},function(){try{return JSON.parse(a.media.getAttribute("data-plyr-config"))}catch(e){return{}}}()),this.elements={container:null,captions:null,buttons:{},display:{},progress:{},inputs:{},settings:{popup:null,menu:null,panels:{},buttons:{}}},this.captions={active:null,currentTrack:-1,meta:new WeakMap},this.fullscreen={active:!1},this.options={speed:[],quality:[]},this.debug=new at(this.config.debug),this.debug.log("Config",this.config),this.debug.log("Support",ve),!q(this.media)&&W(this.media))if(this.media.plyr)this.debug.warn("Target already setup");else if(this.config.enabled)if(ve.check().api){var s=this.media.cloneNode(!0);s.autoplay=!1,this.elements.original=s;var r=this.media.tagName.toLowerCase(),o=null,l=null;switch(r){case"div":if(o=this.media.querySelector("iframe"),W(o)){if(l=Qe(o.getAttribute("src")),this.provider=function(e){return/^(https?:\/\/)?(www\.)?(youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$/.test(e)?et.youtube:/^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(e)?et.vimeo:null}(l.toString()),this.elements.container=this.media,this.media=o,this.elements.container.className="",l.search.length){var c=["1","true"];c.includes(l.searchParams.get("autoplay"))&&(this.config.autoplay=!0),c.includes(l.searchParams.get("loop"))&&(this.config.loop.active=!0),this.isYouTube?(this.config.playsinline=c.includes(l.searchParams.get("playsinline")),this.config.youtube.hl=l.searchParams.get("hl")):this.config.playsinline=!0}}else this.provider=this.media.getAttribute(this.config.attributes.embed.provider),this.media.removeAttribute(this.config.attributes.embed.provider);if(X(this.provider)||!Object.keys(et).includes(this.provider))return void this.debug.error("Setup failed: Invalid provider");this.type=it;break;case"video":case"audio":this.type=r,this.provider=et.html5,this.media.hasAttribute("crossorigin")&&(this.config.crossorigin=!0),this.media.hasAttribute("autoplay")&&(this.config.autoplay=!0),(this.media.hasAttribute("playsinline")||this.media.hasAttribute("webkit-playsinline"))&&(this.config.playsinline=!0),this.media.hasAttribute("muted")&&(this.config.muted=!0),this.media.hasAttribute("loop")&&(this.config.loop.active=!0);break;default:return void this.debug.error("Setup failed: unsupported type")}this.supported=ve.check(this.type,this.provider,this.config.playsinline),this.supported.api?(this.eventListeners=[],this.listeners=new lt(this),this.storage=new Re(this),this.media.plyr=this,W(this.elements.container)||(this.elements.container=ne("div",{tabindex:0}),te(this.media,this.elements.container)),ot.addStyleHook.call(this),gt.setup.call(this),this.config.debug&&ke.call(this,this.elements.container,this.config.events.join(" "),(function(e){a.debug.log("event: ".concat(e.type))})),(this.isHTML5||this.isEmbed&&!this.supported.ui)&&ot.build.call(this),this.listeners.container(),this.listeners.global(),this.fullscreen=new st(this),this.config.ads.enabled&&(this.ads=new yt(this)),this.isHTML5&&this.config.autoplay&&setTimeout((function(){return a.play()}),10),this.lastSeekTime=0,this.config.previewThumbnails.enabled&&(this.previewThumbnails=new bt(this))):this.debug.error("Setup failed: no support")}else this.debug.error("Setup failed: no support");else this.debug.error("Setup failed: disabled by config");else this.debug.error("Setup failed: no suitable element passed")}return i(t,[{key:"play",value:function(){var e=this;return V(this.media.play)?(this.ads&&this.ads.enabled&&this.ads.managerPromise.then((function(){return e.ads.play()})).catch((function(){return e.media.play()})),this.media.play()):null}},{key:"pause",value:function(){return this.playing&&V(this.media.pause)?this.media.pause():null}},{key:"togglePlay",value:function(e){return(R(e)?e:!this.playing)?this.play():this.pause()}},{key:"stop",value:function(){this.isHTML5?(this.pause(),this.restart()):V(this.media.stop)&&this.media.stop()}},{key:"restart",value:function(){this.currentTime=0}},{key:"rewind",value:function(e){this.currentTime-=D(e)?e:this.config.seekTime}},{key:"forward",value:function(e){this.currentTime+=D(e)?e:this.config.seekTime}},{key:"increaseVolume",value:function(e){var t=this.media.muted?0:this.volume;this.volume=t+(D(e)?e:0)}},{key:"decreaseVolume",value:function(e){this.increaseVolume(-e)}},{key:"toggleCaptions",value:function(e){Je.toggle.call(this,e,!1)}},{key:"airplay",value:function(){ve.airplay&&this.media.webkitShowPlaybackTargetPicker()}},{key:"toggleControls",value:function(e){if(this.supported.ui&&!this.isAudio){var t=de(this.elements.container,this.config.classNames.hideControls),i=void 0===e?void 0:!e,n=ue(this.elements.container,this.config.classNames.hideControls,i);if(n&&this.config.controls.includes("settings")&&!X(this.config.settings)&&Ye.toggleMenu.call(this,!1),n!==t){var a=n?"controlshidden":"controlsshown";Ae.call(this,this.media,a)}return!n}return!1}},{key:"on",value:function(e,t){ke.call(this,this.elements.container,e,t)}},{key:"once",value:function(e,t){Ce.call(this,this.elements.container,e,t)}},{key:"off",value:function(e,t){Te(this.elements.container,e,t)}},{key:"destroy",value:function(e){var t=this,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.ready){var n=function(){document.body.style.overflow="",t.embed=null,i?(Object.keys(t.elements).length&&(se(t.elements.buttons.play),se(t.elements.captions),se(t.elements.controls),se(t.elements.wrapper),t.elements.buttons.play=null,t.elements.captions=null,t.elements.controls=null,t.elements.wrapper=null),V(e)&&e()):(Ee.call(t),oe(t.elements.original,t.elements.container),Ae.call(t,t.elements.original,"destroyed",!0),V(e)&&e.call(t.elements.original),t.ready=!1,setTimeout((function(){t.elements=null,t.media=null}),200))};this.stop(),clearTimeout(this.timers.loading),clearTimeout(this.timers.controls),clearTimeout(this.timers.resized),this.isHTML5?(ot.toggleNativeControls.call(this,!0),n()):this.isYouTube?(clearInterval(this.timers.buffering),clearInterval(this.timers.playing),null!==this.embed&&V(this.embed.destroy)&&this.embed.destroy(),n()):this.isVimeo&&(null!==this.embed&&this.embed.unload().then(n),setTimeout(n,200))}}},{key:"supports",value:function(e){return ve.mime.call(this,e)}},{key:"isHTML5",get:function(){return this.provider===et.html5}},{key:"isEmbed",get:function(){return this.isYouTube||this.isVimeo}},{key:"isYouTube",get:function(){return this.provider===et.youtube}},{key:"isVimeo",get:function(){return this.provider===et.vimeo}},{key:"isVideo",get:function(){return this.type===it}},{key:"isAudio",get:function(){return this.type===tt}},{key:"playing",get:function(){return Boolean(this.ready&&!this.paused&&!this.ended)}},{key:"paused",get:function(){return Boolean(this.media.paused)}},{key:"stopped",get:function(){return Boolean(this.paused&&0===this.currentTime)}},{key:"ended",get:function(){return Boolean(this.media.ended)}},{key:"currentTime",set:function(e){if(this.duration){var t=D(e)&&e>0;this.media.currentTime=t?Math.min(e,this.duration):0,this.debug.log("Seeking to ".concat(this.currentTime," seconds"))}},get:function(){return Number(this.media.currentTime)}},{key:"buffered",get:function(){var e=this.media.buffered;return D(e)?e:e&&e.length&&this.duration>0?e.end(0)/this.duration:0}},{key:"seeking",get:function(){return Boolean(this.media.seeking)}},{key:"duration",get:function(){var e=parseFloat(this.config.duration),t=(this.media||{}).duration,i=D(t)&&t!==1/0?t:0;return e||i}},{key:"volume",set:function(e){var t=e;F(t)&&(t=Number(t)),D(t)||(t=this.storage.get("volume")),D(t)||(t=this.config.volume),t>1&&(t=1),t<0&&(t=0),this.config.volume=t,this.media.volume=t,!X(e)&&this.muted&&t>0&&(this.muted=!1)},get:function(){return Number(this.media.volume)}},{key:"muted",set:function(e){var t=e;R(t)||(t=this.storage.get("muted")),R(t)||(t=this.config.muted),this.config.muted=t,this.media.muted=t},get:function(){return Boolean(this.media.muted)}},{key:"hasAudio",get:function(){return!this.isHTML5||(!!this.isAudio||(Boolean(this.media.mozHasAudio)||Boolean(this.media.webkitAudioDecodedByteCount)||Boolean(this.media.audioTracks&&this.media.audioTracks.length)))}},{key:"speed",set:function(e){var t=this,i=null;D(e)&&(i=e),D(i)||(i=this.storage.get("speed")),D(i)||(i=this.config.speed.selected);var n=this.minimumSpeed,a=this.maximumSpeed;i=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:255;return Math.min(Math.max(e,t),i)}(i,n,a),this.config.speed.selected=i,setTimeout((function(){t.media.playbackRate=i}),0)},get:function(){return Number(this.media.playbackRate)}},{key:"minimumSpeed",get:function(){return this.isYouTube?Math.min.apply(Math,o(this.options.speed)):this.isVimeo?.5:.0625}},{key:"maximumSpeed",get:function(){return this.isYouTube?Math.max.apply(Math,o(this.options.speed)):this.isVimeo?2:16}},{key:"quality",set:function(e){var t=this.config.quality,i=this.options.quality;if(i.length){var n=[!X(e)&&Number(e),this.storage.get("quality"),t.selected,t.default].find(D),a=!0;if(!i.includes(n)){var s=function(e,t){return B(e)&&e.length?e.reduce((function(e,i){return Math.abs(i-t)<Math.abs(e-t)?i:e})):null}(i,n);this.debug.warn("Unsupported quality option: ".concat(n,", using ").concat(s," instead")),n=s,a=!1}t.selected=n,this.media.quality=n,a&&this.storage.set({quality:n})}},get:function(){return this.media.quality}},{key:"loop",set:function(e){var t=R(e)?e:this.config.loop.active;this.config.loop.active=t,this.media.loop=t},get:function(){return Boolean(this.media.loop)}},{key:"source",set:function(e){wt.change.call(this,e)},get:function(){return this.media.currentSrc}},{key:"download",get:function(){var e=this.config.urls.download;return Q(e)?e:this.source},set:function(e){Q(e)&&(this.config.urls.download=e,Ye.setDownloadUrl.call(this))}},{key:"poster",set:function(e){this.isVideo?ot.setPoster.call(this,e,!1).catch((function(){})):this.debug.warn("Poster can only be set for video")},get:function(){return this.isVideo?this.media.getAttribute("poster"):null}},{key:"ratio",get:function(){if(!this.isVideo)return null;var e=Me(Ne.call(this));return B(e)?e.join(":"):e},set:function(e){this.isVideo?F(e)&&Pe(e)?(this.config.ratio=e,xe.call(this)):this.debug.error("Invalid aspect ratio specified (".concat(e,")")):this.debug.warn("Aspect ratio can only be set for video")}},{key:"autoplay",set:function(e){var t=R(e)?e:this.config.autoplay;this.config.autoplay=t},get:function(){return Boolean(this.config.autoplay)}},{key:"currentTrack",set:function(e){Je.set.call(this,e,!1)},get:function(){var e=this.captions,t=e.toggled,i=e.currentTrack;return t?i:-1}},{key:"language",set:function(e){Je.setLanguage.call(this,e,!1)},get:function(){return(Je.getCurrentTrack.call(this)||{}).language}},{key:"pip",set:function(e){if(ve.pip){var t=R(e)?e:!this.pip;V(this.media.webkitSetPresentationMode)&&this.media.webkitSetPresentationMode(t?Ge:Ze),V(this.media.requestPictureInPicture)&&(!this.pip&&t?this.media.requestPictureInPicture():this.pip&&!t&&document.exitPictureInPicture())}},get:function(){return ve.pip?X(this.media.webkitPresentationMode)?this.media===document.pictureInPictureElement:this.media.webkitPresentationMode===Ge:null}}],[{key:"supported",value:function(e,t,i){return ve.check(e,t,i)}},{key:"loadSprite",value:function(e,t){return Be(e,t)}},{key:"setup",value:function(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=null;return F(e)?n=Array.from(document.querySelectorAll(e)):U(e)?n=Array.from(e):B(e)&&(n=e.filter(W)),X(n)?null:n.map((function(e){return new t(e,i)}))}}]),t}();return Tt.defaults=(kt=$e,JSON.parse(JSON.stringify(kt))),Tt}));
//# sourceMappingURL=plyr.js.map


!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.Hls=e():t.Hls=e()}(this,function(){return function(t){function e(i){if(r[i])return r[i].exports;var a=r[i]={i:i,l:!1,exports:{}};return t[i].call(a.exports,a,a.exports,e),a.l=!0,a.exports}var r={};return e.m=t,e.c=r,e.d=function(t,r,i){e.o(t,r)||Object.defineProperty(t,r,{configurable:!1,enumerable:!0,get:i})},e.n=function(t){var r=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(r,"a",r),r},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="/dist/",e(e.s=27)}([function(t,e,r){"use strict";function i(){}function a(t,e){return e="["+t+"] > "+e}function n(t){var e=self.console[t];return e?function(){for(var r=arguments.length,i=Array(r),n=0;n<r;n++)i[n]=arguments[n];i[0]&&(i[0]=a(t,i[0])),e.apply(self.console,i)}:i}function o(t){for(var e=arguments.length,r=Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];r.forEach(function(e){u[e]=t[e]?t[e].bind(t):n(e)})}r.d(e,"a",function(){return d}),r.d(e,"b",function(){return c});var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},l={trace:i,debug:i,log:i,warn:i,info:i,error:i},u=l,d=function(t){if(!0===t||"object"===(void 0===t?"undefined":s(t))){o(t,"debug","log","info","warn","error");try{u.log()}catch(t){u=l}}else u=l},c=u},function(t,e,r){"use strict";var i={MEDIA_ATTACHING:"hlsMediaAttaching",MEDIA_ATTACHED:"hlsMediaAttached",MEDIA_DETACHING:"hlsMediaDetaching",MEDIA_DETACHED:"hlsMediaDetached",BUFFER_RESET:"hlsBufferReset",BUFFER_CODECS:"hlsBufferCodecs",BUFFER_CREATED:"hlsBufferCreated",BUFFER_APPENDING:"hlsBufferAppending",BUFFER_APPENDED:"hlsBufferAppended",BUFFER_EOS:"hlsBufferEos",BUFFER_FLUSHING:"hlsBufferFlushing",BUFFER_FLUSHED:"hlsBufferFlushed",MANIFEST_LOADING:"hlsManifestLoading",MANIFEST_LOADED:"hlsManifestLoaded",MANIFEST_PARSED:"hlsManifestParsed",LEVEL_SWITCHING:"hlsLevelSwitching",LEVEL_SWITCHED:"hlsLevelSwitched",LEVEL_LOADING:"hlsLevelLoading",LEVEL_LOADED:"hlsLevelLoaded",LEVEL_UPDATED:"hlsLevelUpdated",LEVEL_PTS_UPDATED:"hlsLevelPtsUpdated",AUDIO_TRACKS_UPDATED:"hlsAudioTracksUpdated",AUDIO_TRACK_SWITCHING:"hlsAudioTrackSwitching",AUDIO_TRACK_SWITCHED:"hlsAudioTrackSwitched",AUDIO_TRACK_LOADING:"hlsAudioTrackLoading",AUDIO_TRACK_LOADED:"hlsAudioTrackLoaded",SUBTITLE_TRACKS_UPDATED:"hlsSubtitleTracksUpdated",SUBTITLE_TRACK_SWITCH:"hlsSubtitleTrackSwitch",SUBTITLE_TRACK_LOADING:"hlsSubtitleTrackLoading",SUBTITLE_TRACK_LOADED:"hlsSubtitleTrackLoaded",SUBTITLE_FRAG_PROCESSED:"hlsSubtitleFragProcessed",INIT_PTS_FOUND:"hlsInitPtsFound",FRAG_LOADING:"hlsFragLoading",FRAG_LOAD_PROGRESS:"hlsFragLoadProgress",FRAG_LOAD_EMERGENCY_ABORTED:"hlsFragLoadEmergencyAborted",FRAG_LOADED:"hlsFragLoaded",FRAG_DECRYPTED:"hlsFragDecrypted",FRAG_PARSING_INIT_SEGMENT:"hlsFragParsingInitSegment",FRAG_PARSING_USERDATA:"hlsFragParsingUserdata",FRAG_PARSING_METADATA:"hlsFragParsingMetadata",FRAG_PARSING_DATA:"hlsFragParsingData",FRAG_PARSED:"hlsFragParsed",FRAG_BUFFERED:"hlsFragBuffered",FRAG_CHANGED:"hlsFragChanged",FPS_DROP:"hlsFpsDrop",FPS_DROP_LEVEL_CAPPING:"hlsFpsDropLevelCapping",ERROR:"hlsError",DESTROYING:"hlsDestroying",KEY_LOADING:"hlsKeyLoading",KEY_LOADED:"hlsKeyLoaded",STREAM_STATE_TRANSITION:"hlsStreamStateTransition"};e.a=i},function(t,e,r){"use strict";r.d(e,"b",function(){return i}),r.d(e,"a",function(){return a});var i={NETWORK_ERROR:"networkError",MEDIA_ERROR:"mediaError",KEY_SYSTEM_ERROR:"keySystemError",MUX_ERROR:"muxError",OTHER_ERROR:"otherError"},a={KEY_SYSTEM_NO_KEYS:"keySystemNoKeys",KEY_SYSTEM_NO_ACCESS:"keySystemNoAccess",KEY_SYSTEM_NO_SESSION:"keySystemNoSession",KEY_SYSTEM_LICENSE_REQUEST_FAILED:"keySystemLicenseRequestFailed",MANIFEST_LOAD_ERROR:"manifestLoadError",MANIFEST_LOAD_TIMEOUT:"manifestLoadTimeOut",MANIFEST_PARSING_ERROR:"manifestParsingError",MANIFEST_INCOMPATIBLE_CODECS_ERROR:"manifestIncompatibleCodecsError",LEVEL_LOAD_ERROR:"levelLoadError",LEVEL_LOAD_TIMEOUT:"levelLoadTimeOut",LEVEL_SWITCH_ERROR:"levelSwitchError",AUDIO_TRACK_LOAD_ERROR:"audioTrackLoadError",AUDIO_TRACK_LOAD_TIMEOUT:"audioTrackLoadTimeOut",FRAG_LOAD_ERROR:"fragLoadError",FRAG_LOAD_TIMEOUT:"fragLoadTimeOut",FRAG_DECRYPT_ERROR:"fragDecryptError",FRAG_PARSING_ERROR:"fragParsingError",REMUX_ALLOC_ERROR:"remuxAllocError",KEY_LOAD_ERROR:"keyLoadError",KEY_LOAD_TIMEOUT:"keyLoadTimeOut",BUFFER_ADD_CODEC_ERROR:"bufferAddCodecError",BUFFER_APPEND_ERROR:"bufferAppendError",BUFFER_APPENDING_ERROR:"bufferAppendingError",BUFFER_STALLED_ERROR:"bufferStalledError",BUFFER_FULL_ERROR:"bufferFullError",BUFFER_SEEK_OVER_HOLE:"bufferSeekOverHole",BUFFER_NUDGE_ON_STALL:"bufferNudgeOnStall",INTERNAL_EXCEPTION:"internalException"}},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(0),n=r(2),o=r(1),s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},l=new Set(["hlsEventGeneric","hlsHandlerDestroying","hlsHandlerDestroyed"]),u=function(){function t(e){i(this,t),this.hls=e,this.onEvent=this.onEvent.bind(this);for(var r=arguments.length,a=Array(r>1?r-1:0),n=1;n<r;n++)a[n-1]=arguments[n];this.handledEvents=a,this.useGenericHandler=!0,this.registerListeners()}return t.prototype.destroy=function(){this.onHandlerDestroying(),this.unregisterListeners(),this.onHandlerDestroyed()},t.prototype.onHandlerDestroying=function(){},t.prototype.onHandlerDestroyed=function(){},t.prototype.isEventHandler=function(){return"object"===s(this.handledEvents)&&this.handledEvents.length&&"function"==typeof this.onEvent},t.prototype.registerListeners=function(){this.isEventHandler()&&this.handledEvents.forEach(function(t){if(l.has(t))throw new Error("Forbidden event-name: "+t);this.hls.on(t,this.onEvent)},this)},t.prototype.unregisterListeners=function(){this.isEventHandler()&&this.handledEvents.forEach(function(t){this.hls.off(t,this.onEvent)},this)},t.prototype.onEvent=function(t,e){this.onEventGeneric(t,e)},t.prototype.onEventGeneric=function(t,e){var r=function(t,e){var r="on"+t.replace("hls","");if("function"!=typeof this[r])throw new Error("Event "+t+" has no generic handler in this "+this.constructor.name+" class (tried "+r+")");return this[r].bind(this,e)};try{r.call(this,t,e).call()}catch(e){a.b.error("An internal error happened while handling event "+t+'. Error message: "'+e.message+'". Here is a stacktrace:',e),this.hls.trigger(o.a.ERROR,{type:n.b.OTHER_ERROR,details:n.a.INTERNAL_EXCEPTION,fatal:!1,event:t,err:e})}},t}();e.a=u},function(t,e,r){!function(e){var r=/^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/\;?#]*)?(.*?)??(;.*?)?(\?.*?)?(#.*?)?$/,i=/^([^\/;?#]*)(.*)$/,a=/(?:\/|^)\.(?=\/)/g,n=/(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g,o={buildAbsoluteURL:function(t,e,r){if(r=r||{},t=t.trim(),!(e=e.trim())){if(!r.alwaysNormalize)return t;var a=this.parseURL(t);if(!s)throw new Error("Error trying to parse base URL.");return a.path=o.normalizePath(a.path),o.buildURLFromParts(a)}var n=this.parseURL(e);if(!n)throw new Error("Error trying to parse relative URL.");if(n.scheme)return r.alwaysNormalize?(n.path=o.normalizePath(n.path),o.buildURLFromParts(n)):e;var s=this.parseURL(t);if(!s)throw new Error("Error trying to parse base URL.");if(!s.netLoc&&s.path&&"/"!==s.path[0]){var l=i.exec(s.path);s.netLoc=l[1],s.path=l[2]}s.netLoc&&!s.path&&(s.path="/");var u={scheme:s.scheme,netLoc:n.netLoc,path:null,params:n.params,query:n.query,fragment:n.fragment};if(!n.netLoc&&(u.netLoc=s.netLoc,"/"!==n.path[0]))if(n.path){var d=s.path,c=d.substring(0,d.lastIndexOf("/")+1)+n.path;u.path=o.normalizePath(c)}else u.path=s.path,n.params||(u.params=s.params,n.query||(u.query=s.query));return null===u.path&&(u.path=r.alwaysNormalize?o.normalizePath(n.path):n.path),o.buildURLFromParts(u)},parseURL:function(t){var e=r.exec(t);return e?{scheme:e[1]||"",netLoc:e[2]||"",path:e[3]||"",params:e[4]||"",query:e[5]||"",fragment:e[6]||""}:null},normalizePath:function(t){for(t=t.split("").reverse().join("").replace(a,"");t.length!==(t=t.replace(n,"")).length;);return t.split("").reverse().join("")},buildURLFromParts:function(t){return t.scheme+t.netLoc+t.path+t.params+t.query+t.fragment}};t.exports=o}()},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.d(e,"b",function(){return n});var a=function(){function t(){i(this,t)}return t.isHeader=function(t,e){return e+10<=t.length&&73===t[e]&&68===t[e+1]&&51===t[e+2]&&t[e+3]<255&&t[e+4]<255&&t[e+6]<128&&t[e+7]<128&&t[e+8]<128&&t[e+9]<128},t.isFooter=function(t,e){return e+10<=t.length&&51===t[e]&&68===t[e+1]&&73===t[e+2]&&t[e+3]<255&&t[e+4]<255&&t[e+6]<128&&t[e+7]<128&&t[e+8]<128&&t[e+9]<128},t.getID3Data=function(e,r){for(var i=r,a=0;t.isHeader(e,r);){a+=10;a+=t._readSize(e,r+6),t.isFooter(e,r+10)&&(a+=10),r+=a}if(a>0)return e.subarray(i,i+a)},t._readSize=function(t,e){var r=0;return r=(127&t[e])<<21,r|=(127&t[e+1])<<14,r|=(127&t[e+2])<<7,r|=127&t[e+3]},t.getTimeStamp=function(e){for(var r=t.getID3Frames(e),i=0;i<r.length;i++){var a=r[i];if(t.isTimeStampFrame(a))return t._readTimeStamp(a)}},t.isTimeStampFrame=function(t){return t&&"PRIV"===t.key&&"com.apple.streaming.transportStreamTimestamp"===t.info},t._getFrameData=function(e){var r=String.fromCharCode(e[0],e[1],e[2],e[3]),i=t._readSize(e,4);return{type:r,size:i,data:e.subarray(10,10+i)}},t.getID3Frames=function(e){for(var r=0,i=[];t.isHeader(e,r);){var a=t._readSize(e,r+6);r+=10;for(var n=r+a;r+8<n;){var o=t._getFrameData(e.subarray(r)),s=t._decodeFrame(o);s&&i.push(s),r+=o.size+10}t.isFooter(e,r)&&(r+=10)}return i},t._decodeFrame=function(e){return"PRIV"===e.type?t._decodePrivFrame(e):"T"===e.type[0]?t._decodeTextFrame(e):"W"===e.type[0]?t._decodeURLFrame(e):void 0},t._readTimeStamp=function(t){if(8===t.data.byteLength){var e=new Uint8Array(t.data),r=1&e[3],i=(e[4]<<23)+(e[5]<<15)+(e[6]<<7)+e[7];return i/=45,r&&(i+=47721858.84),Math.round(i)}},t._decodePrivFrame=function(e){if(!(e.size<2)){var r=t._utf8ArrayToStr(e.data,!0),i=new Uint8Array(e.data.subarray(r.length+1));return{key:e.type,info:r,data:i.buffer}}},t._decodeTextFrame=function(e){if(!(e.size<2)){if("TXXX"===e.type){var r=1,i=t._utf8ArrayToStr(e.data.subarray(r));r+=i.length+1;var a=t._utf8ArrayToStr(e.data.subarray(r));return{key:e.type,info:i,data:a}}var n=t._utf8ArrayToStr(e.data.subarray(1));return{key:e.type,data:n}}},t._decodeURLFrame=function(e){if("WXXX"===e.type){if(e.size<2)return;var r=1,i=t._utf8ArrayToStr(e.data.subarray(r));r+=i.length+1;var a=t._utf8ArrayToStr(e.data.subarray(r));return{key:e.type,info:i,data:a}}var n=t._utf8ArrayToStr(e.data);return{key:e.type,data:n}},t._utf8ArrayToStr=function(t){for(var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=t.length,i=void 0,a=void 0,n=void 0,o="",s=0;s<r;){if(0===(i=t[s++])&&e)return o;if(0!==i&&3!==i)switch(i>>4){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:o+=String.fromCharCode(i);break;case 12:case 13:a=t[s++],o+=String.fromCharCode((31&i)<<6|63&a);break;case 14:a=t[s++],n=t[s++],o+=String.fromCharCode((15&i)<<12|(63&a)<<6|(63&n)<<0)}}return o},t}(),n=a._utf8ArrayToStr;e.a=a},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(4),n=r.n(a),o=r(16),s=function(){function t(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,r,i){return r&&t(e.prototype,r),i&&t(e,i),e}}(),l=function(){function t(){var e;i(this,t),this._url=null,this._byteRange=null,this._decryptdata=null,this.tagList=[],this._elementaryStreams=(e={},e[t.ElementaryStreamTypes.AUDIO]=!1,e[t.ElementaryStreamTypes.VIDEO]=!1,e)}return t.prototype.addElementaryStream=function(t){this._elementaryStreams[t]=!0},t.prototype.hasElementaryStream=function(t){return!0===this._elementaryStreams[t]},t.prototype.createInitializationVector=function(t){for(var e=new Uint8Array(16),r=12;r<16;r++)e[r]=t>>8*(15-r)&255;return e},t.prototype.fragmentDecryptdataFromLevelkey=function(t,e){var r=t;return t&&t.method&&t.uri&&!t.iv&&(r=new o.a,r.method=t.method,r.baseuri=t.baseuri,r.reluri=t.reluri,r.iv=this.createInitializationVector(e)),r},s(t,[{key:"url",get:function(){return!this._url&&this.relurl&&(this._url=n.a.buildAbsoluteURL(this.baseurl,this.relurl,{alwaysNormalize:!0})),this._url},set:function(t){this._url=t}},{key:"programDateTime",get:function(){return!this._programDateTime&&this.rawProgramDateTime&&(this._programDateTime=new Date(Date.parse(this.rawProgramDateTime))),this._programDateTime}},{key:"byteRange",get:function(){if(!this._byteRange&&!this.rawByteRange)return[];if(this._byteRange)return this._byteRange;var t=[];if(this.rawByteRange){var e=this.rawByteRange.split("@",2);if(1===e.length){var r=this.lastByteRangeEndOffset;t[0]=r||0}else t[0]=parseInt(e[1]);t[1]=parseInt(e[0])+t[0],this._byteRange=t}return t}},{key:"byteRangeStartOffset",get:function(){return this.byteRange[0]}},{key:"byteRangeEndOffset",get:function(){return this.byteRange[1]}},{key:"decryptdata",get:function(){return this._decryptdata||(this._decryptdata=this.fragmentDecryptdataFromLevelkey(this.levelkey,this.sn)),this._decryptdata}}],[{key:"ElementaryStreamTypes",get:function(){return{AUDIO:"audio",VIDEO:"video"}}}]),t}();e.a=l},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}r.d(e,"a",function(){return l}),r.d(e,"b",function(){return u});var o=r(3),s=r(1),l={NOT_LOADED:"NOT_LOADED",APPENDING:"APPENDING",PARTIAL:"PARTIAL",OK:"OK"},u=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,s.a.BUFFER_APPENDED,s.a.FRAG_BUFFERED,s.a.FRAG_LOADED));return n.bufferPadding=.2,n.fragments=Object.create(null),n.timeRanges=Object.create(null),n.config=r.config,n}return n(e,t),e.prototype.destroy=function(){this.fragments=null,this.timeRanges=null,this.config=null,o.a.prototype.destroy.call(this),t.prototype.destroy.call(this)},e.prototype.getBufferedFrag=function(t,e){var r=this.fragments,i=Object.keys(r).filter(function(i){var a=r[i];if(a.body.type!==e)return!1;if(!a.buffered)return!1;var n=a.body;return n.startPTS<=t&&t<=n.endPTS});if(0===i.length)return null;var a=i.pop();return r[a].body},e.prototype.detectEvictedFragments=function(t,e){var r=this,i=void 0,a=void 0;Object.keys(this.fragments).forEach(function(n){var o=r.fragments[n];if(!0===o.buffered){var s=o.range[t];if(s){i=s.time;for(var l=0;l<i.length;l++)if(a=i[l],!1===r.isTimeBuffered(a.startPTS,a.endPTS,e)){r.removeFragment(o.body);break}}}})},e.prototype.detectPartialFragments=function(t){var e=this,r=this.getFragmentKey(t),i=this.fragments[r];i&&(i.buffered=!0,Object.keys(this.timeRanges).forEach(function(r){if(!0===t.hasElementaryStream(r)){var a=e.timeRanges[r];i.range[r]=e.getBufferedTimes(t.startPTS,t.endPTS,a)}}))},e.prototype.getBufferedTimes=function(t,e,r){for(var i=[],a=void 0,n=void 0,o=!1,s=0;s<r.length;s++){if(a=r.start(s)-this.bufferPadding,n=r.end(s)+this.bufferPadding,t>=a&&e<=n){i.push({startPTS:Math.max(t,r.start(s)),endPTS:Math.min(e,r.end(s))});break}if(t<n&&e>a)i.push({startPTS:Math.max(t,r.start(s)),endPTS:Math.min(e,r.end(s))}),o=!0;else if(e<=a)break}return{time:i,partial:o}},e.prototype.getFragmentKey=function(t){return t.type+"_"+t.level+"_"+t.sn},e.prototype.getPartialFragment=function(t){var e=this,r=void 0,i=void 0,a=void 0,n=null,o=0;return Object.keys(this.fragments).forEach(function(s){var l=e.fragments[s];e.isPartial(l)&&(i=l.body.startPTS-e.bufferPadding,a=l.body.endPTS+e.bufferPadding,t>=i&&t<=a&&(r=Math.min(t-i,a-t),o<=r&&(n=l.body,o=r)))}),n},e.prototype.getState=function(t){var e=this.getFragmentKey(t),r=this.fragments[e],i=l.NOT_LOADED;return void 0!==r&&(i=r.buffered?!0===this.isPartial(r)?l.PARTIAL:l.OK:l.APPENDING),i},e.prototype.isPartial=function(t){return!0===t.buffered&&(void 0!==t.range.video&&!0===t.range.video.partial||void 0!==t.range.audio&&!0===t.range.audio.partial)},e.prototype.isTimeBuffered=function(t,e,r){for(var i=void 0,a=void 0,n=0;n<r.length;n++){if(i=r.start(n)-this.bufferPadding,a=r.end(n)+this.bufferPadding,t>=i&&e<=a)return!0;if(e<=i)return!1}return!1},e.prototype.onFragLoaded=function(t){var e=t.frag;if(!isNaN(e.sn)){var r=this.getFragmentKey(e),i={body:e,range:Object.create(null),buffered:!1};this.fragments[r]=i}},e.prototype.onBufferAppended=function(t){var e=this;this.timeRanges=t.timeRanges,Object.keys(this.timeRanges).forEach(function(t){var r=e.timeRanges[t];e.detectEvictedFragments(t,r)})},e.prototype.onFragBuffered=function(t){this.detectPartialFragments(t.frag)},e.prototype.hasFragment=function(t){var e=this.getFragmentKey(t);return void 0!==this.fragments[e]},e.prototype.removeFragment=function(t){var e=this.getFragmentKey(t);delete this.fragments[e]},e.prototype.removeAllFragments=function(){this.fragments=Object.create(null)},e}(o.a)},function(t,e,r){"use strict";var i={search:function(t,e){for(var r=0,i=t.length-1,a=null,n=null;r<=i;){a=(r+i)/2|0,n=t[a];var o=e(n);if(o>0)r=a+1;else{if(!(o<0))return n;i=a-1}}return null}};e.a=i},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}r.d(e,"a",function(){return a});var a=function(){function t(){i(this,t)}return t.isBuffered=function(t,e){try{if(t)for(var r=t.buffered,i=0;i<r.length;i++)if(e>=r.start(i)&&e<=r.end(i))return!0}catch(t){}return!1},t.bufferInfo=function(t,e,r){try{if(t){var i=t.buffered,a=[],n=void 0;for(n=0;n<i.length;n++)a.push({start:i.start(n),end:i.end(n)});return this.bufferedInfo(a,e,r)}}catch(t){}return{len:0,start:e,end:e,nextStart:void 0}},t.bufferedInfo=function(t,e,r){var i=[],a=void 0,n=void 0,o=void 0,s=void 0,l=void 0;for(t.sort(function(t,e){var r=t.start-e.start;return r||e.end-t.end}),l=0;l<t.length;l++){var u=i.length;if(u){var d=i[u-1].end;t[l].start-d<r?t[l].end>d&&(i[u-1].end=t[l].end):i.push(t[l])}else i.push(t[l])}for(l=0,a=0,n=o=e;l<i.length;l++){var c=i[l].start,h=i[l].end;if(e+r>=c&&e<h)n=c,o=h,a=o-e;else if(e+r<c){s=c;break}}return{len:a,start:n,end:o,nextStart:s}},t}()},function(t,e){function r(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function i(t){return"function"==typeof t}function a(t){return"number"==typeof t}function n(t){return"object"==typeof t&&null!==t}function o(t){return void 0===t}t.exports=r,r.EventEmitter=r,r.prototype._events=void 0,r.prototype._maxListeners=void 0,r.defaultMaxListeners=10,r.prototype.setMaxListeners=function(t){if(!a(t)||t<0||isNaN(t))throw TypeError("n must be a positive number");return this._maxListeners=t,this},r.prototype.emit=function(t){var e,r,a,s,l,u;if(this._events||(this._events={}),"error"===t&&(!this._events.error||n(this._events.error)&&!this._events.error.length)){if((e=arguments[1])instanceof Error)throw e;var d=new Error('Uncaught, unspecified "error" event. ('+e+")");throw d.context=e,d}if(r=this._events[t],o(r))return!1;if(i(r))switch(arguments.length){case 1:r.call(this);break;case 2:r.call(this,arguments[1]);break;case 3:r.call(this,arguments[1],arguments[2]);break;default:s=Array.prototype.slice.call(arguments,1),r.apply(this,s)}else if(n(r))for(s=Array.prototype.slice.call(arguments,1),u=r.slice(),a=u.length,l=0;l<a;l++)u[l].apply(this,s);return!0},r.prototype.addListener=function(t,e){var a;if(!i(e))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",t,i(e.listener)?e.listener:e),this._events[t]?n(this._events[t])?this._events[t].push(e):this._events[t]=[this._events[t],e]:this._events[t]=e,n(this._events[t])&&!this._events[t].warned&&(a=o(this._maxListeners)?r.defaultMaxListeners:this._maxListeners)&&a>0&&this._events[t].length>a&&(this._events[t].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[t].length),"function"==typeof console.trace&&console.trace()),this},r.prototype.on=r.prototype.addListener,r.prototype.once=function(t,e){function r(){this.removeListener(t,r),a||(a=!0,e.apply(this,arguments))}if(!i(e))throw TypeError("listener must be a function");var a=!1;return r.listener=e,this.on(t,r),this},r.prototype.removeListener=function(t,e){var r,a,o,s;if(!i(e))throw TypeError("listener must be a function");if(!this._events||!this._events[t])return this;if(r=this._events[t],o=r.length,a=-1,r===e||i(r.listener)&&r.listener===e)delete this._events[t],this._events.removeListener&&this.emit("removeListener",t,e);else if(n(r)){for(s=o;s-- >0;)if(r[s]===e||r[s].listener&&r[s].listener===e){a=s;break}if(a<0)return this;1===r.length?(r.length=0,delete this._events[t]):r.splice(a,1),this._events.removeListener&&this.emit("removeListener",t,e)}return this},r.prototype.removeAllListeners=function(t){var e,r;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[t]&&delete this._events[t],this;if(0===arguments.length){for(e in this._events)"removeListener"!==e&&this.removeAllListeners(e);return this.removeAllListeners("removeListener"),this._events={},this}if(r=this._events[t],i(r))this.removeListener(t,r);else if(r)for(;r.length;)this.removeListener(t,r[r.length-1]);return delete this._events[t],this},r.prototype.listeners=function(t){return this._events&&this._events[t]?i(this._events[t])?[this._events[t]]:this._events[t].slice():[]},r.prototype.listenerCount=function(t){if(this._events){var e=this._events[t];if(i(e))return 1;if(e)return e.length}return 0},r.listenerCount=function(t,e){return t.listenerCount(e)}},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(34),n=r(35),o=r(36),s=r(2),l=r(0),u=function(){function t(e,r){var a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},n=a.removePKCS7Padding,o=void 0===n||n;if(i(this,t),this.logEnabled=!0,this.observer=e,this.config=r,this.removePKCS7Padding=o,o)try{var s=crypto||self.crypto;this.subtle=s.subtle||s.webkitSubtle}catch(t){}this.disableWebCrypto=!this.subtle}return t.prototype.isSync=function(){return this.disableWebCrypto&&this.config.enableSoftwareAES},t.prototype.decrypt=function(t,e,r,i){var s=this;if(this.disableWebCrypto&&this.config.enableSoftwareAES){this.logEnabled&&(l.b.log("JS AES decrypt"),this.logEnabled=!1);var u=this.decryptor;u||(this.decryptor=u=new o.a),u.expandKey(e),i(u.decrypt(t,0,r,this.removePKCS7Padding))}else{this.logEnabled&&(l.b.log("WebCrypto AES decrypt"),this.logEnabled=!1);var d=this.subtle;this.key!==e&&(this.key=e,this.fastAesKey=new n.a(d,e)),this.fastAesKey.expandKey().then(function(n){new a.a(d,r).decrypt(t,n).catch(function(a){s.onWebCryptoError(a,t,e,r,i)}).then(function(t){i(t)})}).catch(function(a){s.onWebCryptoError(a,t,e,r,i)})}},t.prototype.onWebCryptoError=function(t,e,r,i,a){this.config.enableSoftwareAES?(l.b.log("WebCrypto Error, disable WebCrypto API"),this.disableWebCrypto=!0,this.logEnabled=!0,this.decrypt(e,r,i,a)):(l.b.error("decrypting error : "+t.message),this.observer.trigger(Event.ERROR,{type:s.b.MEDIA_ERROR,details:s.a.FRAG_DECRYPT_ERROR,fatal:!0,reason:t.message}))},t.prototype.destroy=function(){var t=this.decryptor;t&&(t.destroy(),this.decryptor=void 0)},t}();e.a=u},function(t,e,r){"use strict";function i(){if("undefined"!=typeof window)return window.MediaSource||window.WebKitMediaSource}e.a=i},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(3),s=function(t){function e(r){i(this,e);for(var n=arguments.length,o=Array(n>1?n-1:0),s=1;s<n;s++)o[s-1]=arguments[s];var l=a(this,t.call.apply(t,[this,r].concat(o)));return l._tickInterval=null,l._tickTimer=null,l._tickCallCount=0,l._boundTick=l.tick.bind(l),l}return n(e,t),e.prototype.onHandlerDestroying=function(){this.clearNextTick(),this.clearInterval()},e.prototype.hasInterval=function(){return!!this._tickInterval},e.prototype.hasNextTick=function(){return!!this._tickTimer},e.prototype.setInterval=function(t){function e(e){return t.apply(this,arguments)}return e.toString=function(){return t.toString()},e}(function(t){return!this._tickInterval&&(this._tickInterval=setInterval(this._boundTick,t),!0)}),e.prototype.clearInterval=function(t){function e(){return t.apply(this,arguments)}return e.toString=function(){return t.toString()},e}(function(){return!!this._tickInterval&&(clearInterval(this._tickInterval),this._tickInterval=null,!0)}),e.prototype.clearNextTick=function(){return!!this._tickTimer&&(clearTimeout(this._tickTimer),this._tickTimer=null,!0)},e.prototype.tick=function(){1===++this._tickCallCount&&(this.doTick(),this._tickCallCount>1&&(this.clearNextTick(),this._tickTimer=setTimeout(this._boundTick,0)),this._tickCallCount=0)},e.prototype.doTick=function(){},e}(o.a);e.a=s},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(1),s=r(3),l=r(2),u=r(0),d=r(15),c=r(28),h=function(){function t(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,r,i){return r&&t(e.prototype,r),i&&t(e,i),e}}(),f={MANIFEST:"manifest",LEVEL:"level",AUDIO_TRACK:"audioTrack",SUBTITLE_TRACK:"subtitleTrack"},p={MAIN:"main",AUDIO:"audio",SUBTITLE:"subtitle"},v=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,o.a.MANIFEST_LOADING,o.a.LEVEL_LOADING,o.a.AUDIO_TRACK_LOADING,o.a.SUBTITLE_TRACK_LOADING));return n.loaders={},n}return n(e,t),e.canHaveQualityLevels=function(t){return t!==f.AUDIO_TRACK&&t!==f.SUBTITLE_TRACK},e.mapContextToLevelType=function(t){switch(t.type){case f.AUDIO_TRACK:return p.AUDIO;case f.SUBTITLE_TRACK:return p.SUBTITLE;default:return p.MAIN}},e.getResponseUrl=function(t,e){var r=t.url;return void 0!==r&&0!==r.indexOf("data:")||(r=e.url),r},e.prototype.createInternalLoader=function(t){var e=this.hls.config,r=e.pLoader,i=e.loader,a=r||i,n=new a(e);return t.loader=n,this.loaders[t.type]=n,n},e.prototype.getInternalLoader=function(t){return this.loaders[t.type]},e.prototype.resetInternalLoader=function(t){this.loaders[t]&&delete this.loaders[t]},e.prototype.destroyInternalLoaders=function(){for(var t in this.loaders){var e=this.loaders[t];e&&e.destroy(),this.resetInternalLoader(t)}},e.prototype.destroy=function(){this.destroyInternalLoaders(),t.prototype.destroy.call(this)},e.prototype.onManifestLoading=function(t){this.load(t.url,{type:f.MANIFEST})},e.prototype.onLevelLoading=function(t){this.load(t.url,{type:f.LEVEL,level:t.level,id:t.id})},e.prototype.onAudioTrackLoading=function(t){this.load(t.url,{type:f.AUDIO_TRACK,id:t.id})},e.prototype.onSubtitleTrackLoading=function(t){this.load(t.url,{type:f.SUBTITLE_TRACK,id:t.id})},e.prototype.load=function(t,e){var r=this.hls.config,i=this.getInternalLoader(e);if(i){var a=i.context;if(a&&a.url===t)return u.b.trace("playlist request ongoing"),!1;u.b.warn("aborting previous loader for type: "+e.type),i.abort()}var n=void 0,o=void 0,s=void 0,l=void 0;switch(e.type){case f.MANIFEST:n=r.manifestLoadingMaxRetry,o=r.manifestLoadingTimeOut,s=r.manifestLoadingRetryDelay,l=r.manifestLoadingMaxRetryTimeout;break;case f.LEVEL:n=0,o=r.levelLoadingTimeOut;break;default:n=r.levelLoadingMaxRetry,o=r.levelLoadingTimeOut,s=r.levelLoadingRetryDelay,l=r.levelLoadingMaxRetryTimeout,u.b.log("Playlist loader for "+e.type+" "+(e.level||e.id))}i=this.createInternalLoader(e),e.url=t,e.responseType=e.responseType||"";var d=void 0,c=void 0;return d={timeout:o,maxRetry:n,retryDelay:s,maxRetryDelay:l},c={onSuccess:this.loadsuccess.bind(this),onError:this.loaderror.bind(this),onTimeout:this.loadtimeout.bind(this)},i.load(e,d,c),!0},e.prototype.loadsuccess=function(t,e,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(r.isSidxRequest)return this._handleSidxRequest(t,r),void this._handlePlaylistLoaded(t,e,r,i);this.resetInternalLoader(r.type);var a=t.data;if(e.tload=performance.now(),0!==a.indexOf("#EXTM3U"))return void this._handleManifestParsingError(t,r,"no EXTM3U delimiter",i);a.indexOf("#EXTINF:")>0||a.indexOf("#EXT-X-TARGETDURATION:")>0?this._handleTrackOrLevelPlaylist(t,e,r,i):this._handleMasterPlaylist(t,e,r,i)},e.prototype.loaderror=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this._handleNetworkError(e,r)},e.prototype.loadtimeout=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this._handleNetworkError(e,r,!0)},e.prototype._handleMasterPlaylist=function(t,r,i,a){var n=this.hls,s=t.data,l=e.getResponseUrl(t,i),d=c.a.parseMasterPlaylist(s,l);if(!d.length)return void this._handleManifestParsingError(t,i,"no level found in manifest",a);var h=d.map(function(t){return{id:t.attrs.AUDIO,codec:t.audioCodec}}),f=c.a.parseMasterPlaylistMedia(s,l,"AUDIO",h),p=c.a.parseMasterPlaylistMedia(s,l,"SUBTITLES");if(f.length){var v=!1;f.forEach(function(t){t.url||(v=!0)}),!1===v&&d[0].audioCodec&&!d[0].attrs.AUDIO&&(u.b.log("audio codec signaled in quality level, but no embedded audio track signaled, create one"),f.unshift({type:"main",name:"main"}))}n.trigger(o.a.MANIFEST_LOADED,{levels:d,audioTracks:f,subtitles:p,url:l,stats:r,networkDetails:a})},e.prototype._handleTrackOrLevelPlaylist=function(t,r,i,a){var n=this.hls,s=i.id,l=i.level,u=i.type,d=e.getResponseUrl(t,i),h=isNaN(l)?isNaN(s)?0:s:l,p=e.mapContextToLevelType(i),v=c.a.parseLevelPlaylist(t.data,d,h,p);if(v.tload=r.tload,u===f.MANIFEST){var g={url:d,details:v};n.trigger(o.a.MANIFEST_LOADED,{levels:[g],audioTracks:[],url:d,stats:r,networkDetails:a})}if(r.tparsed=performance.now(),v.needSidxRanges){var y=v.initSegment.url;return void this.load(y,{isSidxRequest:!0,type:u,level:l,levelDetails:v,id:s,rangeStart:0,rangeEnd:2048,responseType:"arraybuffer"})}i.levelDetails=v,this._handlePlaylistLoaded(t,r,i,a)},e.prototype._handleSidxRequest=function(t,e){var r=d.a.parseSegmentIndex(new Uint8Array(t.data));r.references.forEach(function(t,r){var i=t.info,a=e.levelDetails.fragments[r];0===a.byteRange.length&&(a.rawByteRange=String(1+i.end-i.start)+"@"+String(i.start))}),e.levelDetails.initSegment.rawByteRange=String(r.moovEndOffset)+"@0"},e.prototype._handleManifestParsingError=function(t,e,r,i){this.hls.trigger(o.a.ERROR,{type:l.b.NETWORK_ERROR,details:l.a.MANIFEST_PARSING_ERROR,fatal:!0,url:t.url,reason:r,networkDetails:i})},e.prototype._handleNetworkError=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=void 0,a=void 0,n=this.getInternalLoader(t);switch(t.type){case f.MANIFEST:i=r?l.a.MANIFEST_LOAD_TIMEOUT:l.a.MANIFEST_LOAD_ERROR,a=!0;break;case f.LEVEL:i=r?l.a.LEVEL_LOAD_TIMEOUT:l.a.LEVEL_LOAD_ERROR,a=!1;break;case f.AUDIO_TRACK:i=r?l.a.AUDIO_TRACK_LOAD_TIMEOUT:l.a.AUDIO_TRACK_LOAD_ERROR,a=!1;break;default:a=!1}n&&(n.abort(),this.resetInternalLoader(t.type)),this.hls.trigger(o.a.ERROR,{type:l.b.NETWORK_ERROR,details:i,fatal:a,url:n.url,loader:n,context:t,networkDetails:e})},e.prototype._handlePlaylistLoaded=function(t,r,i,a){var n=i.type,s=i.level,l=i.id,u=i.levelDetails;if(!u.targetduration)return void this._handleManifestParsingError(t,i,"invalid target duration",a);if(e.canHaveQualityLevels(i.type))this.hls.trigger(o.a.LEVEL_LOADED,{details:u,level:s||0,id:l||0,stats:r,networkDetails:a});else switch(n){case f.AUDIO_TRACK:this.hls.trigger(o.a.AUDIO_TRACK_LOADED,{details:u,id:l,stats:r,networkDetails:a});break;case f.SUBTITLE_TRACK:this.hls.trigger(o.a.SUBTITLE_TRACK_LOADED,{details:u,id:l,stats:r,networkDetails:a})}},h(e,null,[{key:"ContextType",get:function(){return f}},{key:"LevelType",get:function(){return p}}]),e}(s.a);e.a=v},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(0),n=r(1),o=Math.pow(2,32)-1,s=function(){function t(e,r){i(this,t),this.observer=e,this.remuxer=r}return t.prototype.resetTimeStamp=function(t){this.initPTS=t},t.prototype.resetInitSegment=function(e,r,i,a){if(e&&e.byteLength){var o=this.initData=t.parseInitSegment(e);null==r&&(r="mp4a.40.5"),null==i&&(i="avc1.42e01e");var s={};o.audio&&o.video?s.audiovideo={container:"video/mp4",codec:r+","+i,initSegment:a?e:null}:(o.audio&&(s.audio={container:"audio/mp4",codec:r,initSegment:a?e:null}),o.video&&(s.video={container:"video/mp4",codec:i,initSegment:a?e:null})),this.observer.trigger(n.a.FRAG_PARSING_INIT_SEGMENT,{tracks:s})}else r&&(this.audioCodec=r),i&&(this.videoCodec=i)},t.probe=function(e){return t.findBox({data:e,start:0,end:Math.min(e.length,16384)},["moof"]).length>0},t.bin2str=function(t){return String.fromCharCode.apply(null,t)},t.readUint16=function(t,e){t.data&&(e+=t.start,t=t.data);var r=t[e]<<8|t[e+1];return r<0?65536+r:r},t.readUint32=function(t,e){t.data&&(e+=t.start,t=t.data);var r=t[e]<<24|t[e+1]<<16|t[e+2]<<8|t[e+3];return r<0?4294967296+r:r},t.writeUint32=function(t,e,r){t.data&&(e+=t.start,t=t.data),t[e]=r>>24,t[e+1]=r>>16&255,t[e+2]=r>>8&255,t[e+3]=255&r},t.findBox=function(e,r){var i=[],a=void 0,n=void 0,o=void 0,s=void 0,l=void 0,u=void 0,d=void 0;if(e.data?(u=e.start,s=e.end,e=e.data):(u=0,s=e.byteLength),!r.length)return null;for(a=u;a<s;)n=t.readUint32(e,a),o=t.bin2str(e.subarray(a+4,a+8)),d=n>1?a+n:s,o===r[0]&&(1===r.length?i.push({data:e,start:a+8,end:d}):(l=t.findBox({data:e,start:a+8,end:d},r.slice(1)),l.length&&(i=i.concat(l)))),a=d;return i},t.parseSegmentIndex=function(e){var r=t.findBox(e,["moov"])[0],i=r?r.end:null,a=0,n=t.findBox(e,["sidx"]),o=void 0;if(!n||!n[0])return null;o=[],n=n[0];var s=n.data[0];a=0===s?8:16;var l=t.readUint32(n,a);a+=4;a+=0===s?8:16,a+=2;var u=n.end+0,d=t.readUint16(n,a);a+=2;for(var c=0;c<d;c++){var h=a,f=t.readUint32(n,h);h+=4;var p=2147483647&f;if(1===(2147483648&f)>>>31)return void console.warn("SIDX has hierarchical references (not supported)");var v=t.readUint32(n,h);h+=4,o.push({referenceSize:p,subsegmentDuration:v,info:{duration:v/l,start:u,end:u+p-1}}),u+=p,h+=4,a=h}return{earliestPresentationTime:0,timescale:l,version:s,referencesCount:d,references:o,moovEndOffset:i}},t.parseInitSegment=function(e){var r=[];return t.findBox(e,["moov","trak"]).forEach(function(e){var i=t.findBox(e,["tkhd"])[0];if(i){var n=i.data[i.start],o=0===n?12:20,s=t.readUint32(i,o),l=t.findBox(e,["mdia","mdhd"])[0];if(l){n=l.data[l.start],o=0===n?12:20;var u=t.readUint32(l,o),d=t.findBox(e,["mdia","hdlr"])[0];if(d){var c=t.bin2str(d.data.subarray(d.start+8,d.start+12)),h={soun:"audio",vide:"video"}[c];if(h){var f=t.findBox(e,["mdia","minf","stbl","stsd"]);if(f.length){f=f[0];var p=t.bin2str(f.data.subarray(f.start+12,f.start+16));a.b.log("MP4Demuxer:"+h+":"+p+" found")}r[s]={timescale:u,type:h},r[h]={timescale:u,id:s}}}}}}),r},t.getStartDTS=function(e,r){var i=void 0,a=void 0,n=void 0;return i=t.findBox(r,["moof","traf"]),a=[].concat.apply([],i.map(function(r){return t.findBox(r,["tfhd"]).map(function(i){var a=void 0,n=void 0;return a=t.readUint32(i,4),n=e[a].timescale||9e4,t.findBox(r,["tfdt"]).map(function(e){var r=void 0,i=void 0;return r=e.data[e.start],i=t.readUint32(e,4),1===r&&(i*=Math.pow(2,32),i+=t.readUint32(e,8)),i})[0]/n})})),n=Math.min.apply(null,a),isFinite(n)?n:0},t.offsetStartDTS=function(e,r,i){t.findBox(r,["moof","traf"]).map(function(r){return t.findBox(r,["tfhd"]).map(function(a){var n=t.readUint32(a,4),s=e[n].timescale||9e4;t.findBox(r,["tfdt"]).map(function(e){var r=e.data[e.start],a=t.readUint32(e,4);if(0===r)t.writeUint32(e,4,a-i*s);else{a*=Math.pow(2,32),a+=t.readUint32(e,8),a-=i*s,a=Math.max(a,0);var n=Math.floor(a/(o+1)),l=Math.floor(a%(o+1));t.writeUint32(e,4,n),t.writeUint32(e,8,l)}})})})},t.prototype.append=function(e,r,i,a){var o=this.initData;o||(this.resetInitSegment(e,this.audioCodec,this.videoCodec,!1),o=this.initData);var s=void 0,l=this.initPTS;if(void 0===l){var u=t.getStartDTS(o,e);this.initPTS=l=u-r,this.observer.trigger(n.a.INIT_PTS_FOUND,{initPTS:l})}t.offsetStartDTS(o,e,l),s=t.getStartDTS(o,e),this.remuxer.remux(o.audio,o.video,null,null,s,i,a,e)},t.prototype.destroy=function(){},t}();e.a=s},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(4),n=r.n(a),o=function(){function t(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,r,i){return r&&t(e.prototype,r),i&&t(e,i),e}}(),s=function(){function t(){i(this,t),this.method=null,this.key=null,this.iv=null,this._uri=null}return o(t,[{key:"uri",get:function(){return!this._uri&&this.reluri&&(this._uri=n.a.buildAbsoluteURL(this.baseuri,this.reluri,{alwaysNormalize:!0})),this._uri}}]),t}();e.a=s},function(t,e,r){"use strict";function i(t,e){var r=n[e];return!!r&&!0===r[t.slice(0,4)]}function a(t,e){return MediaSource.isTypeSupported((e||"video")+'/mp4;codecs="'+t+'"')}r.d(e,"b",function(){return i}),r.d(e,"a",function(){return a});var n={audio:{a3ds:!0,"ac-3":!0,"ac-4":!0,alac:!0,alaw:!0,dra1:!0,"dts+":!0,"dts-":!0,dtsc:!0,dtse:!0,dtsh:!0,"ec-3":!0,enca:!0,g719:!0,g726:!0,m4ae:!0,mha1:!0,mha2:!0,mhm1:!0,mhm2:!0,mlpa:!0,mp4a:!0,"raw ":!0,Opus:!0,samr:!0,sawb:!0,sawp:!0,sevc:!0,sqcp:!0,ssmv:!0,twos:!0,ulaw:!0},video:{avc1:!0,avc2:!0,avc3:!0,avc4:!0,avcp:!0,drac:!0,dvav:!0,dvhe:!0,encv:!0,hev1:!0,hvc1:!0,mjp2:!0,mp4v:!0,mvc1:!0,mvc2:!0,mvc3:!0,mvc4:!0,resv:!0,rv60:!0,s263:!0,svc1:!0,svc2:!0,"vc-1":!0,vp08:!0,vp09:!0}}},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(10),n=r.n(a),o=r(33),s=r.n(o),l=r(1),u=r(19),d=r(0),c=r(2),h=r(12),f=Object(h.a)(),p=function(){function t(e,r){i(this,t),this.hls=e,this.id=r;var a=this.observer=new n.a,o=e.config;a.trigger=function(t){for(var e=arguments.length,r=Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];a.emit.apply(a,[t,t].concat(r))},a.off=function(t){for(var e=arguments.length,r=Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];a.removeListener.apply(a,[t].concat(r))};var h=function(t,r){r=r||{},r.frag=this.frag,r.id=this.id,e.trigger(t,r)}.bind(this);a.on(l.a.FRAG_DECRYPTED,h),a.on(l.a.FRAG_PARSING_INIT_SEGMENT,h),a.on(l.a.FRAG_PARSING_DATA,h),a.on(l.a.FRAG_PARSED,h),a.on(l.a.ERROR,h),a.on(l.a.FRAG_PARSING_METADATA,h),a.on(l.a.FRAG_PARSING_USERDATA,h),a.on(l.a.INIT_PTS_FOUND,h);var p={mp4:f.isTypeSupported("video/mp4"),mpeg:f.isTypeSupported("audio/mpeg"),mp3:f.isTypeSupported('audio/mp4; codecs="mp3"')},v=navigator.vendor;if(o.enableWorker&&"undefined"!=typeof Worker){d.b.log("demuxing in webworker");var g=void 0;try{g=this.w=s()(46),this.onwmsg=this.onWorkerMessage.bind(this),g.addEventListener("message",this.onwmsg),g.onerror=function(t){e.trigger(l.a.ERROR,{type:c.b.OTHER_ERROR,details:c.a.INTERNAL_EXCEPTION,fatal:!0,event:"demuxerWorker",err:{message:t.message+" ("+t.filename+":"+t.lineno+")"}})},g.postMessage({cmd:"init",typeSupported:p,vendor:v,id:r,config:JSON.stringify(o)})}catch(t){d.b.error("error while initializing DemuxerWorker, fallback on DemuxerInline"),g&&URL.revokeObjectURL(g.objectURL),this.demuxer=new u.a(a,p,o,v),this.w=void 0}}else this.demuxer=new u.a(a,p,o,v)}return t.prototype.destroy=function(){var t=this.w;if(t)t.removeEventListener("message",this.onwmsg),t.terminate(),this.w=null;else{var e=this.demuxer;e&&(e.destroy(),this.demuxer=null)}var r=this.observer;r&&(r.removeAllListeners(),this.observer=null)},t.prototype.push=function(t,e,r,i,a,n,o,s){var l=this.w,u=isNaN(a.startDTS)?a.start:a.startDTS,c=a.decryptdata,h=this.frag,f=!(h&&a.cc===h.cc),p=!(h&&a.level===h.level),v=h&&a.sn===h.sn+1,g=!p&&v;if(f&&d.b.log(this.id+":discontinuity detected"),p&&d.b.log(this.id+":switch detected"),this.frag=a,l)l.postMessage({cmd:"demux",data:t,decryptdata:c,initSegment:e,audioCodec:r,videoCodec:i,timeOffset:u,discontinuity:f,trackSwitch:p,contiguous:g,duration:n,accurateTimeOffset:o,defaultInitPTS:s},t instanceof ArrayBuffer?[t]:[]);else{var y=this.demuxer;y&&y.push(t,c,e,r,i,u,f,p,g,n,o,s)}},t.prototype.onWorkerMessage=function(t){var e=t.data,r=this.hls;switch(e.event){case"init":URL.revokeObjectURL(this.w.objectURL);break;case l.a.FRAG_PARSING_DATA:e.data.data1=new Uint8Array(e.data1),e.data2&&(e.data.data2=new Uint8Array(e.data2));default:e.data=e.data||{},e.data.frag=this.frag,e.data.id=this.id,r.trigger(e.event,e.data)}},t}();e.a=p},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(1),n=r(2),o=r(11),s=r(37),l=r(15),u=r(38),d=r(41),c=r(42),h=r(45),f=function(){function t(e,r,a,n){i(this,t),this.observer=e,this.typeSupported=r,this.config=a,this.vendor=n}return t.prototype.destroy=function(){var t=this.demuxer;t&&t.destroy()},t.prototype.push=function(t,e,r,i,n,s,l,u,d,c,h,f){if(t.byteLength>0&&null!=e&&null!=e.key&&"AES-128"===e.method){var p=this.decrypter;null==p&&(p=this.decrypter=new o.a(this.observer,this.config));var v=this,g=void 0;try{g=performance.now()}catch(t){g=Date.now()}p.decrypt(t,e.key.buffer,e.iv.buffer,function(t){var o=void 0;try{o=performance.now()}catch(t){o=Date.now()}v.observer.trigger(a.a.FRAG_DECRYPTED,{stats:{tstart:g,tdecrypt:o}}),v.pushDecrypted(new Uint8Array(t),e,new Uint8Array(r),i,n,s,l,u,d,c,h,f)})}else this.pushDecrypted(new Uint8Array(t),e,new Uint8Array(r),i,n,s,l,u,d,c,h,f)},t.prototype.pushDecrypted=function(t,e,r,i,o,f,p,v,g,y,m,b){var E=this.demuxer;if(!E||(p||v)&&!this.probe(t)){for(var T=this.observer,S=this.typeSupported,R=this.config,A=[{demux:u.a,remux:c.a},{demux:l.a,remux:h.a},{demux:s.a,remux:c.a},{demux:d.a,remux:c.a}],_=0,w=A.length;_<w;_++){var L=A[_],D=L.demux.probe;if(D(t)){var I=this.remuxer=new L.remux(T,R,S,this.vendor);E=new L.demux(T,I,R,S),this.probe=D;break}}if(!E)return void T.trigger(a.a.ERROR,{type:n.b.MEDIA_ERROR,details:n.a.FRAG_PARSING_ERROR,fatal:!0,reason:"no demux matching with content found"});this.demuxer=E}var k=this.remuxer;(p||v)&&(E.resetInitSegment(r,i,o,y),k.resetInitSegment()),p&&(E.resetTimeStamp(b),k.resetTimeStamp(b)),"function"==typeof E.setDecryptData&&E.setDecryptData(e),E.append(t,f,g,m)},t}();e.a=f},function(t,e,r){"use strict";function i(t,e,r,i){var a=void 0,n=void 0,o=void 0,s=void 0,l=void 0,u=navigator.userAgent.toLowerCase(),d=i,c=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350];return a=1+((192&e[r+2])>>>6),(n=(60&e[r+2])>>>2)>c.length-1?void t.trigger(Event.ERROR,{type:p.b.MEDIA_ERROR,details:p.a.FRAG_PARSING_ERROR,fatal:!0,reason:"invalid ADTS sampling index:"+n}):(s=(1&e[r+2])<<2,s|=(192&e[r+3])>>>6,f.b.log("manifest codec:"+i+",ADTS data:type:"+a+",sampleingIndex:"+n+"["+c[n]+"Hz],channelConfig:"+s),/firefox/i.test(u)?n>=6?(a=5,l=new Array(4),o=n-3):(a=2,l=new Array(2),o=n):-1!==u.indexOf("android")?(a=2,l=new Array(2),o=n):(a=5,l=new Array(4),i&&(-1!==i.indexOf("mp4a.40.29")||-1!==i.indexOf("mp4a.40.5"))||!i&&n>=6?o=n-3:((i&&-1!==i.indexOf("mp4a.40.2")&&(n>=6&&1===s||/vivaldi/i.test(u))||!i&&1===s)&&(a=2,l=new Array(2)),o=n)),l[0]=a<<3,l[0]|=(14&n)>>1,l[1]|=(1&n)<<7,l[1]|=s<<3,5===a&&(l[1]|=(14&o)>>1,l[2]=(1&o)<<7,l[2]|=8,l[3]=0),{config:l,samplerate:c[n],channelCount:s,codec:"mp4a.40."+a,manifestCodec:d})}function a(t,e){return 255===t[e]&&240==(246&t[e+1])}function n(t,e){return 1&t[e+1]?7:9}function o(t,e){return(3&t[e+3])<<11|t[e+4]<<3|(224&t[e+5])>>>5}function s(t,e){return!!(e+1<t.length&&a(t,e))}function l(t,e){if(e+1<t.length&&a(t,e)){var r=n(t,e),i=r;e+5<t.length&&(i=o(t,e));var s=e+i;if(s===t.length||s+1<t.length&&a(t,s))return!0}return!1}function u(t,e,r,a,n){if(!t.samplerate){var o=i(e,r,a,n);t.config=o.config,t.samplerate=o.samplerate,t.channelCount=o.channelCount,t.codec=o.codec,t.manifestCodec=o.manifestCodec,f.b.log("parsed codec:"+t.codec+",rate:"+o.samplerate+",nb channel:"+o.channelCount)}}function d(t){return 9216e4/t}function c(t,e,r,i,a){var s=void 0,l=void 0,u=void 0,d=t.length;if(s=n(t,e),l=o(t,e),(l-=s)>0&&e+s+l<=d)return u=r+i*a,{headerLength:s,frameLength:l,stamp:u}}function h(t,e,r,i,a){var n=d(t.samplerate),o=c(e,r,i,a,n);if(o){var s=o.stamp,l=o.headerLength,u=o.frameLength,h={unit:e.subarray(r+l,r+l+u),pts:s,dts:s};return t.samples.push(h),t.len+=u,{sample:h,length:u+l}}}e.d=s,e.e=l,e.c=u,e.b=d,e.a=h;var f=r(0),p=r(2)},function(t,e,r){"use strict";var i={BitratesMap:[32,64,96,128,160,192,224,256,288,320,352,384,416,448,32,48,56,64,80,96,112,128,160,192,224,256,320,384,32,40,48,56,64,80,96,112,128,160,192,224,256,320,32,48,56,64,80,96,112,128,144,160,176,192,224,256,8,16,24,32,40,48,56,64,80,96,112,128,144,160],SamplingRateMap:[44100,48e3,32e3,22050,24e3,16e3,11025,12e3,8e3],SamplesCoefficients:[[0,72,144,12],[0,0,0,0],[0,72,144,12],[0,144,144,12]],BytesInSlot:[0,1,1,4],appendFrame:function(t,e,r,i,a){if(!(r+24>e.length)){var n=this.parseHeader(e,r);if(n&&r+n.frameLength<=e.length){var o=9e4*n.samplesPerFrame/n.sampleRate,s=i+a*o,l={unit:e.subarray(r,r+n.frameLength),pts:s,dts:s};return t.config=[],t.channelCount=n.channelCount,t.samplerate=n.sampleRate,t.samples.push(l),t.len+=n.frameLength,{sample:l,length:n.frameLength}}}},parseHeader:function(t,e){var r=t[e+1]>>3&3,a=t[e+1]>>1&3,n=t[e+2]>>4&15,o=t[e+2]>>2&3,s=t[e+2]>>1&1;if(1!==r&&0!==n&&15!==n&&3!==o){var l=3===r?3-a:3===a?3:4,u=1e3*i.BitratesMap[14*l+n-1],d=3===r?0:2===r?1:2,c=i.SamplingRateMap[3*d+o],h=t[e+3]>>6==3?1:2,f=i.SamplesCoefficients[r][a],p=i.BytesInSlot[a],v=8*f*p;return{sampleRate:c,channelCount:h,frameLength:parseInt(f*u/c+s,10)*p,samplesPerFrame:v}}},isHeaderPattern:function(t,e){return 255===t[e]&&224==(224&t[e+1])&&0!=(6&t[e+1])},isHeader:function(t,e){return!!(e+1<t.length&&this.isHeaderPattern(t,e))},probe:function(t,e){if(e+1<t.length&&this.isHeaderPattern(t,e)){var r=this.parseHeader(t,e),i=4;r&&r.frameLength&&(i=r.frameLength);var a=e+i;if(a===t.length||a+1<t.length&&this.isHeaderPattern(t,a))return!0}return!1}};e.a=i},function(t,e,r){"use strict";function i(t,e,r){var i=t[e],a=t[r],n=a.startPTS;isNaN(n)?a.start=r>e?i.start+i.duration:Math.max(i.start-a.duration,0):r>e?(i.duration=n-i.start,i.duration<0&&o.b.warn("negative duration computed for frag "+i.sn+",level "+i.level+", there should be some duration drift between playlist and fragment!")):(a.duration=i.start-n,a.duration<0&&o.b.warn("negative duration computed for frag "+a.sn+",level "+a.level+", there should be some duration drift between playlist and fragment!"))}function a(t,e,r,a,n,o){var s=r;if(!isNaN(e.startPTS)){var l=Math.abs(e.startPTS-r);isNaN(e.deltaPTS)?e.deltaPTS=l:e.deltaPTS=Math.max(l,e.deltaPTS),s=Math.max(r,e.startPTS),r=Math.min(r,e.startPTS),a=Math.max(a,e.endPTS),n=Math.min(n,e.startDTS),o=Math.max(o,e.endDTS)}var u=r-e.start;e.start=e.startPTS=r,e.maxStartPTS=s,e.endPTS=a,e.startDTS=n,e.endDTS=o,e.duration=a-r;var d=e.sn;if(!t||d<t.startSN||d>t.endSN)return 0;var c=void 0,h=void 0,f=void 0;for(c=d-t.startSN,h=t.fragments,h[c]=e,f=c;f>0;f--)i(h,f,f-1);for(f=c;f<h.length-1;f++)i(h,f,f+1);return t.PTSKnown=!0,u}function n(t,e){var r=Math.max(t.startSN,e.startSN)-e.startSN,i=Math.min(t.endSN,e.endSN)-e.startSN,n=e.startSN-t.startSN,s=t.fragments,l=e.fragments,u=0,d=void 0;if(e.initSegment&&t.initSegment&&(e.initSegment=t.initSegment),i<r)return void(e.PTSKnown=!1);for(var c=r;c<=i;c++){var h=s[n+c],f=l[c];f&&h&&(u=h.cc-f.cc,isNaN(h.startPTS)||(f.start=f.startPTS=h.startPTS,f.endPTS=h.endPTS,f.duration=h.duration,f.backtracked=h.backtracked,f.dropped=h.dropped,d=f))}if(u)for(o.b.log("discontinuity sliding from playlist, take drift into account"),c=0;c<l.length;c++)l[c].cc+=u;if(d)a(e,d,d.startPTS,d.endPTS,d.startDTS,d.endDTS);else if(n>=0&&n<s.length){var p=s[n].start;for(c=0;c<l.length;c++)l[c].start+=p}e.PTSKnown=t.PTSKnown}e.b=a,e.a=n;var o=r(0)},function(t,e,r){"use strict";var i={toString:function(t){for(var e="",r=t.length,i=0;i<r;i++)e+="["+t.start(i).toFixed(3)+","+t.end(i).toFixed(3)+"]";return e}};e.a=i},function(t,e,r){"use strict";function i(t,e){for(var r=null,i=0;i<t.length;i+=1){var a=t[i];if(a&&a.cc===e){r=a;break}}return r}function a(t,e){return u.a.search(t,function(t){return t.cc<e?1:t.cc>e?-1:0})}function n(t,e,r){var i=!1;return e&&e.details&&r&&(r.endCC>r.startCC||t&&t.cc<r.startCC)&&(i=!0),i}function o(t,e){var r=t.fragments,a=e.fragments;if(!a.length||!r.length)return void d.b.log("No fragments to align");var n=i(r,a[0].cc);return!n||n&&!n.startPTS?void d.b.log("No frag in previous level to align on"):n}function s(t,e){e.fragments.forEach(function(e){if(e){var r=e.start+t;e.start=e.startPTS=r,e.endPTS=r+e.duration}}),e.PTSKnown=!0}function l(t,e,r){if(n(t,e,r)){var i=o(e.details,r);i&&(d.b.log("Adjusting PTS using last level due to CC increase within current level"),s(i.start,r))}if(!1===r.PTSKnown&&e&&e.details&&e.details.fragments&&e.details.fragments.length){var a=e.details.programDateTime,l=r.programDateTime,u=(l-a)/1e3+e.details.fragments[0].start;isNaN(u)||(d.b.log("adjusting PTS using programDateTime delta, sliding:"+u.toFixed(3)),s(u,r))}}e.b=a,e.a=l;var u=r(8),d=r(0)},function(t,e,r){"use strict";function i(t,e){var r=null;try{r=new window.Event("addtrack")}catch(t){r=document.createEvent("Event"),r.initEvent("addtrack",!1,!1)}r.track=t,e.dispatchEvent(r)}function a(t){if(t&&t.cues)for(;t.cues.length>0;)t.removeCue(t.cues[0])}e.b=i,e.a=a},function(t,e,r){"use strict";function i(){this.window=window,this.state="INITIAL",this.buffer="",this.decoder=new d,this.regionList=[]}function a(t){function e(t,e,r,i){return 3600*(0|t)+60*(0|e)+(0|r)+(0|i)/1e3}var r=t.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);return r?r[3]?e(r[1],r[2],r[3].replace(":",""),r[4]):r[1]>59?e(r[1],r[2],0,r[4]):e(0,r[1],r[2],r[4]):null}function n(){this.values=Object.create(null)}function o(t,e,r,i){var a=i?t.split(i):[t];for(var n in a)if("string"==typeof a[n]){var o=a[n].split(r);if(2===o.length){var s=o[0],l=o[1];e(s,l)}}}function s(t,e,r){function i(){var e=a(t);if(null===e)throw new Error("Malformed timestamp: "+l);return t=t.replace(/^[^\sa-zA-Z-]+/,""),e}function s(){t=t.replace(/^\s+/,"")}var l=t;if(s(),e.startTime=i(),s(),"--\x3e"!==t.substr(0,3))throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): "+l);t=t.substr(3),s(),e.endTime=i(),s(),function(t,e){var i=new n;o(t,function(t,e){switch(t){case"region":for(var a=r.length-1;a>=0;a--)if(r[a].id===e){i.set(t,r[a].region);break}break;case"vertical":i.alt(t,e,["rl","lr"]);break;case"line":var n=e.split(","),o=n[0];i.integer(t,o),i.percent(t,o)&&i.set("snapToLines",!1),i.alt(t,o,["auto"]),2===n.length&&i.alt("lineAlign",n[1],["start",h,"end"]);break;case"position":n=e.split(","),i.percent(t,n[0]),2===n.length&&i.alt("positionAlign",n[1],["start",h,"end","line-left","line-right","auto"]);break;case"size":i.percent(t,e);break;case"align":i.alt(t,e,["start",h,"end","left","right"])}},/:/,/\s/),e.region=i.get("region",null),e.vertical=i.get("vertical","");var a=i.get("line","auto");"auto"===a&&-1===c.line&&(a=-1),e.line=a,e.lineAlign=i.get("lineAlign","start"),e.snapToLines=i.get("snapToLines",!0),e.size=i.get("size",100),e.align=i.get("align",h);var s=i.get("position","auto");"auto"===s&&50===c.position&&(s="start"===e.align||"left"===e.align?0:"end"===e.align||"right"===e.align?100:50),e.position=s}(t,e)}function l(t){return t.replace(/<br(?: \/)?>/gi,"\n")}r.d(e,"b",function(){return l});var u=r(61),d=function(){return{decode:function(t){if(!t)return"";if("string"!=typeof t)throw new Error("Error - expected string data.");return decodeURIComponent(encodeURIComponent(t))}}};n.prototype={set:function(t,e){this.get(t)||""===e||(this.values[t]=e)},get:function(t,e,r){return r?this.has(t)?this.values[t]:e[r]:this.has(t)?this.values[t]:e},has:function(t){return t in this.values},alt:function(t,e,r){for(var i=0;i<r.length;++i)if(e===r[i]){this.set(t,e);break}},integer:function(t,e){/^-?\d+$/.test(e)&&this.set(t,parseInt(e,10))},percent:function(t,e){return!!(e.match(/^([\d]{1,3})(\.[\d]*)?%$/)&&(e=parseFloat(e))>=0&&e<=100)&&(this.set(t,e),!0)}};var c=new u.a(0,0,0),h="middle"===c.align?"middle":"center";i.prototype={parse:function(t){function e(){var t=r.buffer,e=0;for(t=l(t);e<t.length&&"\r"!==t[e]&&"\n"!==t[e];)++e;var i=t.substr(0,e);return"\r"===t[e]&&++e,"\n"===t[e]&&++e,r.buffer=t.substr(e),i}var r=this;t&&(r.buffer+=r.decoder.decode(t,{stream:!0}));try{var i=void 0;if("INITIAL"===r.state){if(!/\r\n|\n/.test(r.buffer))return this;i=e();var a=i.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);if(!a||!a[0])throw new Error("Malformed WebVTT signature.");r.state="HEADER"}for(var n=!1;r.buffer;){if(!/\r\n|\n/.test(r.buffer))return this;switch(n?n=!1:i=e(),r.state){case"HEADER":/:/.test(i)?function(t){o(t,function(t,e){switch(t){case"Region":console.log("parse region",e)}},/:/)}(i):i||(r.state="ID");continue;case"NOTE":i||(r.state="ID");continue;case"ID":if(/^NOTE($|[ \t])/.test(i)){r.state="NOTE";break}if(!i)continue;if(r.cue=new u.a(0,0,""),r.state="CUE",-1===i.indexOf("--\x3e")){r.cue.id=i;continue}case"CUE":try{s(i,r.cue,r.regionList)}catch(t){r.cue=null,r.state="BADCUE";continue}r.state="CUETEXT";continue;case"CUETEXT":var d=-1!==i.indexOf("--\x3e");if(!i||d&&(n=!0)){r.oncue&&r.oncue(r.cue),r.cue=null,r.state="ID";continue}r.cue.text&&(r.cue.text+="\n"),r.cue.text+=i;continue;case"BADCUE":i||(r.state="ID");continue}}}catch(t){"CUETEXT"===r.state&&r.cue&&r.oncue&&r.oncue(r.cue),r.cue=null,r.state="INITIAL"===r.state?"BADWEBVTT":"BADCUE"}return this},flush:function(){var t=this;try{if(t.buffer+=t.decoder.decode(),(t.cue||"HEADER"===t.state)&&(t.buffer+="\n\n",t.parse()),"INITIAL"===t.state)throw new Error("Malformed WebVTT signature.")}catch(t){throw t}return t.onflush&&t.onflush(),this}},e.a=i},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var a=r(4),n=r.n(a),o=r(2),s=r(14),l=r(30),u=r(31),d=r(7),c=r(32),h=r(47),f=r(48),p=r(49),v=r(0),g=r(50),y=r(1),m=r(10),b=r.n(m),E=function(){function t(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,r,i){return r&&t(e.prototype,r),i&&t(e,i),e}}();r(70);var T=function(){function t(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i(this,t);var a=t.DefaultConfig;if((r.liveSyncDurationCount||r.liveMaxLatencyDurationCount)&&(r.liveSyncDuration||r.liveMaxLatencyDuration))throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");for(var n in a)n in r||(r[n]=a[n]);if(void 0!==r.liveMaxLatencyDurationCount&&r.liveMaxLatencyDurationCount<=r.liveSyncDurationCount)throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');if(void 0!==r.liveMaxLatencyDuration&&(r.liveMaxLatencyDuration<=r.liveSyncDuration||void 0===r.liveSyncDuration))throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');Object(v.a)(r.debug),this.config=r,this._autoLevelCapping=-1;var o=this.observer=new b.a;o.trigger=function(t){for(var e=arguments.length,r=Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];o.emit.apply(o,[t,t].concat(r))},o.off=function(t){for(var e=arguments.length,r=Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];o.removeListener.apply(o,[t].concat(r))},this.on=o.on.bind(o),this.off=o.off.bind(o),this.trigger=o.trigger.bind(o);var p=this.abrController=new r.abrController(this),g=new r.bufferController(this),y=new r.capLevelController(this),m=new r.fpsController(this),E=new s.a(this),T=new l.a(this),S=new u.a(this),R=new f.a(this),A=this.levelController=new h.a(this),_=new d.b(this),w=this.streamController=new c.a(this,_),L=[A,w],D=r.audioStreamController;D&&L.push(new D(this,_)),this.networkControllers=L;var I=[E,T,S,p,g,y,m,R,_];if(D=r.audioTrackController){var k=new D(this);this.audioTrackController=k,I.push(k)}if(D=r.subtitleTrackController){var O=new D(this);this.subtitleTrackController=O,I.push(O)}if(D=r.emeController){var C=new D(this);this.emeController=C,I.push(C)}[r.subtitleStreamController,r.timelineController].forEach(function(t){t&&I.push(new t(e))}),this.coreComponents=I}return t.isSupported=function(){return Object(p.a)()},E(t,null,[{key:"version",get:function(){return"0.9.1"}},{key:"Events",get:function(){return y.a}},{key:"ErrorTypes",get:function(){return o.b}},{key:"ErrorDetails",get:function(){return o.a}},{key:"DefaultConfig",get:function(){return t.defaultConfig?t.defaultConfig:g.a},set:function(e){t.defaultConfig=e}}]),t.prototype.destroy=function(){v.b.log("destroy"),this.trigger(y.a.DESTROYING),this.detachMedia(),this.coreComponents.concat(this.networkControllers).forEach(function(t){t.destroy()}),this.url=null,this.observer.removeAllListeners(),this._autoLevelCapping=-1},t.prototype.attachMedia=function(t){v.b.log("attachMedia"),this.media=t,this.trigger(y.a.MEDIA_ATTACHING,{media:t})},t.prototype.detachMedia=function(){v.b.log("detachMedia"),this.trigger(y.a.MEDIA_DETACHING),this.media=null},t.prototype.loadSource=function(t){t=n.a.buildAbsoluteURL(window.location.href,t,{alwaysNormalize:!0}),v.b.log("loadSource:"+t),this.url=t,this.trigger(y.a.MANIFEST_LOADING,{url:t})},t.prototype.startLoad=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1;v.b.log("startLoad("+t+")"),this.networkControllers.forEach(function(e){e.startLoad(t)})},t.prototype.stopLoad=function(){v.b.log("stopLoad"),this.networkControllers.forEach(function(t){t.stopLoad()})},t.prototype.swapAudioCodec=function(){v.b.log("swapAudioCodec"),this.streamController.swapAudioCodec()},t.prototype.recoverMediaError=function(){v.b.log("recoverMediaError");var t=this.media;this.detachMedia(),this.attachMedia(t)},E(t,[{key:"levels",get:function(){return this.levelController.levels}},{key:"currentLevel",get:function(){return this.streamController.currentLevel},set:function(t){v.b.log("set currentLevel:"+t),this.loadLevel=t,this.streamController.immediateLevelSwitch()}},{key:"nextLevel",get:function(){return this.streamController.nextLevel},set:function(t){v.b.log("set nextLevel:"+t),this.levelController.manualLevel=t,this.streamController.nextLevelSwitch()}},{key:"loadLevel",get:function(){return this.levelController.level},set:function(t){v.b.log("set loadLevel:"+t),this.levelController.manualLevel=t}},{key:"nextLoadLevel",get:function(){return this.levelController.nextLoadLevel},set:function(t){this.levelController.nextLoadLevel=t}},{key:"firstLevel",get:function(){return Math.max(this.levelController.firstLevel,this.minAutoLevel)},set:function(t){v.b.log("set firstLevel:"+t),this.levelController.firstLevel=t}},{key:"startLevel",get:function(){return this.levelController.startLevel},set:function(t){v.b.log("set startLevel:"+t);var e=this;-1!==t&&(t=Math.max(t,e.minAutoLevel)),e.levelController.startLevel=t}},{key:"autoLevelCapping",get:function(){return this._autoLevelCapping},set:function(t){v.b.log("set autoLevelCapping:"+t),this._autoLevelCapping=t}},{key:"autoLevelEnabled",get:function(){return-1===this.levelController.manualLevel}},{key:"manualLevel",get:function(){return this.levelController.manualLevel}},{key:"minAutoLevel",get:function(){for(var t=this,e=t.levels,r=t.config.minAutoBitrate,i=e?e.length:0,a=0;a<i;a++){if((e[a].realBitrate?Math.max(e[a].realBitrate,e[a].bitrate):e[a].bitrate)>r)return a}return 0}},{key:"maxAutoLevel",get:function(){var t=this,e=t.levels,r=t.autoLevelCapping;return-1===r&&e&&e.length?e.length-1:r}},{key:"nextAutoLevel",get:function(){var t=this;return Math.min(Math.max(t.abrController.nextAutoLevel,t.minAutoLevel),t.maxAutoLevel)},set:function(t){var e=this;e.abrController.nextAutoLevel=Math.max(e.minAutoLevel,t)}},{key:"audioTracks",get:function(){var t=this.audioTrackController;return t?t.audioTracks:[]}},{key:"audioTrack",get:function(){var t=this.audioTrackController;return t?t.audioTrack:-1},set:function(t){var e=this.audioTrackController;e&&(e.audioTrack=t)}},{key:"liveSyncPosition",get:function(){return this.streamController.liveSyncPosition}},{key:"subtitleTracks",get:function(){var t=this.subtitleTrackController;return t?t.subtitleTracks:[]}},{key:"subtitleTrack",get:function(){var t=this.subtitleTrackController;return t?t.subtitleTrack:-1},set:function(t){var e=this.subtitleTrackController;e&&(e.subtitleTrack=t)}},{key:"subtitleDisplay",get:function(){var t=this.subtitleTrackController;return!!t&&t.subtitleDisplay},set:function(t){var e=this.subtitleTrackController;e&&(e.subtitleDisplay=t)}}]),t}();e.default=T},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(4),n=r.n(a),o=r(6),s=r(16),l=r(29),u=r(0),d=r(17),c=/#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g,h=/#EXT-X-MEDIA:(.*)/g,f=new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,/|(?!#)(\S+)/.source,/|#EXT-X-BYTERANGE:*(.+)/.source,/|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,/|#.*/.source].join(""),"g"),p=/(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)(.*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/,v=function(){function t(){i(this,t)}return t.findGroup=function(t,e){if(!t)return null;for(var r=null,i=0;i<t.length;i++){var a=t[i];a.id===e&&(r=a)}return r},t.convertAVC1ToAVCOTI=function(t){var e=void 0,r=t.split(".");return r.length>2?(e=r.shift()+".",e+=parseInt(r.shift()).toString(16),e+=("000"+parseInt(r.shift()).toString(16)).substr(-4)):e=t,e},t.resolve=function(t,e){return n.a.buildAbsoluteURL(e,t,{alwaysNormalize:!0})},t.parseMasterPlaylist=function(e,r){var i=[],a=void 0;for(c.lastIndex=0;null!=(a=c.exec(e));){var n={},o=n.attrs=new l.a(a[1]);n.url=t.resolve(a[2],r);var s=o.decimalResolution("RESOLUTION");s&&(n.width=s.width,n.height=s.height),n.bitrate=o.decimalInteger("AVERAGE-BANDWIDTH")||o.decimalInteger("BANDWIDTH"),n.name=o.NAME,function(t,e){["video","audio"].forEach(function(r){var i=t.filter(function(t){return Object(d.b)(t,r)});if(i.length){var a=i.filter(function(t){return 0===t.lastIndexOf("avc1",0)||0===t.lastIndexOf("mp4a",0)});e[r+"Codec"]=a.length>0?a[0]:i[0],t=t.filter(function(t){return-1===i.indexOf(t)})}}),e.unknownCodecs=t}([].concat((o.CODECS||"").split(/[ ,]+/)),n),n.videoCodec&&-1!==n.videoCodec.indexOf("avc1")&&(n.videoCodec=t.convertAVC1ToAVCOTI(n.videoCodec)),i.push(n)}return i},t.parseMasterPlaylistMedia=function(e,r,i){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],n=void 0,o=[],s=0;for(h.lastIndex=0;null!==(n=h.exec(e));){var u={},d=new l.a(n[1]);if(d.TYPE===i){if(u.groupId=d["GROUP-ID"],u.name=d.NAME,u.type=i,u.default="YES"===d.DEFAULT,u.autoselect="YES"===d.AUTOSELECT,u.forced="YES"===d.FORCED,d.URI&&(u.url=t.resolve(d.URI,r)),u.lang=d.LANGUAGE,u.name||(u.name=u.lang),a.length){var c=t.findGroup(a,u.groupId);u.audioCodec=c?c.codec:a[0].codec}u.id=s++,o.push(u)}}return o},t.parseLevelPlaylist=function(t,e,r,i){var a=0,n=0,d={type:null,version:null,url:e,fragments:[],live:!0,startSN:0},c=new s.a,h=0,v=null,g=new o.a,y=void 0,m=void 0;for(f.lastIndex=0;null!==(y=f.exec(t));){var b=y[1];if(b){g.duration=parseFloat(b);var E=(" "+y[2]).slice(1);g.title=E||null,g.tagList.push(E?["INF",b,E]:["INF",b])}else if(y[3]){if(!isNaN(g.duration)){var T=a++;g.type=i,g.start=n,g.levelkey=c,g.sn=T,g.level=r,g.cc=h,g.baseurl=e,g.relurl=(" "+y[3]).slice(1),d.programDateTime&&(v?g.rawProgramDateTime?g.pdt=Date.parse(g.rawProgramDateTime):g.pdt=v.pdt+1e3*v.duration:g.pdt=Date.parse(d.programDateTime),g.endPdt=g.pdt+1e3*g.duration),d.fragments.push(g),v=g,n+=g.duration,g=new o.a}}else if(y[4]){if(g.rawByteRange=(" "+y[4]).slice(1),v){var S=v.byteRangeEndOffset;S&&(g.lastByteRangeEndOffset=S)}}else if(y[5])g.rawProgramDateTime=(" "+y[5]).slice(1),g.tagList.push(["PROGRAM-DATE-TIME",g.rawProgramDateTime]),void 0===d.programDateTime&&(d.programDateTime=new Date(new Date(Date.parse(y[5]))-1e3*n));else{for(y=y[0].match(p),m=1;m<y.length&&void 0===y[m];m++);var R=(" "+y[m+1]).slice(1),A=(" "+y[m+2]).slice(1);switch(y[m]){case"#":g.tagList.push(A?[R,A]:[R]);break;case"PLAYLIST-TYPE":d.type=R.toUpperCase();break;case"MEDIA-SEQUENCE":a=d.startSN=parseInt(R);break;case"TARGETDURATION":d.targetduration=parseFloat(R);break;case"VERSION":d.version=parseInt(R);break;case"EXTM3U":break;case"ENDLIST":d.live=!1;break;case"DIS":h++,g.tagList.push(["DIS"]);break;case"DISCONTINUITY-SEQ":h=parseInt(R);break;case"KEY":var _=R,w=new l.a(_),L=w.enumeratedString("METHOD"),D=w.URI,I=w.hexadecimalInteger("IV");L&&(c=new s.a,D&&["AES-128","SAMPLE-AES","SAMPLE-AES-CENC"].indexOf(L)>=0&&(c.method=L,c.baseuri=e,c.reluri=D,c.key=null,c.iv=I));break;case"START":var k=R,O=new l.a(k),C=O.decimalFloatingPoint("TIME-OFFSET");isNaN(C)||(d.startTimeOffset=C);break;case"MAP":var P=new l.a(R);g.relurl=P.URI,g.rawByteRange=P.BYTERANGE,g.baseurl=e,g.level=r,g.type=i,g.sn="initSegment",d.initSegment=g,g=new o.a;break;default:u.b.warn("line parsed but not handled: "+y)}}}return g=v,g&&!g.relurl&&(d.fragments.pop(),n-=g.duration),d.totalduration=n,d.averagetargetduration=n/d.fragments.length,d.endSN=a-1,d.startCC=d.fragments[0]?d.fragments[0].cc:0,d.endCC=h,!d.initSegment&&d.fragments.length&&d.fragments.every(function(t){return t.relurl.endsWith(".mp4")})&&(u.b.warn("MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX"),g=new o.a,g.relurl=d.fragments[0].relurl,g.baseurl=e,g.level=r,g.type=i,g.sn="initSegment",d.initSegment=g,d.needSidxRanges=!0),d},t}();e.a=v},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=/^(\d+)x(\d+)$/,n=/\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g,o=function(){function t(e){i(this,t),"string"==typeof e&&(e=t.parseAttrList(e));for(var r in e)e.hasOwnProperty(r)&&(this[r]=e[r])}return t.prototype.decimalInteger=function(t){var e=parseInt(this[t],10);return e>Number.MAX_SAFE_INTEGER?1/0:e},t.prototype.hexadecimalInteger=function(t){if(this[t]){var e=(this[t]||"0x").slice(2);e=(1&e.length?"0":"")+e;for(var r=new Uint8Array(e.length/2),i=0;i<e.length/2;i++)r[i]=parseInt(e.slice(2*i,2*i+2),16);return r}return null},t.prototype.hexadecimalIntegerAsNumber=function(t){var e=parseInt(this[t],16);return e>Number.MAX_SAFE_INTEGER?1/0:e},t.prototype.decimalFloatingPoint=function(t){return parseFloat(this[t])},t.prototype.enumeratedString=function(t){return this[t]},t.prototype.decimalResolution=function(t){var e=a.exec(this[t]);if(null!==e)return{width:parseInt(e[1],10),height:parseInt(e[2],10)}},t.parseAttrList=function(t){var e=void 0,r={};for(n.lastIndex=0;null!==(e=n.exec(t));){var i=e[2];0===i.indexOf('"')&&i.lastIndexOf('"')===i.length-1&&(i=i.slice(1,-1)),r[e[1]]=i}return r},t}();e.a=o},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(1),s=r(3),l=r(2),u=r(0),d=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,o.a.FRAG_LOADING));return n.loaders={},n}return n(e,t),e.prototype.destroy=function(){var e=this.loaders;for(var r in e){var i=e[r];i&&i.destroy()}this.loaders={},t.prototype.destroy.call(this)},e.prototype.onFragLoading=function(t){var e=t.frag,r=e.type,i=this.loaders,a=this.hls.config,n=a.fLoader,o=a.loader;e.loaded=0;var s=i[r];s&&(u.b.warn("abort previous fragment loader for type: "+r),s.abort()),s=i[r]=e.loader=a.fLoader?new n(a):new o(a);var l=void 0,d=void 0,c=void 0;l={url:e.url,frag:e,responseType:"arraybuffer",progressData:!1};var h=e.byteRangeStartOffset,f=e.byteRangeEndOffset;isNaN(h)||isNaN(f)||(l.rangeStart=h,l.rangeEnd=f),d={timeout:a.fragLoadingTimeOut,maxRetry:0,retryDelay:0,maxRetryDelay:a.fragLoadingMaxRetryTimeout},c={onSuccess:this.loadsuccess.bind(this),onError:this.loaderror.bind(this),onTimeout:this.loadtimeout.bind(this),onProgress:this.loadprogress.bind(this)},s.load(l,d,c)},e.prototype.loadsuccess=function(t,e,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=t.data,n=r.frag;n.loader=void 0,this.loaders[n.type]=void 0,this.hls.trigger(o.a.FRAG_LOADED,{payload:a,frag:n,stats:e,networkDetails:i})},e.prototype.loaderror=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,i=e.loader;i&&i.abort(),this.loaders[e.type]=void 0,this.hls.trigger(o.a.ERROR,{type:l.b.NETWORK_ERROR,details:l.a.FRAG_LOAD_ERROR,fatal:!1,frag:e.frag,response:t,networkDetails:r})},e.prototype.loadtimeout=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,i=e.loader;i&&i.abort(),this.loaders[e.type]=void 0,this.hls.trigger(o.a.ERROR,{type:l.b.NETWORK_ERROR,details:l.a.FRAG_LOAD_TIMEOUT,fatal:!1,frag:e.frag,networkDetails:r})},e.prototype.loadprogress=function(t,e,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=e.frag;a.loaded=t.loaded,this.hls.trigger(o.a.FRAG_LOAD_PROGRESS,{frag:a,stats:t,networkDetails:i})},e}(s.a);e.a=d},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(1),s=r(3),l=r(2),u=r(0),d=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,o.a.KEY_LOADING));return n.loaders={},n.decryptkey=null,n.decrypturl=null,n}return n(e,t),e.prototype.destroy=function(){for(var t in this.loaders){var e=this.loaders[t];e&&e.destroy()}this.loaders={},s.a.prototype.destroy.call(this)},e.prototype.onKeyLoading=function(t){var e=t.frag,r=e.type,i=this.loaders[r],a=e.decryptdata,n=a.uri;if(n!==this.decrypturl||null===this.decryptkey){var s=this.hls.config;i&&(u.b.warn("abort previous key loader for type:"+r),i.abort()),e.loader=this.loaders[r]=new s.loader(s),this.decrypturl=n,this.decryptkey=null;var l=void 0,d=void 0,c=void 0;l={url:n,frag:e,responseType:"arraybuffer"},d={timeout:s.fragLoadingTimeOut,maxRetry:s.fragLoadingMaxRetry,retryDelay:s.fragLoadingRetryDelay,maxRetryDelay:s.fragLoadingMaxRetryTimeout},c={onSuccess:this.loadsuccess.bind(this),onError:this.loaderror.bind(this),onTimeout:this.loadtimeout.bind(this)},e.loader.load(l,d,c)}else this.decryptkey&&(a.key=this.decryptkey,this.hls.trigger(o.a.KEY_LOADED,{frag:e}))},e.prototype.loadsuccess=function(t,e,r){var i=r.frag;this.decryptkey=i.decryptdata.key=new Uint8Array(t.data),i.loader=void 0,this.loaders[i.type]=void 0,this.hls.trigger(o.a.KEY_LOADED,{frag:i})},e.prototype.loaderror=function(t,e){var r=e.frag,i=r.loader;i&&i.abort(),this.loaders[e.type]=void 0,this.hls.trigger(o.a.ERROR,{type:l.b.NETWORK_ERROR,details:l.a.KEY_LOAD_ERROR,fatal:!1,frag:r,response:t})},e.prototype.loadtimeout=function(t,e){var r=e.frag,i=r.loader;i&&i.abort(),this.loaders[e.type]=void 0,this.hls.trigger(o.a.ERROR,{type:l.b.NETWORK_ERROR,details:l.a.KEY_LOAD_TIMEOUT,fatal:!1,frag:r})},e}(s.a);e.a=d},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(8),s=r(9),l=r(18),u=r(1),d=r(7),c=r(6),h=r(14),f=r(22),p=r(23),v=r(2),g=r(0),y=r(24),m=r(13),b=function(){function t(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,r,i){return r&&t(e.prototype,r),i&&t(e,i),e}}(),E={STOPPED:"STOPPED",IDLE:"IDLE",KEY_LOADING:"KEY_LOADING",FRAG_LOADING:"FRAG_LOADING",FRAG_LOADING_WAITING_RETRY:"FRAG_LOADING_WAITING_RETRY",WAITING_LEVEL:"WAITING_LEVEL",PARSING:"PARSING",PARSED:"PARSED",BUFFER_FLUSHING:"BUFFER_FLUSHING",ENDED:"ENDED",ERROR:"ERROR"},T=function(t){function e(r,n){i(this,e);var o=a(this,t.call(this,r,u.a.MEDIA_ATTACHED,u.a.MEDIA_DETACHING,u.a.MANIFEST_LOADING,u.a.MANIFEST_PARSED,u.a.LEVEL_LOADED,u.a.KEY_LOADED,u.a.FRAG_LOADED,u.a.FRAG_LOAD_EMERGENCY_ABORTED,u.a.FRAG_PARSING_INIT_SEGMENT,u.a.FRAG_PARSING_DATA,u.a.FRAG_PARSED,u.a.ERROR,u.a.AUDIO_TRACK_SWITCHING,u.a.AUDIO_TRACK_SWITCHED,u.a.BUFFER_CREATED,u.a.BUFFER_APPENDED,u.a.BUFFER_FLUSHED));return o.fragmentTracker=n,o.config=r.config,o.audioCodecSwap=!1,o._state=E.STOPPED,o.stallReported=!1,o}return n(e,t),e.prototype.onHandlerDestroying=function(){this.stopLoad()},e.prototype.onHandlerDestroyed=function(){this.state=E.STOPPED,this.fragmentTracker=null},e.prototype.startLoad=function(t){if(this.levels){var e=this.lastCurrentTime,r=this.hls;if(this.stopLoad(),this.setInterval(100),this.level=-1,this.fragLoadError=0,!this.startFragRequested){var i=r.startLevel;-1===i&&(i=0,this.bitrateTest=!0),this.level=r.nextLoadLevel=i,this.loadedmetadata=!1}e>0&&-1===t&&(g.b.log("override startPosition with lastCurrentTime @"+e.toFixed(3)),t=e),this.state=E.IDLE,this.nextLoadPosition=this.startPosition=this.lastCurrentTime=t,this.tick()}else this.forceStartLoad=!0,this.state=E.STOPPED},e.prototype.stopLoad=function(){var t=this.fragCurrent;t&&(t.loader&&t.loader.abort(),this.fragmentTracker.removeFragment(t),this.fragCurrent=null),this.fragPrevious=null,this.demuxer&&(this.demuxer.destroy(),this.demuxer=null),this.clearInterval(),this.state=E.STOPPED,this.forceStartLoad=!1},e.prototype.doTick=function(){switch(this.state){case E.BUFFER_FLUSHING:this.fragLoadError=0;break;case E.IDLE:this._doTickIdle();break;case E.WAITING_LEVEL:var t=this.levels[this.level];t&&t.details&&(this.state=E.IDLE);break;case E.FRAG_LOADING_WAITING_RETRY:var e=performance.now(),r=this.retryDate;(!r||e>=r||this.media&&this.media.seeking)&&(g.b.log("mediaController: retryDate reached, switch back to IDLE state"),this.state=E.IDLE);break;case E.ERROR:case E.STOPPED:case E.FRAG_LOADING:case E.PARSING:case E.PARSED:case E.ENDED:}this._checkBuffer(),this._checkFragmentChanged()},e.prototype._doTickIdle=function(){var t=this.hls,e=t.config,r=this.media;if(void 0!==this.levelLastLoaded&&(r||!this.startFragRequested&&e.startFragPrefetch)){var i=void 0;i=this.loadedmetadata?r.currentTime:this.nextLoadPosition;var a=t.nextLoadLevel,n=this.levels[a];if(n){var o=n.bitrate,l=void 0;l=o?Math.max(8*e.maxBufferSize/o,e.maxBufferLength):e.maxBufferLength,l=Math.min(l,e.maxMaxBufferLength);var d=s.a.bufferInfo(this.mediaBuffer?this.mediaBuffer:r,i,e.maxBufferHole),c=d.len;if(!(c>=l)){g.b.trace("buffer length of "+c.toFixed(3)+" is below max of "+l.toFixed(3)+". checking for more payload ..."),this.level=t.nextLoadLevel=a;var h=n.details;if(void 0===h||!0===h.live&&this.levelLastLoaded!==a)return void(this.state=E.WAITING_LEVEL);var f=this.fragPrevious;if(!h.live&&f&&!f.backtracked&&f.sn===h.endSN&&!d.nextStart){if(Math.min(r.duration,f.start+f.duration)-Math.max(d.end,f.start)<=Math.max(.2,f.duration)){var p={};return this.altAudio&&(p.type="video"),this.hls.trigger(u.a.BUFFER_EOS,p),void(this.state=E.ENDED)}}this._fetchPayloadOrEos(i,d,h)}}}},e.prototype._fetchPayloadOrEos=function(t,e,r){var i=this.fragPrevious,a=this.level,n=r.fragments,o=n.length;if(0!==o){var s=n[0].start,l=n[o-1].start+n[o-1].duration,u=e.end,d=void 0;if(r.initSegment&&!r.initSegment.data)d=r.initSegment;else if(r.live){var c=this.config.initialLiveManifestSize;if(o<c)return void g.b.warn("Can not start playback of a level, reason: not enough fragments "+o+" < "+c);if(null===(d=this._ensureFragmentAtLivePoint(r,u,s,l,i,n,o)))return}else u<s&&(d=n[0]);d||(d=this._findFragment(s,i,o,n,u,l,r)),d&&this._loadFragmentOrKey(d,a,r,t,u)}},e.prototype._ensureFragmentAtLivePoint=function(t,e,r,i,a,n,s){var l=this.hls.config,u=this.media,d=void 0,c=void 0!==l.liveMaxLatencyDuration?l.liveMaxLatencyDuration:l.liveMaxLatencyDurationCount*t.targetduration;if(e<Math.max(r-l.maxFragLookUpTolerance,i-c)){var h=this.liveSyncPosition=this.computeLivePosition(r,t);g.b.log("buffer end: "+e.toFixed(3)+" is located too far from the end of live sliding playlist, reset currentTime to : "+h.toFixed(3)),e=h,u&&u.readyState&&u.duration>h&&(u.currentTime=h),this.nextLoadPosition=h}if(t.PTSKnown&&e>i&&u&&u.readyState)return null;if(this.startFragRequested&&!t.PTSKnown){if(a)if(t.programDateTime)d=this._findFragmentByPDT(n,a.endPdt+1);else{var f=a.sn+1;if(f>=t.startSN&&f<=t.endSN){var p=n[f-t.startSN];a.cc===p.cc&&(d=p,g.b.log("live playlist, switching playlist, load frag with next SN: "+d.sn))}d||(d=o.a.search(n,function(t){return a.cc-t.cc}))&&g.b.log("live playlist, switching playlist, load frag with same CC: "+d.sn)}d||(d=n[Math.min(s-1,Math.round(s/2))],g.b.log("live playlist, switching playlist, unknown, load middle frag : "+d.sn))}return d},e.prototype._findFragmentByPDT=function(t,e){if(!t||void 0===e)return null;if(e<t[0].pdt)return null;if(e>=t[t.length-1].endPdt)return null;for(var r=0;r<t.length;++r){var i=t[r];if(e<i.endPdt)return i}return null},e.prototype._findFragmentBySN=function(t,e,r,i){var a=this.hls.config,n=void 0,s=a.maxFragLookUpTolerance,l=t?e[t.sn-e[0].sn+1]:void 0,u=function(t){var e=Math.min(s,t.duration+(t.deltaPTS?t.deltaPTS:0));return t.start+t.duration-e<=r?1:t.start-e>r&&t.start?-1:0};return r<i&&(r>i-s&&(s=0),n=l&&!u(l)?l:o.a.search(e,u)),n},e.prototype._findFragment=function(t,e,r,i,a,n,o){var s=this.hls.config,l=void 0,u=void 0;if(u=a<n?o.programDateTime?this._findFragmentByPDT(i,1e3*a+(o.programDateTime?Date.parse(o.programDateTime):0)-1e3*t):this._findFragmentBySN(e,i,a,n):i[r-1]){l=u;var d=l.sn-o.startSN,c=e&&l.level===e.level,h=i[d-1],f=i[d+1];if(e&&l.sn===e.sn)if(c&&!l.backtracked)if(l.sn<o.endSN){var p=e.deltaPTS;p&&p>s.maxBufferHole&&e.dropped&&d?(l=h,g.b.warn("SN just loaded, with large PTS gap between audio and video, maybe frag is not starting with a keyframe ? load previous one to try to overcome this")):(l=f,g.b.log("SN just loaded, load next one: "+l.sn))}else l=null;else l.backtracked&&(f&&f.backtracked?(g.b.warn("Already backtracked from fragment "+f.sn+", will not backtrack to fragment "+l.sn+". Loading fragment "+f.sn),l=f):(g.b.warn("Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe"),l.dropped=0,h?(l=h,l.backtracked=!0):d&&(l=null)))}return l},e.prototype._loadFragmentOrKey=function(t,e,r,i,a){if(t.decryptdata&&null!=t.decryptdata.uri&&null==t.decryptdata.key)g.b.log("Loading key for "+t.sn+" of ["+r.startSN+" ,"+r.endSN+"],level "+e),this.state=E.KEY_LOADING,this.hls.trigger(u.a.KEY_LOADING,{frag:t});else{g.b.log("Loading "+t.sn+" of ["+r.startSN+" ,"+r.endSN+"],level "+e+", currentTime:"+i.toFixed(3)+",bufferEnd:"+a.toFixed(3));var n=this.fragmentTracker.getState(t);this.fragCurrent=t,this.startFragRequested=!0,isNaN(t.sn)||t.bitrateTest||(this.nextLoadPosition=t.start+t.duration),t.backtracked||n===d.a.NOT_LOADED?(t.autoLevel=this.hls.autoLevelEnabled,t.bitrateTest=this.bitrateTest,this.hls.trigger(u.a.FRAG_LOADING,{frag:t}),this.demuxer||(this.demuxer=new l.a(this.hls,"main")),this.state=E.FRAG_LOADING):n===d.a.APPENDING&&this._reduceMaxBufferLength(t.duration)&&this.fragmentTracker.removeFragment(t)}},e.prototype.getBufferedFrag=function(t){return this.fragmentTracker.getBufferedFrag(t,h.a.LevelType.MAIN)},e.prototype.followingBufferedFrag=function(t){return t?this.getBufferedFrag(t.endPTS+.5):null},e.prototype._checkFragmentChanged=function(){var t=void 0,e=void 0,r=this.media;if(r&&r.readyState&&!1===r.seeking&&(e=r.currentTime,e>r.playbackRate*this.lastCurrentTime&&(this.lastCurrentTime=e),s.a.isBuffered(r,e)?t=this.getBufferedFrag(e):s.a.isBuffered(r,e+.1)&&(t=this.getBufferedFrag(e+.1)),t)){var i=t;if(i!==this.fragPlaying){this.hls.trigger(u.a.FRAG_CHANGED,{frag:i});var a=i.level;this.fragPlaying&&this.fragPlaying.level===a||this.hls.trigger(u.a.LEVEL_SWITCHED,{level:a}),this.fragPlaying=i}}},e.prototype.immediateLevelSwitch=function(){if(g.b.log("immediateLevelSwitch"),!this.immediateSwitch){this.immediateSwitch=!0;var t=this.media,e=void 0;t?(e=t.paused,t.pause()):e=!0,this.previouslyPaused=e}var r=this.fragCurrent;r&&r.loader&&r.loader.abort(),this.fragCurrent=null,this.flushMainBuffer(0,Number.POSITIVE_INFINITY)},e.prototype.immediateLevelSwitchEnd=function(){var t=this.media;t&&t.buffered.length&&(this.immediateSwitch=!1,s.a.isBuffered(t,t.currentTime)&&(t.currentTime-=1e-4),this.previouslyPaused||t.play())},e.prototype.nextLevelSwitch=function(){var t=this.media;if(t&&t.readyState){var e=void 0,r=void 0,i=void 0;if(r=this.getBufferedFrag(t.currentTime),r&&r.startPTS>1&&this.flushMainBuffer(0,r.startPTS-1),t.paused)e=0;else{var a=this.hls.nextLoadLevel,n=this.levels[a],o=this.fragLastKbps;e=o&&this.fragCurrent?this.fragCurrent.duration*n.bitrate/(1e3*o)+1:0}if((i=this.getBufferedFrag(t.currentTime+e))&&(i=this.followingBufferedFrag(i))){var s=this.fragCurrent;s&&s.loader&&s.loader.abort(),this.fragCurrent=null,this.flushMainBuffer(i.maxStartPTS,Number.POSITIVE_INFINITY)}}},e.prototype.flushMainBuffer=function(t,e){this.state=E.BUFFER_FLUSHING;var r={startOffset:t,endOffset:e};this.altAudio&&(r.type="video"),this.hls.trigger(u.a.BUFFER_FLUSHING,r)},e.prototype.onMediaAttached=function(t){var e=this.media=this.mediaBuffer=t.media;this.onvseeking=this.onMediaSeeking.bind(this),this.onvseeked=this.onMediaSeeked.bind(this),this.onvended=this.onMediaEnded.bind(this),e.addEventListener("seeking",this.onvseeking),e.addEventListener("seeked",this.onvseeked),e.addEventListener("ended",this.onvended);var r=this.config;this.levels&&r.autoStartLoad&&this.hls.startLoad(r.startPosition)},e.prototype.onMediaDetaching=function(){var t=this.media;t&&t.ended&&(g.b.log("MSE detaching and video ended, reset startPosition"),this.startPosition=this.lastCurrentTime=0);var e=this.levels;e&&e.forEach(function(t){t.details&&t.details.fragments.forEach(function(t){t.backtracked=void 0})}),t&&(t.removeEventListener("seeking",this.onvseeking),t.removeEventListener("seeked",this.onvseeked),t.removeEventListener("ended",this.onvended),this.onvseeking=this.onvseeked=this.onvended=null),this.media=this.mediaBuffer=null,this.loadedmetadata=!1,this.stopLoad()},e.prototype.onMediaSeeking=function(){var t=this.media,e=t?t.currentTime:void 0,r=this.config;isNaN(e)||g.b.log("media seeking to "+e.toFixed(3));var i=this.mediaBuffer?this.mediaBuffer:t,a=s.a.bufferInfo(i,e,this.config.maxBufferHole);if(this.state===E.FRAG_LOADING){var n=this.fragCurrent;if(0===a.len&&n){var o=r.maxFragLookUpTolerance,l=n.start-o,u=n.start+n.duration+o;e<l||e>u?(n.loader&&(g.b.log("seeking outside of buffer while fragment load in progress, cancel fragment load"),n.loader.abort()),this.fragCurrent=null,this.fragPrevious=null,this.state=E.IDLE):g.b.log("seeking outside of buffer but within currently loaded fragment range")}}else this.state===E.ENDED&&(0===a.len&&(this.fragPrevious=0),this.state=E.IDLE);t&&(this.lastCurrentTime=e),this.loadedmetadata||(this.nextLoadPosition=this.startPosition=e),this.tick()},e.prototype.onMediaSeeked=function(){var t=this.media,e=t?t.currentTime:void 0;isNaN(e)||g.b.log("media seeked to "+e.toFixed(3)),this.tick()},e.prototype.onMediaEnded=function(){g.b.log("media ended"),this.startPosition=this.lastCurrentTime=0},e.prototype.onManifestLoading=function(){g.b.log("trigger BUFFER_RESET"),this.hls.trigger(u.a.BUFFER_RESET),this.fragmentTracker.removeAllFragments(),this.stalled=!1,this.startPosition=this.lastCurrentTime=0},e.prototype.onManifestParsed=function(t){var e=!1,r=!1,i=void 0;t.levels.forEach(function(t){(i=t.audioCodec)&&(-1!==i.indexOf("mp4a.40.2")&&(e=!0),-1!==i.indexOf("mp4a.40.5")&&(r=!0))}),this.audioCodecSwitch=e&&r,this.audioCodecSwitch&&g.b.log("both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"),this.levels=t.levels,this.startFragRequested=!1;var a=this.config;(a.autoStartLoad||this.forceStartLoad)&&this.hls.startLoad(a.startPosition)},e.prototype.onLevelLoaded=function(t){var e=t.details,r=t.level,i=this.levels[this.levelLastLoaded],a=this.levels[r],n=e.totalduration,o=0;if(g.b.log("level "+r+" loaded ["+e.startSN+","+e.endSN+"],duration:"+n),e.live){var s=a.details;s&&e.fragments.length>0?(f.a(s,e),o=e.fragments[0].start,this.liveSyncPosition=this.computeLivePosition(o,s),e.PTSKnown&&!isNaN(o)?g.b.log("live playlist sliding:"+o.toFixed(3)):(g.b.log("live playlist - outdated PTS, unknown sliding"),Object(y.a)(this.fragPrevious,i,e))):(g.b.log("live playlist - first load, unknown sliding"),e.PTSKnown=!1,Object(y.a)(this.fragPrevious,i,e))}else e.PTSKnown=!1;if(a.details=e,this.levelLastLoaded=r,this.hls.trigger(u.a.LEVEL_UPDATED,{details:e,level:r}),!1===this.startFragRequested){if(-1===this.startPosition||-1===this.lastCurrentTime){var l=e.startTimeOffset;isNaN(l)?e.live?(this.startPosition=this.computeLivePosition(o,e),g.b.log("configure startPosition to "+this.startPosition)):this.startPosition=0:(l<0&&(g.b.log("negative start time offset "+l+", count from end of last fragment"),l=o+n+l),g.b.log("start time offset found in playlist, adjust startPosition to "+l),this.startPosition=l),this.lastCurrentTime=this.startPosition}this.nextLoadPosition=this.startPosition}this.state===E.WAITING_LEVEL&&(this.state=E.IDLE),this.tick()},e.prototype.onKeyLoaded=function(){this.state===E.KEY_LOADING&&(this.state=E.IDLE,this.tick())},e.prototype.onFragLoaded=function(t){var e=this.fragCurrent,r=t.frag;if(this.state===E.FRAG_LOADING&&e&&"main"===r.type&&r.level===e.level&&r.sn===e.sn){var i=t.stats,a=this.levels[e.level],n=a.details;if(g.b.log("Loaded  "+e.sn+" of ["+n.startSN+" ,"+n.endSN+"],level "+e.level),this.bitrateTest=!1,this.stats=i,!0===r.bitrateTest&&this.hls.nextLoadLevel)this.state=E.IDLE,this.startFragRequested=!1,i.tparsed=i.tbuffered=performance.now(),this.hls.trigger(u.a.FRAG_BUFFERED,{stats:i,frag:e,id:"main"}),this.tick();else if("initSegment"===r.sn)this.state=E.IDLE,i.tparsed=i.tbuffered=performance.now(),n.initSegment.data=t.payload,this.hls.trigger(u.a.FRAG_BUFFERED,{stats:i,frag:e,id:"main"}),this.tick();else{this.state=E.PARSING;var o=n.totalduration,s=e.level,d=e.sn,c=this.config.defaultAudioCodec||a.audioCodec;this.audioCodecSwap&&(g.b.log("swapping playlist audio codec"),void 0===c&&(c=this.lastAudioCodec),c&&(c=-1!==c.indexOf("mp4a.40.5")?"mp4a.40.2":"mp4a.40.5")),this.pendingBuffering=!0,this.appended=!1,g.b.log("Parsing "+d+" of ["+n.startSN+" ,"+n.endSN+"],level "+s+", cc "+e.cc);var h=this.demuxer;h||(h=this.demuxer=new l.a(this.hls,"main"));var f=this.media,p=f&&f.seeking,v=!p&&(n.PTSKnown||!n.live),y=n.initSegment?n.initSegment.data:[];h.push(t.payload,y,c,a.videoCodec,e,o,v,void 0)}}this.fragLoadError=0},e.prototype.onFragParsingInitSegment=function(t){var e=this.fragCurrent,r=t.frag;if(e&&"main"===t.id&&r.sn===e.sn&&r.level===e.level&&this.state===E.PARSING){var i=t.tracks,a=void 0,n=void 0;if(i.audio&&this.altAudio&&delete i.audio,n=i.audio){var o=this.levels[this.level].audioCodec,s=navigator.userAgent.toLowerCase();o&&this.audioCodecSwap&&(g.b.log("swapping playlist audio codec"),o=-1!==o.indexOf("mp4a.40.5")?"mp4a.40.2":"mp4a.40.5"),this.audioCodecSwitch&&1!==n.metadata.channelCount&&-1===s.indexOf("firefox")&&(o="mp4a.40.5"),-1!==s.indexOf("android")&&"audio/mpeg"!==n.container&&(o="mp4a.40.2",g.b.log("Android: force audio codec to "+o)),n.levelCodec=o,n.id=t.id}n=i.video,n&&(n.levelCodec=this.levels[this.level].videoCodec,n.id=t.id),this.hls.trigger(u.a.BUFFER_CODECS,i);for(a in i){n=i[a],g.b.log("main track:"+a+",container:"+n.container+",codecs[level/parsed]=["+n.levelCodec+"/"+n.codec+"]");var l=n.initSegment;l&&(this.appended=!0,this.pendingBuffering=!0,this.hls.trigger(u.a.BUFFER_APPENDING,{type:a,data:l,parent:"main",content:"initSegment"}))}this.tick()}},e.prototype.onFragParsingData=function(t){var e=this,r=this.fragCurrent,i=t.frag;if(r&&"main"===t.id&&i.sn===r.sn&&i.level===r.level&&("audio"!==t.type||!this.altAudio)&&this.state===E.PARSING){var a=this.levels[this.level],n=r;if(isNaN(t.endPTS)&&(t.endPTS=t.startPTS+r.duration,t.endDTS=t.startDTS+r.duration),!0===t.hasAudio&&n.addElementaryStream(c.a.ElementaryStreamTypes.AUDIO),!0===t.hasVideo&&n.addElementaryStream(c.a.ElementaryStreamTypes.VIDEO),g.b.log("Parsed "+t.type+",PTS:["+t.startPTS.toFixed(3)+","+t.endPTS.toFixed(3)+"],DTS:["+t.startDTS.toFixed(3)+"/"+t.endDTS.toFixed(3)+"],nb:"+t.nb+",dropped:"+(t.dropped||0)),"video"===t.type)if(n.dropped=t.dropped,n.dropped)if(n.backtracked)g.b.warn("Already backtracked on this fragment, appending with the gap");else{var o=a.details;if(!o||n.sn!==o.startSN)return g.b.warn("missing video frame(s), backtracking fragment"),this.fragmentTracker.removeFragment(n),n.backtracked=!0,this.nextLoadPosition=t.startPTS,this.state=E.IDLE,this.fragPrevious=n,void this.tick();g.b.warn("missing video frame(s) on first frag, appending with gap")}else n.backtracked=!1;var s=f.b(a.details,n,t.startPTS,t.endPTS,t.startDTS,t.endDTS),l=this.hls;l.trigger(u.a.LEVEL_PTS_UPDATED,{details:a.details,level:this.level,drift:s,type:t.type,start:t.startPTS,end:t.endPTS}),[t.data1,t.data2].forEach(function(r){r&&r.length&&e.state===E.PARSING&&(e.appended=!0,e.pendingBuffering=!0,l.trigger(u.a.BUFFER_APPENDING,{type:t.type,data:r,parent:"main",content:"data"}))}),this.tick()}},e.prototype.onFragParsed=function(t){var e=this.fragCurrent,r=t.frag;e&&"main"===t.id&&r.sn===e.sn&&r.level===e.level&&this.state===E.PARSING&&(this.stats.tparsed=performance.now(),this.state=E.PARSED,this._checkAppendedParsed())},e.prototype.onAudioTrackSwitching=function(t){var e=!!t.url,r=t.id;if(!e){if(this.mediaBuffer!==this.media){g.b.log("switching on main audio, use media.buffered to schedule main fragment loading"),this.mediaBuffer=this.media;var i=this.fragCurrent;i.loader&&(g.b.log("switching to main audio track, cancel main fragment load"),i.loader.abort()),this.fragCurrent=null,this.fragPrevious=null,this.demuxer&&(this.demuxer.destroy(),this.demuxer=null),this.state=E.IDLE}var a=this.hls;a.trigger(u.a.BUFFER_FLUSHING,{startOffset:0,endOffset:Number.POSITIVE_INFINITY,type:"audio"}),a.trigger(u.a.AUDIO_TRACK_SWITCHED,{id:r}),this.altAudio=!1}},e.prototype.onAudioTrackSwitched=function(t){var e=t.id,r=!!this.hls.audioTracks[e].url;if(r){var i=this.videoBuffer;i&&this.mediaBuffer!==i&&(g.b.log("switching on alternate audio, use video.buffered to schedule main fragment loading"),this.mediaBuffer=i)}this.altAudio=r,this.tick()},e.prototype.onBufferCreated=function(t){var e=t.tracks,r=void 0,i=void 0,a=!1;for(var n in e){var o=e[n];"main"===o.id?(i=n,r=o,"video"===n&&(this.videoBuffer=e[n].buffer)):a=!0}a&&r?(g.b.log("alternate track found, use "+i+".buffered to schedule main fragment loading"),this.mediaBuffer=r.buffer):this.mediaBuffer=this.media},e.prototype.onBufferAppended=function(t){if("main"===t.parent){var e=this.state;e!==E.PARSING&&e!==E.PARSED||(this.pendingBuffering=t.pending>0,this._checkAppendedParsed())}},e.prototype._checkAppendedParsed=function(){if(!(this.state!==E.PARSED||this.appended&&this.pendingBuffering)){var t=this.fragCurrent;if(t){var e=this.mediaBuffer?this.mediaBuffer:this.media;g.b.log("main buffered : "+p.a.toString(e.buffered)),this.fragPrevious=t;var r=this.stats;r.tbuffered=performance.now(),this.fragLastKbps=Math.round(8*r.total/(r.tbuffered-r.tfirst)),this.hls.trigger(u.a.FRAG_BUFFERED,{stats:r,frag:t,id:"main"}),this.state=E.IDLE}this.tick()}},e.prototype.onError=function(t){var e=t.frag||this.fragCurrent;if(!e||"main"===e.type){var r=!!this.media&&s.a.isBuffered(this.media,this.media.currentTime)&&s.a.isBuffered(this.media,this.media.currentTime+.5);switch(t.details){case v.a.FRAG_LOAD_ERROR:case v.a.FRAG_LOAD_TIMEOUT:case v.a.KEY_LOAD_ERROR:case v.a.KEY_LOAD_TIMEOUT:if(!t.fatal)if(this.fragLoadError+1<=this.config.fragLoadingMaxRetry){var i=Math.min(Math.pow(2,this.fragLoadError)*this.config.fragLoadingRetryDelay,this.config.fragLoadingMaxRetryTimeout);g.b.warn("mediaController: frag loading failed, retry in "+i+" ms"),this.retryDate=performance.now()+i,this.loadedmetadata||(this.startFragRequested=!1,this.nextLoadPosition=this.startPosition),this.fragLoadError++,this.state=E.FRAG_LOADING_WAITING_RETRY}else g.b.error("mediaController: "+t.details+" reaches max retry, redispatch as fatal ..."),t.fatal=!0,this.state=E.ERROR;break;case v.a.LEVEL_LOAD_ERROR:case v.a.LEVEL_LOAD_TIMEOUT:this.state!==E.ERROR&&(t.fatal?(this.state=E.ERROR,g.b.warn("streamController: "+t.details+",switch to "+this.state+" state ...")):t.levelRetry||this.state!==E.WAITING_LEVEL||(this.state=E.IDLE));break;case v.a.BUFFER_FULL_ERROR:"main"!==t.parent||this.state!==E.PARSING&&this.state!==E.PARSED||(r?(this._reduceMaxBufferLength(this.config.maxBufferLength),this.state=E.IDLE):(g.b.warn("buffer full error also media.currentTime is not buffered, flush everything"),this.fragCurrent=null,this.flushMainBuffer(0,Number.POSITIVE_INFINITY)))}}},e.prototype._reduceMaxBufferLength=function(t){var e=this.config;return e.maxMaxBufferLength>=t&&(e.maxMaxBufferLength/=2,g.b.warn("main:reduce max buffer length to "+e.maxMaxBufferLength+"s"),!0)},e.prototype._checkBuffer=function(){var t=this.config,e=this.media;if(e&&0!==e.readyState){var r=e.currentTime,i=this.mediaBuffer?this.mediaBuffer:e,a=i.buffered;if(!this.loadedmetadata&&a.length)this.loadedmetadata=!0,this._seekToStartPos();else if(this.immediateSwitch)this.immediateLevelSwitchEnd();else{var n=!(e.paused&&e.readyState>1||e.ended||0===e.buffered.length),o=performance.now();if(r!==this.lastCurrentTime)this.stallReported&&(g.b.warn("playback not stuck anymore @"+r+", after "+Math.round(o-this.stalled)+"ms"),this.stallReported=!1),this.stalled=null,this.nudgeRetry=0;else if(n){if(!this.stalled)return void(this.stalled=o);var l=s.a.bufferInfo(e,r,t.maxBufferHole),u=o-this.stalled;this._tryFixBufferStall(l,u)}}}},e.prototype.onFragLoadEmergencyAborted=function(){this.state=E.IDLE,this.loadedmetadata||(this.startFragRequested=!1,this.nextLoadPosition=this.startPosition),this.tick()},e.prototype.onBufferFlushed=function(){var t=this.mediaBuffer?this.mediaBuffer:this.media;t&&this.fragmentTracker.detectEvictedFragments(c.a.ElementaryStreamTypes.VIDEO,t.buffered),this.state=E.IDLE,this.fragPrevious=null},e.prototype.swapAudioCodec=function(){this.audioCodecSwap=!this.audioCodecSwap},e.prototype.computeLivePosition=function(t,e){var r=void 0!==this.config.liveSyncDuration?this.config.liveSyncDuration:this.config.liveSyncDurationCount*e.targetduration;return t+Math.max(0,e.totalduration-r)},e.prototype._tryFixBufferStall=function(t,e){var r=this.config,i=this.media,a=i.currentTime;this._reportStall(t.len);var n=this.fragmentTracker.getPartialFragment(a);n&&this._trySkipBufferHole(n),t.len>.5&&e>1e3*r.highBufferWatchdogPeriod&&(this.stalled=null,this._tryNudgeBuffer())},e.prototype._reportStall=function(t){var e=this.hls,r=this.media;this.stallReported||(this.stallReported=!0,g.b.warn("Playback stalling at @"+r.currentTime+" due to low buffer"),e.trigger(u.a.ERROR,{type:v.b.MEDIA_ERROR,details:v.a.BUFFER_STALLED_ERROR,fatal:!1,buffer:t}))},e.prototype._trySkipBufferHole=function(t){for(var e=this.hls,r=this.media,i=r.currentTime,a=0,n=0;n<r.buffered.length;n++){var o=r.buffered.start(n);if(i>=a&&i<o)return r.currentTime=Math.max(o,r.currentTime+.1),g.b.warn("skipping hole, adjusting currentTime from "+i+" to "+r.currentTime),this.stalled=null,void e.trigger(u.a.ERROR,{type:v.b.MEDIA_ERROR,details:v.a.BUFFER_SEEK_OVER_HOLE,fatal:!1,reason:"fragment loaded with buffer holes, seeking from "+i+" to "+r.currentTime,frag:t});a=r.buffered.end(n)}},e.prototype._tryNudgeBuffer=function(){var t=this.config,e=this.hls,r=this.media,i=r.currentTime,a=(this.nudgeRetry||0)+1;if(this.nudgeRetry=a,a<t.nudgeMaxRetry){var n=i+a*t.nudgeOffset;g.b.log("adjust currentTime from "+i+" to "+n),r.currentTime=n,e.trigger(u.a.ERROR,{type:v.b.MEDIA_ERROR,details:v.a.BUFFER_NUDGE_ON_STALL,fatal:!1})}else g.b.error("still stuck in high buffer @"+i+" after "+t.nudgeMaxRetry+", raise fatal error"),e.trigger(u.a.ERROR,{type:v.b.MEDIA_ERROR,details:v.a.BUFFER_STALLED_ERROR,fatal:!0})},e.prototype._seekToStartPos=function(){var t=this.media,e=t.currentTime,r=t.seeking?e:this.startPosition;e!==r&&(g.b.log("target start position not buffered, seek to buffered.start(0) "+r+" from current time "+e+" "),t.currentTime=r)},b(e,[{key:"state",set:function(t){if(this.state!==t){var e=this.state;this._state=t,g.b.log("main stream:"+e+"->"+t),this.hls.trigger(u.a.STREAM_STATE_TRANSITION,{previousState:e,nextState:t})}},get:function(){return this._state}},{key:"currentLevel",get:function(){var t=this.media;if(t){var e=this.getBufferedFrag(t.currentTime);if(e)return e.level}return-1}},{key:"nextBufferedFrag",get:function(){var t=this.media;return t?this.followingBufferedFrag(this.getBufferedFrag(t.currentTime)):null}},{key:"nextLevel",get:function(){var t=this.nextBufferedFrag;return t?t.level:-1}},{key:"liveSyncPosition",get:function(){return this._liveSyncPosition},set:function(t){this._liveSyncPosition=t}}]),e}(m.a);e.a=T},function(t,e,r){function i(t){function e(i){if(r[i])return r[i].exports;var a=r[i]={i:i,l:!1,exports:{}};return t[i].call(a.exports,a,a.exports,e),a.l=!0,a.exports}var r={};e.m=t,e.c=r,e.i=function(t){return t},e.d=function(t,r,i){e.o(t,r)||Object.defineProperty(t,r,{configurable:!1,enumerable:!0,get:i})},e.n=function(t){var r=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(r,"a",r),r},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="/",e.oe=function(t){throw console.error(t),t};var i=e(e.s=ENTRY_MODULE);return i.default||i}function a(t){return(t+"").replace(/[.?*+^$[\]\\(){}|-]/g,"\\$&")}function n(t,e,i){var n={};n[i]=[];var o=e.toString(),s=o.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/);if(!s)return n;for(var d,c=s[1],h=new RegExp("(\\\\n|\\W)"+a(c)+u,"g");d=h.exec(o);)"dll-reference"!==d[3]&&n[i].push(d[3]);for(h=new RegExp("\\("+a(c)+'\\("(dll-reference\\s('+l+'))"\\)\\)'+u,"g");d=h.exec(o);)t[d[2]]||(n[i].push(d[1]),t[d[2]]=r(d[1]).m),n[d[2]]=n[d[2]]||[],n[d[2]].push(d[4]);return n}function o(t){return Object.keys(t).reduce(function(e,r){return e||t[r].length>0},!1)}function s(t,e){for(var r={main:[e]},i={main:[]},a={main:{}};o(r);)for(var s=Object.keys(r),l=0;l<s.length;l++){var u=s[l],d=r[u],c=d.pop();if(a[u]=a[u]||{},!a[u][c]&&t[u][c]){a[u][c]=!0,i[u]=i[u]||[],i[u].push(c);for(var h=n(t,t[u][c],u),f=Object.keys(h),p=0;p<f.length;p++)r[f[p]]=r[f[p]]||[],r[f[p]]=r[f[p]].concat(h[f[p]])}}return i}var l="[\\.|\\-|\\+|\\w|/|@]+",u="\\((/\\*.*?\\*/)?s?.*?("+l+").*?\\)";t.exports=function(t,e){e=e||{};var a={main:r.m},n=e.all?{main:Object.keys(a)}:s(a,t),o="";Object.keys(n).filter(function(t){return"main"!==t}).forEach(function(t){for(var e=0;n[t][e];)e++;n[t].push(e),a[t][e]="(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })",o=o+"var "+t+" = ("+i.toString().replace("ENTRY_MODULE",JSON.stringify(e))+")({"+n[t].map(function(e){return JSON.stringify(e)+": "+a[t][e].toString()}).join(",")+"});\n"}),o=o+"("+i.toString().replace("ENTRY_MODULE",JSON.stringify(t))+")({"+n.main.map(function(t){return JSON.stringify(t)+": "+a.main[t].toString()}).join(",")+"})(self);";var l=new window.Blob([o],{type:"text/javascript"});if(e.bare)return l;var u=window.URL||window.webkitURL||window.mozURL||window.msURL,d=u.createObjectURL(l),c=new window.Worker(d);return c.objectURL=d,c}},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=function(){function t(e,r){i(this,t),this.subtle=e,this.aesIV=r}return t.prototype.decrypt=function(t,e){return this.subtle.decrypt({name:"AES-CBC",iv:this.aesIV},e,t)},t}();e.a=a},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=function(){function t(e,r){i(this,t),this.subtle=e,this.key=r}return t.prototype.expandKey=function(){return this.subtle.importKey("raw",this.key,{name:"AES-CBC"},!1,["encrypt","decrypt"])},t}();e.a=a},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t){var e=t.byteLength,r=e&&new DataView(t).getUint8(e-1);return r?t.slice(0,e-r):t}var n=function(){function t(){i(this,t),this.rcon=[0,1,2,4,8,16,32,64,128,27,54],this.subMix=[new Uint32Array(256),new Uint32Array(256),new Uint32Array(256),new Uint32Array(256)],this.invSubMix=[new Uint32Array(256),new Uint32Array(256),new Uint32Array(256),new Uint32Array(256)],this.sBox=new Uint32Array(256),this.invSBox=new Uint32Array(256),this.key=new Uint32Array(0),this.initTable()}return t.prototype.uint8ArrayToUint32Array_=function(t){for(var e=new DataView(t),r=new Uint32Array(4),i=0;i<4;i++)r[i]=e.getUint32(4*i);return r},t.prototype.initTable=function(){var t=this.sBox,e=this.invSBox,r=this.subMix,i=r[0],a=r[1],n=r[2],o=r[3],s=this.invSubMix,l=s[0],u=s[1],d=s[2],c=s[3],h=new Uint32Array(256),f=0,p=0,v=0;for(v=0;v<256;v++)h[v]=v<128?v<<1:v<<1^283;for(v=0;v<256;v++){var g=p^p<<1^p<<2^p<<3^p<<4;g=g>>>8^255&g^99,t[f]=g,e[g]=f;var y=h[f],m=h[y],b=h[m],E=257*h[g]^16843008*g;i[f]=E<<24|E>>>8,a[f]=E<<16|E>>>16,n[f]=E<<8|E>>>24,o[f]=E,E=16843009*b^65537*m^257*y^16843008*f,l[g]=E<<24|E>>>8,u[g]=E<<16|E>>>16,d[g]=E<<8|E>>>24,c[g]=E,f?(f=y^h[h[h[b^y]]],p^=h[h[p]]):f=p=1}},t.prototype.expandKey=function(t){for(var e=this.uint8ArrayToUint32Array_(t),r=!0,i=0;i<e.length&&r;)r=e[i]===this.key[i],i++;if(!r){this.key=e;var a=this.keySize=e.length;if(4!==a&&6!==a&&8!==a)throw new Error("Invalid aes key size="+a);var n=this.ksRows=4*(a+6+1),o=void 0,s=void 0,l=this.keySchedule=new Uint32Array(n),u=this.invKeySchedule=new Uint32Array(n),d=this.sBox,c=this.rcon,h=this.invSubMix,f=h[0],p=h[1],v=h[2],g=h[3],y=void 0,m=void 0;for(o=0;o<n;o++)o<a?y=l[o]=e[o]:(m=y,o%a==0?(m=m<<8|m>>>24,m=d[m>>>24]<<24|d[m>>>16&255]<<16|d[m>>>8&255]<<8|d[255&m],m^=c[o/a|0]<<24):a>6&&o%a==4&&(m=d[m>>>24]<<24|d[m>>>16&255]<<16|d[m>>>8&255]<<8|d[255&m]),l[o]=y=(l[o-a]^m)>>>0);for(s=0;s<n;s++)o=n-s,m=3&s?l[o]:l[o-4],u[s]=s<4||o<=4?m:f[d[m>>>24]]^p[d[m>>>16&255]]^v[d[m>>>8&255]]^g[d[255&m]],u[s]=u[s]>>>0}},t.prototype.networkToHostOrderSwap=function(t){return t<<24|(65280&t)<<8|(16711680&t)>>8|t>>>24},t.prototype.decrypt=function(t,e,r,i){for(var n=this.keySize+6,o=this.invKeySchedule,s=this.invSBox,l=this.invSubMix,u=l[0],d=l[1],c=l[2],h=l[3],f=this.uint8ArrayToUint32Array_(r),p=f[0],v=f[1],g=f[2],y=f[3],m=new Int32Array(t),b=new Int32Array(m.length),E=void 0,T=void 0,S=void 0,R=void 0,A=void 0,_=void 0,w=void 0,L=void 0,D=void 0,I=void 0,k=void 0,O=void 0,C=void 0,P=void 0,x=this.networkToHostOrderSwap;e<m.length;){for(D=x(m[e]),I=x(m[e+1]),k=x(m[e+2]),O=x(m[e+3]),A=D^o[0],_=O^o[1],w=k^o[2],L=I^o[3],C=4,P=1;P<n;P++)E=u[A>>>24]^d[_>>16&255]^c[w>>8&255]^h[255&L]^o[C],T=u[_>>>24]^d[w>>16&255]^c[L>>8&255]^h[255&A]^o[C+1],S=u[w>>>24]^d[L>>16&255]^c[A>>8&255]^h[255&_]^o[C+2],R=u[L>>>24]^d[A>>16&255]^c[_>>8&255]^h[255&w]^o[C+3],A=E,_=T,w=S,L=R,C+=4;E=s[A>>>24]<<24^s[_>>16&255]<<16^s[w>>8&255]<<8^s[255&L]^o[C],T=s[_>>>24]<<24^s[w>>16&255]<<16^s[L>>8&255]<<8^s[255&A]^o[C+1],S=s[w>>>24]<<24^s[L>>16&255]<<16^s[A>>8&255]<<8^s[255&_]^o[C+2],R=s[L>>>24]<<24^s[A>>16&255]<<16^s[_>>8&255]<<8^s[255&w]^o[C+3],C+=3,b[e]=x(E^p),b[e+1]=x(R^v),b[e+2]=x(S^g),b[e+3]=x(T^y),p=D,v=I,g=k,y=O,e+=4}return i?a(b.buffer):b.buffer},t.prototype.destroy=function(){this.key=void 0,this.keySize=void 0,this.ksRows=void 0,this.sBox=void 0,this.invSBox=void 0,this.subMix=void 0,this.invSubMix=void 0,this.keySchedule=void 0,this.invKeySchedule=void 0,this.rcon=void 0},t}();e.a=n},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(20),n=r(0),o=r(5),s=function(){function t(e,r,a){i(this,t),this.observer=e,this.config=a,this.remuxer=r}return t.prototype.resetInitSegment=function(t,e,r,i){this._audioTrack={container:"audio/adts",type:"audio",id:0,sequenceNumber:0,isAAC:!0,samples:[],len:0,manifestCodec:e,duration:i,inputTimeScale:9e4}},t.prototype.resetTimeStamp=function(){},t.probe=function(t){if(!t)return!1;for(var e=o.a.getID3Data(t,0)||[],r=e.length,i=t.length;r<i;r++)if(a.e(t,r))return n.b.log("ADTS sync word found !"),!0;return!1},t.prototype.append=function(t,e,r,i){for(var s=this._audioTrack,l=o.a.getID3Data(t,0)||[],u=o.a.getTimeStamp(l),d=u?90*u:9e4*e,c=0,h=d,f=t.length,p=l.length,v=[{pts:h,dts:h,data:l}];p<f-1;)if(a.d(t,p)&&p+5<f){a.c(s,this.observer,t,p,s.manifestCodec);var g=a.a(s,t,p,d,c);if(!g){n.b.log("Unable to parse AAC frame");break}p+=g.length,h=g.sample.pts,c++}else o.a.isHeader(t,p)?(l=o.a.getID3Data(t,p),v.push({pts:h,dts:h,data:l}),p+=l.length):p++;this.remuxer.remux(s,{samples:[]},{samples:v,inputTimeScale:9e4},{samples:[]},e,r,i)},t.prototype.destroy=function(){},t}();e.a=s},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(20),n=r(21),o=r(1),s=r(39),l=r(40),u=r(0),d=r(2),c={video:0,audio:1,id3:2,text:3},h=function(){function t(e,r,a,n){i(this,t),this.observer=e,this.config=a,this.typeSupported=n,this.remuxer=r,this.sampleAes=null}return t.prototype.setDecryptData=function(t){null!=t&&null!=t.key&&"SAMPLE-AES"===t.method?this.sampleAes=new l.a(this.observer,this.config,t,this.discardEPB):this.sampleAes=null},t.probe=function(e){var r=t._syncOffset(e);return!(r<0)&&(r&&u.b.warn("MPEG2-TS detected but first sync word found @ offset "+r+", junk ahead ?"),!0)},t._syncOffset=function(t){for(var e=Math.min(1e3,t.length-564),r=0;r<e;){if(71===t[r]&&71===t[r+188]&&71===t[r+376])return r;r++}return-1},t.createTrack=function(t,e){return{container:"video"===t||"audio"===t?"video/mp2t":void 0,type:t,id:c[t],pid:-1,inputTimeScale:9e4,sequenceNumber:0,samples:[],len:0,dropped:"video"===t?0:void 0,isAAC:"audio"===t||void 0,duration:"audio"===t?e:void 0}},t.prototype.resetInitSegment=function(e,r,i,a){this.pmtParsed=!1,this._pmtId=-1,this._avcTrack=t.createTrack("video",a),this._audioTrack=t.createTrack("audio",a),this._id3Track=t.createTrack("id3",a),this._txtTrack=t.createTrack("text",a),this.aacOverFlow=null,this.aacLastPTS=null,this.avcSample=null,this.audioCodec=r,this.videoCodec=i,this._duration=a},t.prototype.resetTimeStamp=function(){},t.prototype.append=function(e,r,i,a){var n=void 0,s=e.length,l=void 0,c=void 0,h=void 0,f=void 0,p=!1;this.contiguous=i;var v=this.pmtParsed,g=this._avcTrack,y=this._audioTrack,m=this._id3Track,b=g.pid,E=y.pid,T=m.pid,S=this._pmtId,R=g.pesData,A=y.pesData,_=m.pesData,w=this._parsePAT,L=this._parsePMT,D=this._parsePES,I=this._parseAVCPES.bind(this),k=this._parseAACPES.bind(this),O=this._parseMPEGPES.bind(this),C=this._parseID3PES.bind(this),P=t._syncOffset(e);for(s-=(s+P)%188,n=P;n<s;n+=188)if(71===e[n]){if(l=!!(64&e[n+1]),c=((31&e[n+1])<<8)+e[n+2],(48&e[n+3])>>4>1){if((h=n+5+e[n+4])===n+188)continue}else h=n+4;switch(c){case b:l&&(R&&(f=D(R))&&void 0!==f.pts&&I(f,!1),R={data:[],size:0}),R&&(R.data.push(e.subarray(h,n+188)),R.size+=n+188-h);break;case E:l&&(A&&(f=D(A))&&void 0!==f.pts&&(y.isAAC?k(f):O(f)),A={data:[],size:0}),A&&(A.data.push(e.subarray(h,n+188)),A.size+=n+188-h);break;case T:l&&(_&&(f=D(_))&&void 0!==f.pts&&C(f),_={data:[],size:0}),_&&(_.data.push(e.subarray(h,n+188)),_.size+=n+188-h);break;case 0:l&&(h+=e[h]+1),S=this._pmtId=w(e,h);break;case S:l&&(h+=e[h]+1);var x=L(e,h,!0===this.typeSupported.mpeg||!0===this.typeSupported.mp3,null!=this.sampleAes);b=x.avc,b>0&&(g.pid=b),E=x.audio,E>0&&(y.pid=E,y.isAAC=x.isAAC),T=x.id3,T>0&&(m.pid=T),p&&!v&&(u.b.log("reparse from beginning"),p=!1,n=P-188),v=this.pmtParsed=!0;break;case 17:case 8191:break;default:p=!0}}else this.observer.trigger(o.a.ERROR,{type:d.b.MEDIA_ERROR,details:d.a.FRAG_PARSING_ERROR,fatal:!1,reason:"TS packet did not start with 0x47"});R&&(f=D(R))&&void 0!==f.pts?(I(f,!0),g.pesData=null):g.pesData=R,A&&(f=D(A))&&void 0!==f.pts?(y.isAAC?k(f):O(f),y.pesData=null):(A&&A.size&&u.b.log("last AAC PES packet truncated,might overlap between fragments"),y.pesData=A),_&&(f=D(_))&&void 0!==f.pts?(C(f),m.pesData=null):m.pesData=_,null==this.sampleAes?this.remuxer.remux(y,g,m,this._txtTrack,r,i,a):this.decryptAndRemux(y,g,m,this._txtTrack,r,i,a)},t.prototype.decryptAndRemux=function(t,e,r,i,a,n,o){if(t.samples&&t.isAAC){var s=this;this.sampleAes.decryptAacSamples(t.samples,0,function(){s.decryptAndRemuxAvc(t,e,r,i,a,n,o)})}else this.decryptAndRemuxAvc(t,e,r,i,a,n,o)},t.prototype.decryptAndRemuxAvc=function(t,e,r,i,a,n,o){if(e.samples){var s=this;this.sampleAes.decryptAvcSamples(e.samples,0,0,function(){s.remuxer.remux(t,e,r,i,a,n,o)})}else this.remuxer.remux(t,e,r,i,a,n,o)},t.prototype.destroy=function(){this._initPTS=this._initDTS=void 0,this._duration=0},t.prototype._parsePAT=function(t,e){return(31&t[e+10])<<8|t[e+11]},t.prototype._parsePMT=function(t,e,r,i){var a=void 0,n=void 0,o=void 0,s=void 0,l={audio:-1,avc:-1,id3:-1,isAAC:!0};for(a=(15&t[e+1])<<8|t[e+2],n=e+3+a-4,o=(15&t[e+10])<<8|t[e+11],e+=12+o;e<n;){switch(s=(31&t[e+1])<<8|t[e+2],t[e]){case 207:if(!i){u.b.log("unkown stream type:"+t[e]);break}case 15:-1===l.audio&&(l.audio=s);break;case 21:-1===l.id3&&(l.id3=s);break;case 219:if(!i){u.b.log("unkown stream type:"+t[e]);break}case 27:-1===l.avc&&(l.avc=s);break;case 3:case 4:r?-1===l.audio&&(l.audio=s,l.isAAC=!1):u.b.log("MPEG audio found, not supported in this browser for now");break;case 36:u.b.warn("HEVC stream type found, not supported for now");break;default:u.b.log("unkown stream type:"+t[e])}e+=5+((15&t[e+3])<<8|t[e+4])}return l},t.prototype._parsePES=function(t){var e=0,r=void 0,i=void 0,a=void 0,n=void 0,o=void 0,s=void 0,l=void 0,d=void 0,c=t.data;if(!t||0===t.size)return null;for(;c[0].length<19&&c.length>1;){var h=new Uint8Array(c[0].length+c[1].length);h.set(c[0]),h.set(c[1],c[0].length),c[0]=h,c.splice(1,1)}if(r=c[0],1===(r[0]<<16)+(r[1]<<8)+r[2]){if((a=(r[4]<<8)+r[5])&&a>t.size-6)return null;i=r[7],192&i&&(s=536870912*(14&r[9])+4194304*(255&r[10])+16384*(254&r[11])+128*(255&r[12])+(254&r[13])/2,s>4294967295&&(s-=8589934592),64&i?(l=536870912*(14&r[14])+4194304*(255&r[15])+16384*(254&r[16])+128*(255&r[17])+(254&r[18])/2,l>4294967295&&(l-=8589934592),s-l>54e5&&(u.b.warn(Math.round((s-l)/9e4)+"s delta between PTS and DTS, align them"),s=l)):l=s),n=r[8],d=n+9,t.size-=d,o=new Uint8Array(t.size);for(var f=0,p=c.length;f<p;f++){r=c[f];var v=r.byteLength;if(d){if(d>v){d-=v;continue}r=r.subarray(d),v-=d,d=0}o.set(r,e),e+=v}return a&&(a-=n+3),{data:o,pts:s,dts:l,len:a}}return null},t.prototype.pushAccesUnit=function(t,e){if(t.units.length&&t.frame){var r=e.samples,i=r.length;!this.config.forceKeyFrameOnDiscontinuity||!0===t.key||e.sps&&(i||this.contiguous)?(t.id=i,r.push(t)):e.dropped++}t.debug.length&&u.b.log(t.pts+"/"+t.dts+":"+t.debug)},t.prototype._parseAVCPES=function(t,e){var r=this,i=this._avcTrack,a=this._parseAVCNALu(t.data),n=void 0,o=this.avcSample,l=void 0,u=!1,d=void 0,c=this.pushAccesUnit.bind(this),h=function(t,e,r,i){return{key:t,pts:e,dts:r,units:[],debug:i}};t.data=null,o&&a.length&&!i.audFound&&(c(o,i),o=this.avcSample=h(!1,t.pts,t.dts,"")),a.forEach(function(e){switch(e.type){case 1:l=!0,o||(o=r.avcSample=h(!0,t.pts,t.dts,"")),o.frame=!0;var a=e.data;if(u&&a.length>4){var f=new s.a(a).readSliceType();2!==f&&4!==f&&7!==f&&9!==f||(o.key=!0)}break;case 5:l=!0,o||(o=r.avcSample=h(!0,t.pts,t.dts,"")),o.key=!0,o.frame=!0;break;case 6:l=!0,n=new s.a(r.discardEPB(e.data)),n.readUByte();for(var p=0,v=0,g=!1,y=0;!g&&n.bytesAvailable>1;){p=0;do{y=n.readUByte(),p+=y}while(255===y);v=0;do{y=n.readUByte(),v+=y}while(255===y);if(4===p&&0!==n.bytesAvailable){g=!0;if(181===n.readUByte()){if(49===n.readUShort()){if(1195456820===n.readUInt()){if(3===n.readUByte()){var m=n.readUByte(),b=n.readUByte(),E=31&m,T=[m,b];for(d=0;d<E;d++)T.push(n.readUByte()),T.push(n.readUByte()),T.push(n.readUByte());r._insertSampleInOrder(r._txtTrack.samples,{type:3,pts:t.pts,bytes:T})}}}}}else if(v<n.bytesAvailable)for(d=0;d<v;d++)n.readUByte()}break;case 7:if(l=!0,u=!0,!i.sps){n=new s.a(e.data);var S=n.readSPS();i.width=S.width,i.height=S.height,i.pixelRatio=S.pixelRatio,i.sps=[e.data],i.duration=r._duration;var R=e.data.subarray(1,4),A="avc1.";for(d=0;d<3;d++){var _=R[d].toString(16);_.length<2&&(_="0"+_),A+=_}i.codec=A}break;case 8:l=!0,i.pps||(i.pps=[e.data]);break;case 9:l=!1,i.audFound=!0,o&&c(o,i),o=r.avcSample=h(!1,t.pts,t.dts,"");break;case 12:l=!1;break;default:l=!1,o&&(o.debug+="unknown NAL "+e.type+" ")}if(o&&l){o.units.push(e)}}),e&&o&&(c(o,i),this.avcSample=null)},t.prototype._insertSampleInOrder=function(t,e){var r=t.length;if(r>0){if(e.pts>=t[r-1].pts)t.push(e);else for(var i=r-1;i>=0;i--)if(e.pts<t[i].pts){t.splice(i,0,e);break}}else t.push(e)},t.prototype._getLastNalUnit=function(){var t=this.avcSample,e=void 0;if(!t||0===t.units.length){var r=this._avcTrack,i=r.samples;t=i[i.length-1]}if(t){var a=t.units;e=a[a.length-1]}return e},t.prototype._parseAVCNALu=function(t){var e=0,r=t.byteLength,i=void 0,a=void 0,n=this._avcTrack,o=n.naluState||0,s=o,l=[],u=void 0,d=void 0,c=-1,h=void 0;for(-1===o&&(c=0,h=31&t[0],o=0,e=1);e<r;)if(i=t[e++],o)if(1!==o)if(i)if(1===i){if(c>=0)u={data:t.subarray(c,e-o-1),type:h},l.push(u);else{var f=this._getLastNalUnit();if(f&&(s&&e<=4-s&&f.state&&(f.data=f.data.subarray(0,f.data.byteLength-s)),(a=e-o-1)>0)){var p=new Uint8Array(f.data.byteLength+a);p.set(f.data,0),p.set(t.subarray(0,a),f.data.byteLength),f.data=p}}e<r?(d=31&t[e],c=e,h=d,o=0):o=-1}else o=0;else o=3;else o=i?0:2;else o=i?0:1;if(c>=0&&o>=0&&(u={data:t.subarray(c,r),type:h,state:o},l.push(u)),0===l.length){var v=this._getLastNalUnit();if(v){var g=new Uint8Array(v.data.byteLength+t.byteLength);g.set(v.data,0),g.set(t,v.data.byteLength),v.data=g}}return n.naluState=o,l},t.prototype.discardEPB=function(t){for(var e=t.byteLength,r=[],i=1,a=void 0,n=void 0;i<e-2;)0===t[i]&&0===t[i+1]&&3===t[i+2]?(r.push(i+2),i+=2):i++;if(0===r.length)return t;a=e-r.length,n=new Uint8Array(a);var o=0;for(i=0;i<a;o++,i++)o===r[0]&&(o++,r.shift()),n[i]=t[o];return n},t.prototype._parseAACPES=function(t){var e=this._audioTrack,r=t.data,i=t.pts,n=this.aacOverFlow,s=this.aacLastPTS,l=void 0,c=void 0,h=void 0,f=void 0,p=void 0;if(n){var v=new Uint8Array(n.byteLength+r.byteLength);v.set(n,0),v.set(r,n.byteLength),r=v}for(h=0,p=r.length;h<p-1&&!a.d(r,h);h++);if(h){var g=void 0,y=void 0;if(h<p-1?(g="AAC PES did not start with ADTS header,offset:"+h,y=!1):(g="no ADTS header found in AAC PES",y=!0),u.b.warn("parsing error:"+g),this.observer.trigger(o.a.ERROR,{type:d.b.MEDIA_ERROR,details:d.a.FRAG_PARSING_ERROR,fatal:y,reason:g}),y)return}if(a.c(e,this.observer,r,h,this.audioCodec),c=0,l=a.b(e.samplerate),n&&s){var m=s+l;Math.abs(m-i)>1&&(u.b.log("AAC: align PTS for overlapping frames by "+Math.round((m-i)/90)),i=m)}for(;h<p;)if(a.d(r,h)&&h+5<p){var b=a.a(e,r,h,i,c);if(!b)break;h+=b.length,f=b.sample.pts,c++}else h++;n=h<p?r.subarray(h,p):null,this.aacOverFlow=n,this.aacLastPTS=f},t.prototype._parseMPEGPES=function(t){for(var e=t.data,r=e.length,i=0,a=0,o=t.pts;a<r;)if(n.a.isHeader(e,a)){var s=n.a.appendFrame(this._audioTrack,e,a,o,i);if(!s)break;a+=s.length,i++}else a++},t.prototype._parseID3PES=function(t){this._id3Track.samples.push(t)},t}();e.a=h},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(0),n=function(){function t(e){i(this,t),this.data=e,this.bytesAvailable=e.byteLength,this.word=0,this.bitsAvailable=0}return t.prototype.loadWord=function(){var t=this.data,e=this.bytesAvailable,r=t.byteLength-e,i=new Uint8Array(4),a=Math.min(4,e);if(0===a)throw new Error("no bytes available");i.set(t.subarray(r,r+a)),this.word=new DataView(i.buffer).getUint32(0),this.bitsAvailable=8*a,this.bytesAvailable-=a},t.prototype.skipBits=function(t){var e=void 0;this.bitsAvailable>t?(this.word<<=t,this.bitsAvailable-=t):(t-=this.bitsAvailable,e=t>>3,t-=e>>3,this.bytesAvailable-=e,this.loadWord(),this.word<<=t,this.bitsAvailable-=t)},t.prototype.readBits=function(t){var e=Math.min(this.bitsAvailable,t),r=this.word>>>32-e;return t>32&&a.b.error("Cannot read more than 32 bits at a time"),this.bitsAvailable-=e,this.bitsAvailable>0?this.word<<=e:this.bytesAvailable>0&&this.loadWord(),e=t-e,e>0&&this.bitsAvailable?r<<e|this.readBits(e):r},t.prototype.skipLZ=function(){var t=void 0;for(t=0;t<this.bitsAvailable;++t)if(0!=(this.word&2147483648>>>t))return this.word<<=t,this.bitsAvailable-=t,t;return this.loadWord(),t+this.skipLZ()},t.prototype.skipUEG=function(){this.skipBits(1+this.skipLZ())},t.prototype.skipEG=function(){this.skipBits(1+this.skipLZ())},t.prototype.readUEG=function(){var t=this.skipLZ();return this.readBits(t+1)-1},t.prototype.readEG=function(){var t=this.readUEG();return 1&t?1+t>>>1:-1*(t>>>1)},t.prototype.readBoolean=function(){return 1===this.readBits(1)},t.prototype.readUByte=function(){return this.readBits(8)},t.prototype.readUShort=function(){return this.readBits(16)},t.prototype.readUInt=function(){return this.readBits(32)},t.prototype.skipScalingList=function(t){var e=8,r=8,i=void 0,a=void 0;for(i=0;i<t;i++)0!==r&&(a=this.readEG(),r=(e+a+256)%256),e=0===r?e:r},t.prototype.readSPS=function(){var t=0,e=0,r=0,i=0,a=void 0,n=void 0,o=void 0,s=void 0,l=void 0,u=void 0,d=void 0,c=this.readUByte.bind(this),h=this.readBits.bind(this),f=this.readUEG.bind(this),p=this.readBoolean.bind(this),v=this.skipBits.bind(this),g=this.skipEG.bind(this),y=this.skipUEG.bind(this),m=this.skipScalingList.bind(this);if(c(),a=c(),h(5),v(3),c(),y(),100===a||110===a||122===a||244===a||44===a||83===a||86===a||118===a||128===a){var b=f();if(3===b&&v(1),y(),y(),v(1),p())for(u=3!==b?8:12,d=0;d<u;d++)p()&&m(d<6?16:64)}y();var E=f();if(0===E)f();else if(1===E)for(v(1),g(),g(),n=f(),d=0;d<n;d++)g();y(),v(1),o=f(),s=f(),l=h(1),0===l&&v(1),v(1),p()&&(t=f(),e=f(),r=f(),i=f());var T=[1,1];if(p()&&p()){switch(c()){case 1:T=[1,1];break;case 2:T=[12,11];break;case 3:T=[10,11];break;case 4:T=[16,11];break;case 5:T=[40,33];break;case 6:T=[24,11];break;case 7:T=[20,11];break;case 8:T=[32,11];break;case 9:T=[80,33];break;case 10:T=[18,11];break;case 11:T=[15,11];break;case 12:T=[64,33];break;case 13:T=[160,99];break;case 14:T=[4,3];break;case 15:T=[3,2];break;case 16:T=[2,1];break;case 255:T=[c()<<8|c(),c()<<8|c()]}}return{width:Math.ceil(16*(o+1)-2*t-2*e),height:(2-l)*(s+1)*16-(l?2:4)*(r+i),pixelRatio:T}},t.prototype.readSliceType=function(){return this.readUByte(),this.readUEG(),this.readUEG()},t}();e.a=n},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(11),n=function(){function t(e,r,n,o){i(this,t),this.decryptdata=n,this.discardEPB=o,this.decrypter=new a.a(e,r,{removePKCS7Padding:!1})}return t.prototype.decryptBuffer=function(t,e){this.decrypter.decrypt(t,this.decryptdata.key.buffer,this.decryptdata.iv.buffer,e)},t.prototype.decryptAacSample=function(t,e,r,i){var a=t[e].unit,n=a.subarray(16,a.length-a.length%16),o=n.buffer.slice(n.byteOffset,n.byteOffset+n.length),s=this;this.decryptBuffer(o,function(n){n=new Uint8Array(n),a.set(n,16),i||s.decryptAacSamples(t,e+1,r)})},t.prototype.decryptAacSamples=function(t,e,r){for(;;e++){if(e>=t.length)return void r();if(!(t[e].unit.length<32)){var i=this.decrypter.isSync();if(this.decryptAacSample(t,e,r,i),!i)return}}},t.prototype.getAvcEncryptedData=function(t){for(var e=16*Math.floor((t.length-48)/160)+16,r=new Int8Array(e),i=0,a=32;a<=t.length-16;a+=160,i+=16)r.set(t.subarray(a,a+16),i);return r},t.prototype.getAvcDecryptedUnit=function(t,e){e=new Uint8Array(e);for(var r=0,i=32;i<=t.length-16;i+=160,r+=16)t.set(e.subarray(r,r+16),i);return t},t.prototype.decryptAvcSample=function(t,e,r,i,a,n){var o=this.discardEPB(a.data),s=this.getAvcEncryptedData(o),l=this;this.decryptBuffer(s.buffer,function(s){a.data=l.getAvcDecryptedUnit(o,s),n||l.decryptAvcSamples(t,e,r+1,i)})},t.prototype.decryptAvcSamples=function(t,e,r,i){for(;;e++,r=0){if(e>=t.length)return void i();for(var a=t[e].units;!(r>=a.length);r++){var n=a[r];if(!(n.length<=48||1!==n.type&&5!==n.type)){var o=this.decrypter.isSync();if(this.decryptAvcSample(t,e,r,i,n,o),!o)return}}}},t}();e.a=n},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(5),n=r(0),o=r(21),s=function(){function t(e,r,a){i(this,t),this.observer=e,this.config=a,this.remuxer=r}return t.prototype.resetInitSegment=function(t,e,r,i){this._audioTrack={container:"audio/mpeg",type:"audio",id:-1,sequenceNumber:0,isAAC:!1,samples:[],len:0,manifestCodec:e,duration:i,inputTimeScale:9e4}},t.prototype.resetTimeStamp=function(){},t.probe=function(t){var e=void 0,r=void 0,i=a.a.getID3Data(t,0);if(i&&void 0!==a.a.getTimeStamp(i))for(e=i.length,r=Math.min(t.length-1,e+100);e<r;e++)if(o.a.probe(t,e))return n.b.log("MPEG Audio sync word found !"),!0;return!1},t.prototype.append=function(t,e,r,i){for(var n=a.a.getID3Data(t,0),s=a.a.getTimeStamp(n),l=s?90*s:9e4*e,u=n.length,d=t.length,c=0,h=0,f=this._audioTrack,p=[{pts:l,dts:l,data:n}];u<d;)if(o.a.isHeader(t,u)){var v=o.a.appendFrame(f,t,u,l,c);if(!v)break;u+=v.length,h=v.sample.pts,c++}else a.a.isHeader(t,u)?(n=a.a.getID3Data(t,u),p.push({pts:h,dts:h,data:n}),u+=n.length):u++;this.remuxer.remux(f,{samples:[]},{samples:p,inputTimeScale:9e4},{samples:[]},e,r,i)},t.prototype.destroy=function(){},t}();e.a=s},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(43),n=r(44),o=r(1),s=r(2),l=r(0),u=function(){function t(e,r,a,n){i(this,t),this.observer=e,this.config=r,this.typeSupported=a;var o=navigator.userAgent;this.isSafari=n&&n.indexOf("Apple")>-1&&o&&!o.match("CriOS"),this.ISGenerated=!1}return t.prototype.destroy=function(){},t.prototype.resetTimeStamp=function(t){this._initPTS=this._initDTS=t},t.prototype.resetInitSegment=function(){this.ISGenerated=!1},t.prototype.remux=function(t,e,r,i,a,n,s){if(this.ISGenerated||this.generateIS(t,e,a),this.ISGenerated){var u=t.samples.length,d=e.samples.length,c=a,h=a;if(u&&d){var f=(t.samples[0].dts-e.samples[0].dts)/e.inputTimeScale;c+=Math.max(0,f),h+=Math.max(0,-f)}if(u){t.timescale||(l.b.warn("regenerate InitSegment as audio detected"),this.generateIS(t,e,a));var p=this.remuxAudio(t,c,n,s);if(d){var v=void 0;p&&(v=p.endPTS-p.startPTS),e.timescale||(l.b.warn("regenerate InitSegment as video detected"),this.generateIS(t,e,a)),this.remuxVideo(e,h,n,v,s)}}else if(d){var g=this.remuxVideo(e,h,n,0,s);g&&t.codec&&this.remuxEmptyAudio(t,c,n,g)}}r.samples.length&&this.remuxID3(r,a),i.samples.length&&this.remuxText(i,a),this.observer.trigger(o.a.FRAG_PARSED)},t.prototype.generateIS=function(t,e,r){var i=this.observer,a=t.samples,u=e.samples,d=this.typeSupported,c="audio/mp4",h={},f={tracks:h},p=void 0===this._initPTS,v=void 0,g=void 0;if(p&&(v=g=1/0),t.config&&a.length&&(t.timescale=t.samplerate,l.b.log("audio sampling rate : "+t.samplerate),t.isAAC||(d.mpeg?(c="audio/mpeg",t.codec=""):d.mp3&&(t.codec="mp3")),h.audio={container:c,codec:t.codec,initSegment:!t.isAAC&&d.mpeg?new Uint8Array:n.a.initSegment([t]),metadata:{channelCount:t.channelCount}},p&&(v=g=a[0].pts-t.inputTimeScale*r)),e.sps&&e.pps&&u.length){var y=e.inputTimeScale;e.timescale=y,h.video={container:"video/mp4",codec:e.codec,initSegment:n.a.initSegment([e]),metadata:{width:e.width,height:e.height}},p&&(v=Math.min(v,u[0].pts-y*r),g=Math.min(g,u[0].dts-y*r),this.observer.trigger(o.a.INIT_PTS_FOUND,{initPTS:v}))}Object.keys(h).length?(i.trigger(o.a.FRAG_PARSING_INIT_SEGMENT,f),this.ISGenerated=!0,p&&(this._initPTS=v,this._initDTS=g)):i.trigger(o.a.ERROR,{type:s.b.MEDIA_ERROR,details:s.a.FRAG_PARSING_ERROR,fatal:!1,reason:"no audio/video samples found"})},t.prototype.remuxVideo=function(t,e,r,i,a){var u=8,d=t.timescale,c=void 0,h=void 0,f=void 0,p=void 0,v=void 0,g=void 0,y=void 0,m=t.samples,b=[],E=m.length,T=this._PTSNormalize,S=this._initDTS,R=this.nextAvcDts,A=this.isSafari;if(0!==E){A&&(r|=m.length&&R&&(a&&Math.abs(e-R/d)<.1||Math.abs(m[0].pts-R-S)<d/5)),r||(R=e*d),m.forEach(function(t){t.pts=T(t.pts-S,R),t.dts=T(t.dts-S,R)}),m.sort(function(t,e){var r=t.dts-e.dts,i=t.pts-e.pts;return r||i||t.id-e.id});var _=m.reduce(function(t,e){return Math.max(Math.min(t,e.pts-e.dts),-18e3)},0);if(_<0){l.b.warn("PTS < DTS detected in video samples, shifting DTS by "+Math.round(_/90)+" ms to overcome this issue");for(var w=0;w<m.length;w++)m[w].dts+=_}var L=m[0];v=Math.max(L.dts,0),p=Math.max(L.pts,0);var D=Math.round((v-R)/90);r&&D&&(D>1?l.b.log("AVC:"+D+" ms hole between fragments detected,filling it"):D<-1&&l.b.log("AVC:"+-D+" ms overlapping between fragments detected"),v=R,m[0].dts=v,p=Math.max(p-D,R),m[0].pts=p,l.b.log("Video/PTS/DTS adjusted: "+Math.round(p/90)+"/"+Math.round(v/90)+",delta:"+D+" ms")),v,L=m[m.length-1],y=Math.max(L.dts,0),g=Math.max(L.pts,0,y),A&&(c=Math.round((y-v)/(m.length-1)));for(var I=0,k=0,O=0;O<E;O++){for(var C=m[O],P=C.units,x=P.length,F=0,N=0;N<x;N++)F+=P[N].data.length;k+=F,I+=x,C.length=F,C.dts=A?v+O*c:Math.max(C.dts,v),C.pts=Math.max(C.pts,C.dts)}var M=k+4*I+8;try{h=new Uint8Array(M)}catch(t){return void this.observer.trigger(o.a.ERROR,{type:s.b.MUX_ERROR,details:s.a.REMUX_ALLOC_ERROR,fatal:!1,bytes:M,reason:"fail allocating video mdat "+M})}var U=new DataView(h.buffer);U.setUint32(0,M),h.set(n.a.types.mdat,4);for(var B=0;B<E;B++){for(var G=m[B],K=G.units,j=0,H=void 0,V=0,Y=K.length;V<Y;V++){var W=K[V],q=W.data,X=W.data.byteLength;U.setUint32(u,X),u+=4,h.set(q,u),u+=X,j+=4+X}if(A)H=Math.max(0,c*Math.round((G.pts-G.dts)/c));else{if(B<E-1)c=m[B+1].dts-G.dts;else{var z=this.config,Q=G.dts-m[B>0?B-1:B].dts;if(z.stretchShortVideoTrack){var J=z.maxBufferHole,$=Math.floor(J*d),Z=(i?p+i*d:this.nextAudioPts)-G.pts;Z>$?(c=Z-Q,c<0&&(c=Q),l.b.log("It is approximately "+Z/90+" ms to the next segment; using duration "+c/90+" ms for the last video frame.")):c=Q}else c=Q}H=Math.round(G.pts-G.dts)}b.push({size:j,duration:c,cts:H,flags:{isLeading:0,isDependedOn:0,hasRedundancy:0,degradPrio:0,dependsOn:G.key?2:1,isNonSync:G.key?0:1}})}this.nextAvcDts=y+c;var tt=t.dropped;if(t.len=0,t.nbNalu=0,t.dropped=0,b.length&&navigator.userAgent.toLowerCase().indexOf("chrome")>-1){var et=b[0].flags;et.dependsOn=2,et.isNonSync=0}t.samples=b,f=n.a.moof(t.sequenceNumber++,v,t),t.samples=[];var rt={data1:f,data2:h,startPTS:p/d,endPTS:(g+c)/d,startDTS:v/d,endDTS:this.nextAvcDts/d,type:"video",hasAudio:!1,hasVideo:!0,nb:b.length,dropped:tt};return this.observer.trigger(o.a.FRAG_PARSING_DATA,rt),rt}},t.prototype.remuxAudio=function(t,e,r,i){var u=t.inputTimeScale,d=t.timescale,c=u/d,h=t.isAAC?1024:1152,f=h*c,p=this._PTSNormalize,v=this._initDTS,g=!t.isAAC&&this.typeSupported.mpeg,y=void 0,m=void 0,b=void 0,E=void 0,T=void 0,S=void 0,R=void 0,A=t.samples,_=[],w=this.nextAudioPts;if(r|=A.length&&w&&(i&&Math.abs(e-w/u)<.1||Math.abs(A[0].pts-w-v)<20*f),A.forEach(function(t){t.pts=t.dts=p(t.pts-v,e*u)}),A=A.filter(function(t){return t.pts>=0}),0!==A.length){if(r||(w=i?e*u:A[0].pts),t.isAAC)for(var L=this.config.maxAudioFramesDrift,D=0,I=w;D<A.length;){var k,O=A[D],C=O.pts;k=C-I;var P=Math.abs(1e3*k/u);if(k<=-L*f)l.b.warn("Dropping 1 audio frame @ "+(I/u).toFixed(3)+"s due to "+Math.round(P)+" ms overlap."),A.splice(D,1),t.len-=O.unit.length;else if(k>=L*f&&P<1e4&&I){var x=Math.round(k/f);l.b.warn("Injecting "+x+" audio frame @ "+(I/u).toFixed(3)+"s due to "+Math.round(1e3*k/u)+" ms gap.");for(var F=0;F<x;F++){var N=Math.max(I,0);b=a.a.getSilentFrame(t.manifestCodec||t.codec,t.channelCount),b||(l.b.log("Unable to get silent frame for given audio codec; duplicating last frame instead."),b=O.unit.subarray()),A.splice(D,0,{unit:b,pts:N,dts:N}),t.len+=b.length,I+=f,D++}O.pts=O.dts=I,I+=f,D++}else Math.abs(k),O.pts=O.dts=I,I+=f,D++}for(var M=0,U=A.length;M<U;M++){var B=A[M],G=B.unit,K=B.pts;if(void 0!==R)m.duration=Math.round((K-R)/c);else{var j=Math.round(1e3*(K-w)/u),H=0;if(r&&t.isAAC&&j){if(j>0&&j<1e4)H=Math.round((K-w)/f),l.b.log(j+" ms hole between AAC samples detected,filling it"),H>0&&(b=a.a.getSilentFrame(t.manifestCodec||t.codec,t.channelCount),b||(b=G.subarray()),t.len+=H*b.length);else if(j<-12){l.b.log("drop overlapping AAC sample, expected/parsed/delta:"+(w/u).toFixed(3)+"s/"+(K/u).toFixed(3)+"s/"+-j+"ms"),t.len-=G.byteLength;continue}K=w}if(S=K,!(t.len>0))return;var V=g?t.len:t.len+8;y=g?0:8;try{E=new Uint8Array(V)}catch(t){return void this.observer.trigger(o.a.ERROR,{type:s.b.MUX_ERROR,details:s.a.REMUX_ALLOC_ERROR,fatal:!1,bytes:V,reason:"fail allocating audio mdat "+V})}if(!g){new DataView(E.buffer).setUint32(0,V),E.set(n.a.types.mdat,4)}for(var Y=0;Y<H;Y++)b=a.a.getSilentFrame(t.manifestCodec||t.codec,t.channelCount),b||(l.b.log("Unable to get silent frame for given audio codec; duplicating this frame instead."),b=G.subarray()),E.set(b,y),y+=b.byteLength,m={size:b.byteLength,cts:0,duration:1024,flags:{isLeading:0,isDependedOn:0,hasRedundancy:0,degradPrio:0,dependsOn:1}},_.push(m)}E.set(G,y);var W=G.byteLength;y+=W,m={size:W,cts:0,duration:0,flags:{isLeading:0,isDependedOn:0,hasRedundancy:0,degradPrio:0,dependsOn:1}},_.push(m),R=K}var q=0,X=_.length;if(X>=2&&(q=_[X-2].duration,m.duration=q),X){this.nextAudioPts=w=R+c*q,t.len=0,t.samples=_,T=g?new Uint8Array:n.a.moof(t.sequenceNumber++,S/c,t),t.samples=[];var z=S/u,Q=w/u,J={data1:T,data2:E,startPTS:z,endPTS:Q,startDTS:z,endDTS:Q,type:"audio",hasAudio:!0,hasVideo:!1,nb:X};return this.observer.trigger(o.a.FRAG_PARSING_DATA,J),J}return null}},t.prototype.remuxEmptyAudio=function(t,e,r,i){var n=t.inputTimeScale,o=t.samplerate?t.samplerate:n,s=n/o,u=this.nextAudioPts,d=(void 0!==u?u:i.startDTS*n)+this._initDTS,c=i.endDTS*n+this._initDTS,h=1024*s,f=Math.ceil((c-d)/h),p=a.a.getSilentFrame(t.manifestCodec||t.codec,t.channelCount);if(l.b.warn("remux empty Audio"),!p)return void l.b.trace("Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!");for(var v=[],g=0;g<f;g++){var y=d+g*h;v.push({unit:p,pts:y,dts:y}),t.len+=p.length}t.samples=v,this.remuxAudio(t,e,r)},t.prototype.remuxID3=function(t,e){var r=t.samples.length,i=void 0,a=t.inputTimeScale,n=this._initPTS,s=this._initDTS;if(r){for(var l=0;l<r;l++)i=t.samples[l],i.pts=(i.pts-n)/a,i.dts=(i.dts-s)/a;this.observer.trigger(o.a.FRAG_PARSING_METADATA,{samples:t.samples})}t.samples=[],e=e},t.prototype.remuxText=function(t,e){t.samples.sort(function(t,e){return t.pts-e.pts});var r=t.samples.length,i=void 0,a=t.inputTimeScale,n=this._initPTS;if(r){for(var s=0;s<r;s++)i=t.samples[s],i.pts=(i.pts-n)/a;this.observer.trigger(o.a.FRAG_PARSING_USERDATA,{samples:t.samples})}t.samples=[],e=e},t.prototype._PTSNormalize=function(t,e){var r=void 0;if(void 0===e)return t;for(r=e<t?-8589934592:8589934592;Math.abs(t-e)>4294967296;)t+=r;return t},t}();e.a=u},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=function(){function t(){i(this,t)}return t.getSilentFrame=function(t,e){switch(t){case"mp4a.40.2":if(1===e)return new Uint8Array([0,200,0,128,35,128]);if(2===e)return new Uint8Array([33,0,73,144,2,25,0,35,128]);if(3===e)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,142]);if(4===e)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,128,44,128,8,2,56]);if(5===e)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,56]);if(6===e)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,0,178,0,32,8,224]);break;default:if(1===e)return new Uint8Array([1,64,34,128,163,78,230,128,186,8,0,0,0,28,6,241,193,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94]);if(2===e)return new Uint8Array([1,64,34,128,163,94,230,128,186,8,0,0,0,0,149,0,6,241,161,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94]);if(3===e)return new Uint8Array([1,64,34,128,163,94,230,128,186,8,0,0,0,0,149,0,6,241,161,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94])}return null},t}();e.a=a},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=Math.pow(2,32)-1,n=function(){function t(){i(this,t)}return t.init=function(){t.types={avc1:[],avcC:[],btrt:[],dinf:[],dref:[],esds:[],ftyp:[],hdlr:[],mdat:[],mdhd:[],mdia:[],mfhd:[],minf:[],moof:[],moov:[],mp4a:[],".mp3":[],mvex:[],mvhd:[],pasp:[],sdtp:[],stbl:[],stco:[],stsc:[],stsd:[],stsz:[],stts:[],tfdt:[],tfhd:[],traf:[],trak:[],trun:[],trex:[],tkhd:[],vmhd:[],smhd:[]};var e=void 0;for(e in t.types)t.types.hasOwnProperty(e)&&(t.types[e]=[e.charCodeAt(0),e.charCodeAt(1),e.charCodeAt(2),e.charCodeAt(3)]);var r=new Uint8Array([0,0,0,0,0,0,0,0,118,105,100,101,0,0,0,0,0,0,0,0,0,0,0,0,86,105,100,101,111,72,97,110,100,108,101,114,0]),i=new Uint8Array([0,0,0,0,0,0,0,0,115,111,117,110,0,0,0,0,0,0,0,0,0,0,0,0,83,111,117,110,100,72,97,110,100,108,101,114,0]);t.HDLR_TYPES={video:r,audio:i};var a=new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,12,117,114,108,32,0,0,0,1]),n=new Uint8Array([0,0,0,0,0,0,0,0]);t.STTS=t.STSC=t.STCO=n,t.STSZ=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0]),t.VMHD=new Uint8Array([0,0,0,1,0,0,0,0,0,0,0,0]),t.SMHD=new Uint8Array([0,0,0,0,0,0,0,0]),t.STSD=new Uint8Array([0,0,0,0,0,0,0,1]);var o=new Uint8Array([105,115,111,109]),s=new Uint8Array([97,118,99,49]),l=new Uint8Array([0,0,0,1]);t.FTYP=t.box(t.types.ftyp,o,l,o,s),t.DINF=t.box(t.types.dinf,t.box(t.types.dref,a))},t.box=function(t){for(var e=Array.prototype.slice.call(arguments,1),r=8,i=e.length,a=i,n=void 0;i--;)r+=e[i].byteLength;for(n=new Uint8Array(r),n[0]=r>>24&255,n[1]=r>>16&255,n[2]=r>>8&255,n[3]=255&r,n.set(t,4),i=0,r=8;i<a;i++)n.set(e[i],r),r+=e[i].byteLength;return n},t.hdlr=function(e){return t.box(t.types.hdlr,t.HDLR_TYPES[e])},t.mdat=function(e){return t.box(t.types.mdat,e)},t.mdhd=function(e,r){r*=e;var i=Math.floor(r/(a+1)),n=Math.floor(r%(a+1));return t.box(t.types.mdhd,new Uint8Array([1,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,e>>24&255,e>>16&255,e>>8&255,255&e,i>>24,i>>16&255,i>>8&255,255&i,n>>24,n>>16&255,n>>8&255,255&n,85,196,0,0]))},t.mdia=function(e){return t.box(t.types.mdia,t.mdhd(e.timescale,e.duration),t.hdlr(e.type),t.minf(e))},t.mfhd=function(e){return t.box(t.types.mfhd,new Uint8Array([0,0,0,0,e>>24,e>>16&255,e>>8&255,255&e]))},t.minf=function(e){return"audio"===e.type?t.box(t.types.minf,t.box(t.types.smhd,t.SMHD),t.DINF,t.stbl(e)):t.box(t.types.minf,t.box(t.types.vmhd,t.VMHD),t.DINF,t.stbl(e))},t.moof=function(e,r,i){return t.box(t.types.moof,t.mfhd(e),t.traf(i,r))},t.moov=function(e){for(var r=e.length,i=[];r--;)i[r]=t.trak(e[r]);return t.box.apply(null,[t.types.moov,t.mvhd(e[0].timescale,e[0].duration)].concat(i).concat(t.mvex(e)))},t.mvex=function(e){for(var r=e.length,i=[];r--;)i[r]=t.trex(e[r]);return t.box.apply(null,[t.types.mvex].concat(i))},t.mvhd=function(e,r){r*=e;var i=Math.floor(r/(a+1)),n=Math.floor(r%(a+1)),o=new Uint8Array([1,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,e>>24&255,e>>16&255,e>>8&255,255&e,i>>24,i>>16&255,i>>8&255,255&i,n>>24,n>>16&255,n>>8&255,255&n,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255]);return t.box(t.types.mvhd,o)},t.sdtp=function(e){var r=e.samples||[],i=new Uint8Array(4+r.length),a=void 0,n=void 0;for(n=0;n<r.length;n++)a=r[n].flags,i[n+4]=a.dependsOn<<4|a.isDependedOn<<2|a.hasRedundancy;return t.box(t.types.sdtp,i)},t.stbl=function(e){return t.box(t.types.stbl,t.stsd(e),t.box(t.types.stts,t.STTS),t.box(t.types.stsc,t.STSC),t.box(t.types.stsz,t.STSZ),t.box(t.types.stco,t.STCO))},t.avc1=function(e){var r=[],i=[],a=void 0,n=void 0,o=void 0;for(a=0;a<e.sps.length;a++)n=e.sps[a],o=n.byteLength,r.push(o>>>8&255),r.push(255&o),r=r.concat(Array.prototype.slice.call(n));for(a=0;a<e.pps.length;a++)n=e.pps[a],o=n.byteLength,i.push(o>>>8&255),i.push(255&o),i=i.concat(Array.prototype.slice.call(n));var s=t.box(t.types.avcC,new Uint8Array([1,r[3],r[4],r[5],255,224|e.sps.length].concat(r).concat([e.pps.length]).concat(i))),l=e.width,u=e.height,d=e.pixelRatio[0],c=e.pixelRatio[1];return t.box(t.types.avc1,new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,l>>8&255,255&l,u>>8&255,255&u,0,72,0,0,0,72,0,0,0,0,0,0,0,1,18,100,97,105,108,121,109,111,116,105,111,110,47,104,108,115,46,106,115,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,17,17]),s,t.box(t.types.btrt,new Uint8Array([0,28,156,128,0,45,198,192,0,45,198,192])),t.box(t.types.pasp,new Uint8Array([d>>24,d>>16&255,d>>8&255,255&d,c>>24,c>>16&255,c>>8&255,255&c])))},t.esds=function(t){var e=t.config.length;return new Uint8Array([0,0,0,0,3,23+e,0,1,0,4,15+e,64,21,0,0,0,0,0,0,0,0,0,0,0,5].concat([e]).concat(t.config).concat([6,1,2]))},t.mp4a=function(e){var r=e.samplerate;return t.box(t.types.mp4a,new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,e.channelCount,0,16,0,0,0,0,r>>8&255,255&r,0,0]),t.box(t.types.esds,t.esds(e)))},t.mp3=function(e){var r=e.samplerate;return t.box(t.types[".mp3"],new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,e.channelCount,0,16,0,0,0,0,r>>8&255,255&r,0,0]))},t.stsd=function(e){return"audio"===e.type?e.isAAC||"mp3"!==e.codec?t.box(t.types.stsd,t.STSD,t.mp4a(e)):t.box(t.types.stsd,t.STSD,t.mp3(e)):t.box(t.types.stsd,t.STSD,t.avc1(e))},t.tkhd=function(e){var r=e.id,i=e.duration*e.timescale,n=e.width,o=e.height,s=Math.floor(i/(a+1)),l=Math.floor(i%(a+1));return t.box(t.types.tkhd,new Uint8Array([1,0,0,7,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,r>>24&255,r>>16&255,r>>8&255,255&r,0,0,0,0,s>>24,s>>16&255,s>>8&255,255&s,l>>24,l>>16&255,l>>8&255,255&l,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,n>>8&255,255&n,0,0,o>>8&255,255&o,0,0]))},t.traf=function(e,r){var i=t.sdtp(e),n=e.id,o=Math.floor(r/(a+1)),s=Math.floor(r%(a+1));return t.box(t.types.traf,t.box(t.types.tfhd,new Uint8Array([0,0,0,0,n>>24,n>>16&255,n>>8&255,255&n])),t.box(t.types.tfdt,new Uint8Array([1,0,0,0,o>>24,o>>16&255,o>>8&255,255&o,s>>24,s>>16&255,s>>8&255,255&s])),t.trun(e,i.length+16+20+8+16+8+8),i)},t.trak=function(e){return e.duration=e.duration||4294967295,t.box(t.types.trak,t.tkhd(e),t.mdia(e))},t.trex=function(e){var r=e.id;return t.box(t.types.trex,new Uint8Array([0,0,0,0,r>>24,r>>16&255,r>>8&255,255&r,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1]))},t.trun=function(e,r){var i=e.samples||[],a=i.length,n=12+16*a,o=new Uint8Array(n),s=void 0,l=void 0,u=void 0,d=void 0,c=void 0,h=void 0;for(r+=8+n,o.set([0,0,15,1,a>>>24&255,a>>>16&255,a>>>8&255,255&a,r>>>24&255,r>>>16&255,r>>>8&255,255&r],0),s=0;s<a;s++)l=i[s],u=l.duration,d=l.size,c=l.flags,h=l.cts,o.set([u>>>24&255,u>>>16&255,u>>>8&255,255&u,d>>>24&255,d>>>16&255,d>>>8&255,255&d,c.isLeading<<2|c.dependsOn,c.isDependedOn<<6|c.hasRedundancy<<4|c.paddingValue<<1|c.isNonSync,61440&c.degradPrio,15&c.degradPrio,h>>>24&255,h>>>16&255,h>>>8&255,255&h],12+16*s);return t.box(t.types.trun,o)},t.initSegment=function(e){t.types||t.init();var r=t.moov(e),i=void 0;return i=new Uint8Array(t.FTYP.byteLength+r.byteLength),i.set(t.FTYP),i.set(r,t.FTYP.byteLength),i},t}();e.a=n},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(1),n=function(){function t(e){i(this,t),this.observer=e}return t.prototype.destroy=function(){},t.prototype.resetTimeStamp=function(){},t.prototype.resetInitSegment=function(){},t.prototype.remux=function(t,e,r,i,n,o,s,l){var u=this.observer,d="";t&&(d+="audio"),e&&(d+="video"),u.trigger(a.a.FRAG_PARSING_DATA,{data1:l,startPTS:n,startDTS:n,type:d,hasAudio:!!t,hasVideo:!!e,nb:1,dropped:0}),u.trigger(a.a.FRAG_PARSED)},t}();e.a=n},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=r(19),a=r(1),n=r(0),o=r(10),s=r.n(o),l=function(t){var e=new s.a;e.trigger=function(t){for(var r=arguments.length,i=Array(r>1?r-1:0),a=1;a<r;a++)i[a-1]=arguments[a];e.emit.apply(e,[t,t].concat(i))},e.off=function(t){for(var r=arguments.length,i=Array(r>1?r-1:0),a=1;a<r;a++)i[a-1]=arguments[a];e.removeListener.apply(e,[t].concat(i))};var r=function(e,r){t.postMessage({event:e,data:r})};t.addEventListener("message",function(a){var o=a.data;switch(o.cmd){case"init":var s=JSON.parse(o.config);t.demuxer=new i.a(e,o.typeSupported,s,o.vendor);try{Object(n.a)(!0===s.debug)}catch(t){console.warn("demuxerWorker: unable to enable logs")}r("init",null);break;case"demux":t.demuxer.push(o.data,o.decryptdata,o.initSegment,o.audioCodec,o.videoCodec,o.timeOffset,o.discontinuity,o.trackSwitch,o.contiguous,o.duration,o.accurateTimeOffset,o.defaultInitPTS)}}),e.on(a.a.FRAG_DECRYPTED,r),e.on(a.a.FRAG_PARSING_INIT_SEGMENT,r),e.on(a.a.FRAG_PARSED,r),e.on(a.a.ERROR,r),e.on(a.a.FRAG_PARSING_METADATA,r),e.on(a.a.FRAG_PARSING_USERDATA,r),e.on(a.a.INIT_PTS_FOUND,r),e.on(a.a.FRAG_PARSING_DATA,function(e,r){var i=[],a={event:e,data:r};r.data1&&(a.data1=r.data1.buffer,i.push(r.data1.buffer),delete r.data1),r.data2&&(a.data2=r.data2.buffer,i.push(r.data2.buffer),delete r.data2),t.postMessage(a,i)})};e.default=l},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(1),s=r(3),l=r(0),u=r(2),d=r(17),c=function(){function t(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,r,i){return r&&t(e.prototype,r),i&&t(e,i),e}}(),h=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,o.a.MANIFEST_LOADED,o.a.LEVEL_LOADED,o.a.FRAG_LOADED,o.a.ERROR));return n.canload=!1,n.currentLevelIndex=null,n.manualLevelIndex=-1,n.timer=null,n}return n(e,t),e.prototype.onHandlerDestroying=function(){this.cleanTimer(),this.manualLevelIndex=-1},e.prototype.cleanTimer=function(){null!==this.timer&&(clearTimeout(this.timer),this.timer=null)},e.prototype.startLoad=function(){var t=this._levels;this.canload=!0,this.levelRetryCount=0,t&&t.forEach(function(t){t.loadError=0;var e=t.details;e&&e.live&&(t.details=void 0)}),null!==this.timer&&this.loadLevel()},e.prototype.stopLoad=function(){this.canload=!1},e.prototype.onManifestLoaded=function(t){var e=[],r=void 0,i={},a=null,n=!1,s=!1,c=/chrome|firefox/.test(navigator.userAgent.toLowerCase()),h=[];if(t.levels.forEach(function(t){t.loadError=0,t.fragmentError=!1,n=n||!!t.videoCodec,s=s||!!t.audioCodec||!(!t.attrs||!t.attrs.AUDIO),!0===c&&t.audioCodec&&-1!==t.audioCodec.indexOf("mp4a.40.34")&&(t.audioCodec=void 0),a=i[t.bitrate],void 0===a?(t.url=[t.url],t.urlId=0,i[t.bitrate]=t,e.push(t)):a.url.push(t.url)}),!0===n&&!0===s&&(e=e.filter(function(t){return!!t.videoCodec})),e=e.filter(function(t){var e=t.audioCodec,r=t.videoCodec;return(!e||Object(d.a)(e))&&(!r||Object(d.a)(r))}),t.audioTracks&&(h=t.audioTracks.filter(function(t){return!t.audioCodec||Object(d.a)(t.audioCodec,"audio")})),e.length>0){r=e[0].bitrate,e.sort(function(t,e){return t.bitrate-e.bitrate}),this._levels=e;for(var f=0;f<e.length;f++)if(e[f].bitrate===r){this._firstLevel=f,l.b.log("manifest loaded,"+e.length+" level(s) found, first bitrate:"+r);break}this.hls.trigger(o.a.MANIFEST_PARSED,{levels:e,audioTracks:h,firstLevel:this._firstLevel,stats:t.stats,audio:s,video:n,altAudio:h.length>0&&n})}else this.hls.trigger(o.a.ERROR,{type:u.b.MEDIA_ERROR,details:u.a.MANIFEST_INCOMPATIBLE_CODECS_ERROR,fatal:!0,url:this.hls.url,reason:"no level with compatible codecs found in manifest"})},e.prototype.setLevelInternal=function(t){var e=this._levels,r=this.hls;if(t>=0&&t<e.length){if(this.cleanTimer(),this.currentLevelIndex!==t){l.b.log("switching to level "+t),this.currentLevelIndex=t;var i=e[t];i.level=t,r.trigger(o.a.LEVEL_SWITCHING,i)}var a=e[t],n=a.details;if(!n||!0===n.live){var s=a.urlId;r.trigger(o.a.LEVEL_LOADING,{url:a.url[s],level:t,id:s})}}else r.trigger(o.a.ERROR,{type:u.b.OTHER_ERROR,details:u.a.LEVEL_SWITCH_ERROR,level:t,fatal:!1,reason:"invalid level idx"})},e.prototype.onError=function(t){if(!0===t.fatal)return void(t.type===u.b.NETWORK_ERROR&&this.cleanTimer());var e=!1,r=!1,i=void 0;switch(t.details){case u.a.FRAG_LOAD_ERROR:case u.a.FRAG_LOAD_TIMEOUT:case u.a.KEY_LOAD_ERROR:case u.a.KEY_LOAD_TIMEOUT:i=t.frag.level,r=!0;break;case u.a.LEVEL_LOAD_ERROR:case u.a.LEVEL_LOAD_TIMEOUT:i=t.context.level,e=!0;break;case u.a.REMUX_ALLOC_ERROR:i=t.level,e=!0}void 0!==i&&this.recoverLevel(t,i,e,r)},e.prototype.recoverLevel=function(t,e,r,i){var a=this,n=this.hls.config,o=t.details,s=this._levels[e],u=void 0,d=void 0,c=void 0;if(s.loadError++,s.fragmentError=i,!0===r){if(!(this.levelRetryCount+1<=n.levelLoadingMaxRetry))return l.b.error("level controller, cannot recover from "+o+" error"),this.currentLevelIndex=null,this.cleanTimer(),void(t.fatal=!0);d=Math.min(Math.pow(2,this.levelRetryCount)*n.levelLoadingRetryDelay,n.levelLoadingMaxRetryTimeout),this.timer=setTimeout(function(){return a.loadLevel()},d),t.levelRetry=!0,this.levelRetryCount++,l.b.warn("level controller, "+o+", retry in "+d+" ms, current retry count is "+this.levelRetryCount)}!0!==r&&!0!==i||(u=s.url.length,u>1&&s.loadError<u?(l.b.warn("level controller, "+o+" for level "+e+": switching to redundant stream id "+s.urlId),s.urlId=(s.urlId+1)%u,s.details=void 0):-1===this.manualLevelIndex?(c=0===e?this._levels.length-1:e-1,l.b.warn("level controller, "+o+": switch to "+c),this.hls.nextAutoLevel=this.currentLevelIndex=c):!0===i&&(l.b.warn("level controller, "+o+": reload a fragment"),this.currentLevelIndex=null))},e.prototype.onFragLoaded=function(t){var e=t.frag;if(void 0!==e&&"main"===e.type){var r=this._levels[e.level];void 0!==r&&(r.fragmentError=!1,r.loadError=0,this.levelRetryCount=0)}},e.prototype.onLevelLoaded=function(t){var e=this,r=t.level;if(r===this.currentLevelIndex){var i=this._levels[r];!1===i.fragmentError&&(i.loadError=0,this.levelRetryCount=0);var a=t.details;if(a.live){var n=1e3*(a.averagetargetduration?a.averagetargetduration:a.targetduration),o=n,s=i.details;s&&a.endSN===s.endSN&&(o/=2,l.b.log("same live playlist, reload twice faster")),o-=performance.now()-t.stats.trequest,o=Math.max(n/2,Math.round(o)),l.b.log("live playlist, reload in "+Math.round(o)+" ms"),this.timer=setTimeout(function(){return e.loadLevel()},o)}else this.cleanTimer()}},e.prototype.loadLevel=function(){var t=void 0,e=void 0;null!==this.currentLevelIndex&&!0===this.canload&&void 0!==(t=this._levels[this.currentLevelIndex])&&t.url.length>0&&(e=t.urlId,this.hls.trigger(o.a.LEVEL_LOADING,{url:t.url[e],level:this.currentLevelIndex,id:e}))},c(e,[{key:"levels",get:function(){return this._levels}},{key:"level",get:function(){return this.currentLevelIndex},set:function(t){var e=this._levels;e&&(t=Math.min(t,e.length-1),this.currentLevelIndex===t&&void 0!==e[t].details||this.setLevelInternal(t))}},{key:"manualLevel",get:function(){return this.manualLevelIndex},set:function(t){this.manualLevelIndex=t,void 0===this._startLevel&&(this._startLevel=t),-1!==t&&(this.level=t)}},{key:"firstLevel",get:function(){return this._firstLevel},set:function(t){this._firstLevel=t}},{key:"startLevel",get:function(){if(void 0===this._startLevel){var t=this.hls.config.startLevel;return void 0!==t?t:this._firstLevel}return this._startLevel},set:function(t){this._startLevel=t}},{key:"nextLoadLevel",get:function(){return-1!==this.manualLevelIndex?this.manualLevelIndex:this.hls.nextAutoLevel},set:function(t){this.level=t,-1===this.manualLevelIndex&&(this.hls.nextAutoLevel=t)}}]),e}(s.a);e.a=h},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(1),s=r(3),l=r(5),u=r(25),d=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,o.a.MEDIA_ATTACHED,o.a.MEDIA_DETACHING,o.a.FRAG_PARSING_METADATA));return n.id3Track=void 0,n.media=void 0,n}return n(e,t),e.prototype.destroy=function(){s.a.prototype.destroy.call(this)},e.prototype.onMediaAttached=function(t){this.media=t.media,this.media},e.prototype.onMediaDetaching=function(){Object(u.a)(this.id3Track),this.id3Track=void 0,this.media=void 0},e.prototype.getID3Track=function(t){for(var e=0;e<t.length;e++){var r=t[e];if("metadata"===r.kind&&"id3"===r.label)return Object(u.b)(r,this.media),r}return this.media.addTextTrack("metadata","id3")},e.prototype.onFragParsingMetadata=function(t){var e=t.frag,r=t.samples;this.id3Track||(this.id3Track=this.getID3Track(this.media.textTracks),this.id3Track.mode="hidden");for(var i=window.WebKitDataCue||window.VTTCue||window.TextTrackCue,a=0;a<r.length;a++){var n=l.a.getID3Frames(r[a].data);if(n){var o=r[a].pts,s=a<r.length-1?r[a+1].pts:e.endPTS;o===s&&(s+=1e-4);for(var u=0;u<n.length;u++){var d=n[u];if(!l.a.isTimeStampFrame(d)){var c=new i(o,s,"");c.value=d,this.id3Track.addCue(c)}}}}},e}(s.a);e.a=d},function(t,e,r){"use strict";function i(){var t=Object(a.a)(),e=window.SourceBuffer||window.WebKitSourceBuffer,r=t&&"function"==typeof t.isTypeSupported&&t.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),i=!e||e.prototype&&"function"==typeof e.prototype.appendBuffer&&"function"==typeof e.prototype.remove;return!!r&&!!i}e.a=i;var a=r(12)},function(t,e,r){"use strict";r.d(e,"a",function(){return g});var i=r(51),a=r(54),n=r(55),o=r(56),s=r(57),l=r(58),u=r(59),d=r(60),c=r(62),h=r(66),f=r(67),p=r(68),v=r(69),g={autoStartLoad:!0,startPosition:-1,defaultAudioCodec:void 0,debug:!1,capLevelOnFPSDrop:!1,capLevelToPlayerSize:!1,initialLiveManifestSize:1,maxBufferLength:30,maxBufferSize:6e7,maxBufferHole:.5,lowBufferWatchdogPeriod:.5,highBufferWatchdogPeriod:3,nudgeOffset:.1,nudgeMaxRetry:3,maxFragLookUpTolerance:.25,liveSyncDurationCount:3,liveMaxLatencyDurationCount:1/0,liveSyncDuration:void 0,liveMaxLatencyDuration:void 0,liveDurationInfinity:!1,maxMaxBufferLength:600,enableWorker:!0,enableSoftwareAES:!0,manifestLoadingTimeOut:1e4,manifestLoadingMaxRetry:1,manifestLoadingRetryDelay:1e3,manifestLoadingMaxRetryTimeout:64e3,startLevel:void 0,levelLoadingTimeOut:1e4,levelLoadingMaxRetry:4,levelLoadingRetryDelay:1e3,levelLoadingMaxRetryTimeout:64e3,fragLoadingTimeOut:2e4,fragLoadingMaxRetry:6,fragLoadingRetryDelay:1e3,fragLoadingMaxRetryTimeout:64e3,startFragPrefetch:!1,fpsDroppedMonitoringPeriod:5e3,fpsDroppedMonitoringThreshold:.2,appendErrorMaxRetry:3,loader:s.a,fLoader:void 0,pLoader:void 0,xhrSetup:void 0,licenseXhrSetup:void 0,abrController:i.a,bufferController:a.a,capLevelController:n.a,fpsController:o.a,stretchShortVideoTrack:!1,maxAudioFramesDrift:1,forceKeyFrameOnDiscontinuity:!0,abrEwmaFastLive:3,abrEwmaSlowLive:9,abrEwmaFastVoD:3,abrEwmaSlowVoD:9,abrEwmaDefaultEstimate:5e5,abrBandWidthFactor:.95,abrBandWidthUpFactor:.7,abrMaxWithRealBitrate:!1,maxStarvationDelay:4,maxLoadingDelay:4,minAutoBitrate:0,emeEnabled:!1,widevineLicenseUrl:void 0,requestMediaKeySystemAccessFunc:v.a};g.subtitleStreamController=f.a,g.subtitleTrackController=h.a,g.timelineController=c.a,g.cueHandler=d,g.enableCEA708Captions=!0,g.enableWebVTT=!0,g.captionsTextTrack1Label="English",g.captionsTextTrack1LanguageCode="en",g.captionsTextTrack2Label="Spanish",g.captionsTextTrack2LanguageCode="es",g.audioStreamController=u.a,g.audioTrackController=l.a,g.emeController=p.a},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(1),s=r(3),l=r(9),u=r(2),d=r(0),c=r(52),h=function(){function t(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,r,i){return r&&t(e.prototype,r),i&&t(e,i),e}}(),f=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,o.a.FRAG_LOADING,o.a.FRAG_LOADED,o.a.FRAG_BUFFERED,o.a.ERROR));return n.lastLoadedFragLevel=0,n._nextAutoLevel=-1,n.hls=r,n.timer=null,n._bwEstimator=null,n.onCheck=n._abandonRulesCheck.bind(n),n}return n(e,t),e.prototype.destroy=function(){this.clearTimer(),s.a.prototype.destroy.call(this)},e.prototype.onFragLoading=function(t){var e=t.frag;if("main"===e.type){if(this.timer||(this.timer=setInterval(this.onCheck,100)),!this._bwEstimator){var r=this.hls,i=t.frag.level,a=r.levels[i].details.live,n=r.config,o=void 0,s=void 0;a?(o=n.abrEwmaFastLive,s=n.abrEwmaSlowLive):(o=n.abrEwmaFastVoD,s=n.abrEwmaSlowVoD),this._bwEstimator=new c.a(r,s,o,n.abrEwmaDefaultEstimate)}this.fragCurrent=e}},e.prototype._abandonRulesCheck=function(){var t=this.hls,e=t.media,r=this.fragCurrent,i=r.loader,a=t.minAutoLevel;if(!i||i.stats&&i.stats.aborted)return d.b.warn("frag loader destroy or aborted, disarm abandonRules"),this.clearTimer(),void(this._nextAutoLevel=-1);var n=i.stats;if(e&&n&&(!e.paused&&0!==e.playbackRate||!e.readyState)&&r.autoLevel&&r.level){var s=performance.now()-n.trequest,u=Math.abs(e.playbackRate);if(s>500*r.duration/u){var c=t.levels,h=Math.max(1,n.bw?n.bw/8:1e3*n.loaded/s),f=c[r.level],p=f.realBitrate?Math.max(f.realBitrate,f.bitrate):f.bitrate,v=n.total?n.total:Math.max(n.loaded,Math.round(r.duration*p/8)),g=e.currentTime,y=(v-n.loaded)/h,m=(l.a.bufferInfo(e,g,t.config.maxBufferHole).end-g)/u;if(m<2*r.duration/u&&y>m){var b=void 0,E=void 0;for(E=r.level-1;E>a;E--){var T=c[E].realBitrate?Math.max(c[E].realBitrate,c[E].bitrate):c[E].bitrate;if((b=r.duration*T/(6.4*h))<m)break}b<y&&(d.b.warn("loading too slow, abort fragment loading and switch to level "+E+":fragLoadedDelay["+E+"]<fragLoadedDelay["+(r.level-1)+"];bufferStarvationDelay:"+b.toFixed(1)+"<"+y.toFixed(1)+":"+m.toFixed(1)),t.nextLoadLevel=E,this._bwEstimator.sample(s,n.loaded),i.abort(),this.clearTimer(),t.trigger(o.a.FRAG_LOAD_EMERGENCY_ABORTED,{frag:r,stats:n}))}}}},e.prototype.onFragLoaded=function(t){var e=t.frag;if("main"===e.type&&!isNaN(e.sn)){if(this.clearTimer(),this.lastLoadedFragLevel=e.level,this._nextAutoLevel=-1,this.hls.config.abrMaxWithRealBitrate){var r=this.hls.levels[e.level],i=(r.loaded?r.loaded.bytes:0)+t.stats.loaded,a=(r.loaded?r.loaded.duration:0)+t.frag.duration;r.loaded={bytes:i,duration:a},r.realBitrate=Math.round(8*i/a)}if(t.frag.bitrateTest){var n=t.stats;n.tparsed=n.tbuffered=n.tload,this.onFragBuffered(t)}}},e.prototype.onFragBuffered=function(t){var e=t.stats,r=t.frag;if(!(!0===e.aborted||"main"!==r.type||isNaN(r.sn)||r.bitrateTest&&e.tload!==e.tbuffered)){var i=e.tparsed-e.trequest;d.b.log("latency/loading/parsing/append/kbps:"+Math.round(e.tfirst-e.trequest)+"/"+Math.round(e.tload-e.tfirst)+"/"+Math.round(e.tparsed-e.tload)+"/"+Math.round(e.tbuffered-e.tparsed)+"/"+Math.round(8*e.loaded/(e.tbuffered-e.trequest))),this._bwEstimator.sample(i,e.loaded),e.bwEstimate=this._bwEstimator.getEstimate(),r.bitrateTest?this.bitrateTestDelay=i/1e3:this.bitrateTestDelay=0}},e.prototype.onError=function(t){switch(t.details){case u.a.FRAG_LOAD_ERROR:case u.a.FRAG_LOAD_TIMEOUT:this.clearTimer()}},e.prototype.clearTimer=function(){clearInterval(this.timer),this.timer=null},e.prototype._findBestLevel=function(t,e,r,i,a,n,o,s,l){for(var u=a;u>=i;u--){var c=l[u],h=c.details,f=h?h.totalduration/h.fragments.length:e,p=!!h&&h.live,v=void 0;v=u<=t?o*r:s*r;var g=l[u].realBitrate?Math.max(l[u].realBitrate,l[u].bitrate):l[u].bitrate,y=g*f/v;if(d.b.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: "+u+"/"+Math.round(v)+"/"+g+"/"+f+"/"+n+"/"+y),v>g&&(!y||p&&!this.bitrateTestDelay||y<n))return u}return-1},h(e,[{key:"nextAutoLevel",get:function(){var t=this._nextAutoLevel,e=this._bwEstimator;if(!(-1===t||e&&e.canEstimate()))return t;var r=this._nextABRAutoLevel;return-1!==t&&(r=Math.min(t,r)),r},set:function(t){this._nextAutoLevel=t}},{key:"_nextABRAutoLevel",get:function(){var t=this.hls,e=t.maxAutoLevel,r=t.levels,i=t.config,a=t.minAutoLevel,n=t.media,o=this.lastLoadedFragLevel,s=this.fragCurrent?this.fragCurrent.duration:0,u=n?n.currentTime:0,c=n&&0!==n.playbackRate?Math.abs(n.playbackRate):1,h=this._bwEstimator?this._bwEstimator.getEstimate():i.abrEwmaDefaultEstimate,f=(l.a.bufferInfo(n,u,i.maxBufferHole).end-u)/c,p=this._findBestLevel(o,s,h,a,e,f,i.abrBandWidthFactor,i.abrBandWidthUpFactor,r);if(p>=0)return p;d.b.trace("rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering");var v=s?Math.min(s,i.maxStarvationDelay):i.maxStarvationDelay,g=i.abrBandWidthFactor,y=i.abrBandWidthUpFactor;if(0===f){var m=this.bitrateTestDelay;if(m){v=(s?Math.min(s,i.maxLoadingDelay):i.maxLoadingDelay)-m,d.b.trace("bitrate test took "+Math.round(1e3*m)+"ms, set first fragment max fetchDuration to "+Math.round(1e3*v)+" ms"),g=y=1}}return p=this._findBestLevel(o,s,h,a,e,f+v,g,y,r),Math.max(p,0)}}]),e}(s.a);e.a=f},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(53),n=function(){function t(e,r,n,o){i(this,t),this.hls=e,this.defaultEstimate_=o,this.minWeight_=.001,this.minDelayMs_=50,this.slow_=new a.a(r),this.fast_=new a.a(n)}return t.prototype.sample=function(t,e){t=Math.max(t,this.minDelayMs_);var r=8e3*e/t,i=t/1e3;this.fast_.sample(i,r),this.slow_.sample(i,r)},t.prototype.canEstimate=function(){var t=this.fast_;return t&&t.getTotalWeight()>=this.minWeight_},t.prototype.getEstimate=function(){return this.canEstimate()?Math.min(this.fast_.getEstimate(),this.slow_.getEstimate()):this.defaultEstimate_},t.prototype.destroy=function(){},t}();e.a=n},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=function(){function t(e){i(this,t),this.alpha_=e?Math.exp(Math.log(.5)/e):0,this.estimate_=0,this.totalWeight_=0}return t.prototype.sample=function(t,e){var r=Math.pow(this.alpha_,t);this.estimate_=e*(1-r)+r*this.estimate_,this.totalWeight_+=t},t.prototype.getTotalWeight=function(){return this.totalWeight_},t.prototype.getEstimate=function(){if(this.alpha_){var t=1-Math.pow(this.alpha_,this.totalWeight_);return this.estimate_/t}return this.estimate_},t}();e.a=a},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(1),s=r(3),l=r(0),u=r(2),d=r(12),c=Object(d.a)(),h=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,o.a.MEDIA_ATTACHING,o.a.MEDIA_DETACHING,o.a.MANIFEST_PARSED,o.a.BUFFER_RESET,o.a.BUFFER_APPENDING,o.a.BUFFER_CODECS,o.a.BUFFER_EOS,o.a.BUFFER_FLUSHING,o.a.LEVEL_PTS_UPDATED,o.a.LEVEL_UPDATED));return n._msDuration=null,n._levelDuration=null,n._live=null,n._objectUrl=null,n.onsbue=n.onSBUpdateEnd.bind(n),n.onsbe=n.onSBUpdateError.bind(n),n.pendingTracks={},n.tracks={},n}return n(e,t),e.prototype.destroy=function(){s.a.prototype.destroy.call(this)},e.prototype.onLevelPtsUpdated=function(t){var e=t.type,r=this.tracks.audio;if("audio"===e&&r&&"audio/mpeg"===r.container){var i=this.sourceBuffer.audio;if(Math.abs(i.timestampOffset-t.start)>.1){var a=i.updating;try{i.abort()}catch(t){a=!0,l.b.warn("can not abort audio buffer: "+t)}a?this.audioTimestampOffset=t.start:(l.b.warn("change mpeg audio timestamp offset from "+i.timestampOffset+" to "+t.start),i.timestampOffset=t.start)}}},e.prototype.onManifestParsed=function(t){var e=t.audio,r=t.video||t.levels.length&&t.altAudio,i=0;t.altAudio&&(e||r)&&(i=(e?1:0)+(r?1:0),l.b.log(i+" sourceBuffer(s) expected")),this.sourceBufferNb=i},e.prototype.onMediaAttaching=function(t){var e=this.media=t.media;if(e){var r=this.mediaSource=new c;this.onmso=this.onMediaSourceOpen.bind(this),this.onmse=this.onMediaSourceEnded.bind(this),this.onmsc=this.onMediaSourceClose.bind(this),r.addEventListener("sourceopen",this.onmso),r.addEventListener("sourceended",this.onmse),r.addEventListener("sourceclose",this.onmsc),e.src=URL.createObjectURL(r),this._objectUrl=e.src}},e.prototype.onMediaDetaching=function(){l.b.log("media source detaching");var t=this.mediaSource;if(t){if("open"===t.readyState)try{t.endOfStream()}catch(t){l.b.warn("onMediaDetaching:"+t.message+" while calling endOfStream")}t.removeEventListener("sourceopen",this.onmso),t.removeEventListener("sourceended",this.onmse),t.removeEventListener("sourceclose",this.onmsc),this.media&&(URL.revokeObjectURL(this._objectUrl),this.media.src===this._objectUrl?(this.media.removeAttribute("src"),this.media.load()):l.b.warn("media.src was changed by a third party - skip cleanup")),this.mediaSource=null,this.media=null,this._objectUrl=null,this.pendingTracks={},this.tracks={},this.sourceBuffer={},this.flushRange=[],this.segments=[],this.appended=0}this.onmso=this.onmse=this.onmsc=null,this.hls.trigger(o.a.MEDIA_DETACHED)},e.prototype.onMediaSourceOpen=function(){l.b.log("media source opened"),this.hls.trigger(o.a.MEDIA_ATTACHED,{media:this.media});var t=this.mediaSource;t&&t.removeEventListener("sourceopen",this.onmso),this.checkPendingTracks()},e.prototype.checkPendingTracks=function(){var t=this.pendingTracks,e=Object.keys(t).length;e&&(this.sourceBufferNb<=e||0===this.sourceBufferNb)&&(this.createSourceBuffers(t),this.pendingTracks={},this.doAppending())},e.prototype.onMediaSourceClose=function(){l.b.log("media source closed")},e.prototype.onMediaSourceEnded=function(){l.b.log("media source ended")},e.prototype.onSBUpdateEnd=function(){if(this.audioTimestampOffset){var t=this.sourceBuffer.audio;l.b.warn("change mpeg audio timestamp offset from "+t.timestampOffset+" to "+this.audioTimestampOffset),t.timestampOffset=this.audioTimestampOffset,delete this.audioTimestampOffset}this._needsFlush&&this.doFlush(),this._needsEos&&this.checkEos(),this.appending=!1;var e=this.parent,r=this.segments.reduce(function(t,r){return r.parent===e?t+1:t},0),i={},a=this.sourceBuffer;for(var n in a)i[n]=a[n].buffered;this.hls.trigger(o.a.BUFFER_APPENDED,{parent:e,pending:r,timeRanges:i}),this._needsFlush||this.doAppending(),this.updateMediaElementDuration()},e.prototype.onSBUpdateError=function(t){l.b.error("sourceBuffer error:",t),this.hls.trigger(o.a.ERROR,{type:u.b.MEDIA_ERROR,details:u.a.BUFFER_APPENDING_ERROR,fatal:!1})},e.prototype.onBufferReset=function(){var t=this.sourceBuffer;for(var e in t){var r=t[e];try{this.mediaSource.removeSourceBuffer(r),r.removeEventListener("updateend",this.onsbue),r.removeEventListener("error",this.onsbe)}catch(t){}}this.sourceBuffer={},this.flushRange=[],this.segments=[],this.appended=0},e.prototype.onBufferCodecs=function(t){if(0===Object.keys(this.sourceBuffer).length){for(var e in t)this.pendingTracks[e]=t[e];var r=this.mediaSource;r&&"open"===r.readyState&&this.checkPendingTracks()}},e.prototype.createSourceBuffers=function(t){var e=this.sourceBuffer,r=this.mediaSource;for(var i in t)if(!e[i]){var a=t[i],n=a.levelCodec||a.codec,s=a.container+";codecs="+n;l.b.log("creating sourceBuffer("+s+")");try{var d=e[i]=r.addSourceBuffer(s);d.addEventListener("updateend",this.onsbue),d.addEventListener("error",this.onsbe),this.tracks[i]={codec:n,container:a.container},a.buffer=d}catch(t){l.b.error("error while trying to add sourceBuffer:"+t.message),this.hls.trigger(o.a.ERROR,{type:u.b.MEDIA_ERROR,details:u.a.BUFFER_ADD_CODEC_ERROR,fatal:!1,err:t,mimeType:s})}}this.hls.trigger(o.a.BUFFER_CREATED,{tracks:t})},e.prototype.onBufferAppending=function(t){this._needsFlush||(this.segments?this.segments.push(t):this.segments=[t],this.doAppending())},e.prototype.onBufferAppendFail=function(t){l.b.error("sourceBuffer error:",t.event),this.hls.trigger(o.a.ERROR,{type:u.b.MEDIA_ERROR,details:u.a.BUFFER_APPENDING_ERROR,fatal:!1})},e.prototype.onBufferEos=function(t){var e=this.sourceBuffer,r=t.type;for(var i in e)r&&i!==r||e[i].ended||(e[i].ended=!0,l.b.log(i+" sourceBuffer now EOS"));this.checkEos()},e.prototype.checkEos=function(){var t=this.sourceBuffer,e=this.mediaSource;if(!e||"open"!==e.readyState)return void(this._needsEos=!1);for(var r in t){var i=t[r];if(!i.ended)return;if(i.updating)return void(this._needsEos=!0)}l.b.log("all media data available, signal endOfStream() to MediaSource and stop loading fragment");try{e.endOfStream()}catch(t){l.b.warn("exception while calling mediaSource.endOfStream()")}this._needsEos=!1},e.prototype.onBufferFlushing=function(t){this.flushRange.push({start:t.startOffset,end:t.endOffset,type:t.type}),this.flushBufferCounter=0,this.doFlush()},e.prototype.onLevelUpdated=function(t){var e=t.details;e.fragments.length>0&&(this._levelDuration=e.totalduration+e.fragments[0].start,this._live=e.live,this.updateMediaElementDuration())},e.prototype.updateMediaElementDuration=function(){var t=this.hls.config,e=void 0;if(null!==this._levelDuration&&this.media&&this.mediaSource&&this.sourceBuffer&&0!==this.media.readyState&&"open"===this.mediaSource.readyState){for(var r in this.sourceBuffer)if(!0===this.sourceBuffer[r].updating)return;e=this.media.duration,null===this._msDuration&&(this._msDuration=this.mediaSource.duration),!0===this._live&&!0===t.liveDurationInfinity?(l.b.log("Media Source duration is set to Infinity"),this._msDuration=this.mediaSource.duration=1/0):(this._levelDuration>this._msDuration&&this._levelDuration>e||e===1/0||isNaN(e))&&(l.b.log("Updating Media Source duration to "+this._levelDuration.toFixed(3)),this._msDuration=this.mediaSource.duration=this._levelDuration)}},e.prototype.doFlush=function(){for(;this.flushRange.length;){var t=this.flushRange[0];if(!this.flushBuffer(t.start,t.end,t.type))return void(this._needsFlush=!0);this.flushRange.shift(),this.flushBufferCounter=0}if(0===this.flushRange.length){this._needsFlush=!1;var e=0,r=this.sourceBuffer;try{for(var i in r)e+=r[i].buffered.length}catch(t){l.b.error("error while accessing sourceBuffer.buffered")}this.appended=e,this.hls.trigger(o.a.BUFFER_FLUSHED)}},e.prototype.doAppending=function(){var t=this.hls,e=this.sourceBuffer,r=this.segments;if(Object.keys(e).length){if(this.media.error)return this.segments=[],void l.b.error("trying to append although a media error occured, flush segment and abort");if(this.appending)return;if(r&&r.length){var i=r.shift();try{var a=i.type,n=e[a];n?n.updating?r.unshift(i):(n.ended=!1,this.parent=i.parent,n.appendBuffer(i.data),this.appendError=0,this.appended++,this.appending=!0):this.onSBUpdateEnd()}catch(e){l.b.error("error while trying to append buffer:"+e.message),r.unshift(i);var s={type:u.b.MEDIA_ERROR,parent:i.parent};22!==e.code?(this.appendError?this.appendError++:this.appendError=1,s.details=u.a.BUFFER_APPEND_ERROR,this.appendError>t.config.appendErrorMaxRetry?(l.b.log("fail "+t.config.appendErrorMaxRetry+" times to append segment in sourceBuffer"),r=[],s.fatal=!0,t.trigger(o.a.ERROR,s)):(s.fatal=!1,t.trigger(o.a.ERROR,s))):(this.segments=[],s.details=u.a.BUFFER_FULL_ERROR,s.fatal=!1,t.trigger(o.a.ERROR,s))}}}},e.prototype.flushBuffer=function(t,e,r){var i=void 0,a=void 0,n=void 0,o=void 0,s=void 0,u=void 0,d=this.sourceBuffer;if(Object.keys(d).length){if(l.b.log("flushBuffer,pos/start/end: "+this.media.currentTime.toFixed(3)+"/"+t+"/"+e),this.flushBufferCounter<this.appended){for(var c in d)if(!r||c===r){if(i=d[c],i.ended=!1,i.updating)return l.b.warn("cannot flush, sb updating in progress"),!1;try{for(a=0;a<i.buffered.length;a++)if(n=i.buffered.start(a),o=i.buffered.end(a),-1!==navigator.userAgent.toLowerCase().indexOf("firefox")&&e===Number.POSITIVE_INFINITY?(s=t,u=e):(s=Math.max(n,t),u=Math.min(o,e)),Math.min(u,o)-s>.5)return this.flushBufferCounter++,l.b.log("flush "+c+" ["+s+","+u+"], of ["+n+","+o+"], pos:"+this.media.currentTime),i.remove(s,u),!1}catch(t){l.b.warn("exception while accessing sourcebuffer, it might have been removed from MediaSource")}}}else l.b.warn("abort flushing too many retries");l.b.log("buffer flushed")}return!0},e}(s.a);e.a=h},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(1),s=r(3),l=function(){function t(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,r,i){return r&&t(e.prototype,r),i&&t(e,i),e}}(),u=function(t){function e(r){return i(this,e),a(this,t.call(this,r,o.a.FPS_DROP_LEVEL_CAPPING,o.a.MEDIA_ATTACHING,o.a.MANIFEST_PARSED))}return n(e,t),e.prototype.destroy=function(){this.hls.config.capLevelToPlayerSize&&(this.media=this.restrictedLevels=null,this.autoLevelCapping=Number.POSITIVE_INFINITY,this.timer&&(this.timer=clearInterval(this.timer)))},e.prototype.onFpsDropLevelCapping=function(t){e.isLevelAllowed(t.droppedLevel,this.restrictedLevels)&&this.restrictedLevels.push(t.droppedLevel)},e.prototype.onMediaAttaching=function(t){this.media=t.media instanceof HTMLVideoElement?t.media:null},e.prototype.onManifestParsed=function(t){var e=this.hls;this.restrictedLevels=[],e.config.capLevelToPlayerSize&&(t.video||t.levels.length&&t.altAudio)&&(this.autoLevelCapping=Number.POSITIVE_INFINITY,this.levels=t.levels,e.firstLevel=this.getMaxLevel(t.firstLevel),clearInterval(this.timer),this.timer=setInterval(this.detectPlayerSize.bind(this),1e3),this.detectPlayerSize())},e.prototype.detectPlayerSize=function(){if(this.media){var t=this.levels?this.levels.length:0;if(t){var e=this.hls;e.autoLevelCapping=this.getMaxLevel(t-1),e.autoLevelCapping>this.autoLevelCapping&&e.streamController.nextLevelSwitch(),this.autoLevelCapping=e.autoLevelCapping}}},e.prototype.getMaxLevel=function(t){var r=this;if(!this.levels)return-1;var i=this.levels.filter(function(i,a){return e.isLevelAllowed(a,r.restrictedLevels)&&a<=t});return e.getMaxLevelByMediaSize(i,this.mediaWidth,this.mediaHeight)},e.isLevelAllowed=function(t){return-1===(arguments.length>1&&void 0!==arguments[1]?arguments[1]:[]).indexOf(t)},e.getMaxLevelByMediaSize=function(t,e,r){if(!t||t&&!t.length)return-1;for(var i=t.length-1,a=0;a<t.length;a+=1){var n=t[a];if((n.width>=e||n.height>=r)&&function(t,e){return!e||(t.width!==e.width||t.height!==e.height)}(n,t[a+1])){i=a;break}}return i},l(e,[{key:"mediaWidth",get:function(){var t=void 0,r=this.media;return r&&(t=r.width||r.clientWidth||r.offsetWidth,t*=e.contentScaleFactor),t}},{key:"mediaHeight",get:function(){var t=void 0,r=this.media;return r&&(t=r.height||r.clientHeight||r.offsetHeight,t*=e.contentScaleFactor),t}}],[{key:"contentScaleFactor",get:function(){var t=1;try{t=window.devicePixelRatio}catch(t){}return t}}]),e}(s.a);e.a=u},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(1),s=r(3),l=r(0),u=function(t){function e(r){return i(this,e),a(this,t.call(this,r,o.a.MEDIA_ATTACHING))}return n(e,t),e.prototype.destroy=function(){this.timer&&clearInterval(this.timer),this.isVideoPlaybackQualityAvailable=!1},e.prototype.onMediaAttaching=function(t){var e=this.hls.config;if(e.capLevelOnFPSDrop){"function"==typeof(this.video=t.media instanceof HTMLVideoElement?t.media:null).getVideoPlaybackQuality&&(this.isVideoPlaybackQualityAvailable=!0),clearInterval(this.timer),this.timer=setInterval(this.checkFPSInterval.bind(this),e.fpsDroppedMonitoringPeriod)}},e.prototype.checkFPS=function(t,e,r){var i=performance.now();if(e){if(this.lastTime){var a=i-this.lastTime,n=r-this.lastDroppedFrames,s=e-this.lastDecodedFrames,u=1e3*n/a,d=this.hls;if(d.trigger(o.a.FPS_DROP,{currentDropped:n,currentDecoded:s,totalDroppedFrames:r}),u>0&&n>d.config.fpsDroppedMonitoringThreshold*s){var c=d.currentLevel;l.b.warn("drop FPS ratio greater than max allowed value for currentLevel: "+c),c>0&&(-1===d.autoLevelCapping||d.autoLevelCapping>=c)&&(c-=1,d.trigger(o.a.FPS_DROP_LEVEL_CAPPING,{level:c,droppedLevel:d.currentLevel}),d.autoLevelCapping=c,d.streamController.nextLevelSwitch())}}this.lastTime=i,this.lastDroppedFrames=r,this.lastDecodedFrames=e}},e.prototype.checkFPSInterval=function(){var t=this.video;if(t)if(this.isVideoPlaybackQualityAvailable){var e=t.getVideoPlaybackQuality();this.checkFPS(t,e.totalVideoFrames,e.droppedVideoFrames)}else this.checkFPS(t,t.webkitDecodedFrameCount,t.webkitDroppedFrameCount)},e}(s.a);e.a=u},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=r(0),n=function(){function t(e){i(this,t),e&&e.xhrSetup&&(this.xhrSetup=e.xhrSetup)}return t.prototype.destroy=function(){this.abort(),this.loader=null},t.prototype.abort=function(){var t=this.loader;t&&4!==t.readyState&&(this.stats.aborted=!0,t.abort()),window.clearTimeout(this.requestTimeout),this.requestTimeout=null,window.clearTimeout(this.retryTimeout),this.retryTimeout=null},t.prototype.load=function(t,e,r){this.context=t,this.config=e,this.callbacks=r,this.stats={trequest:performance.now(),retry:0},this.retryDelay=e.retryDelay,this.loadInternal()},t.prototype.loadInternal=function(){var t=void 0,e=this.context;t=this.loader=new XMLHttpRequest;var r=this.stats;r.tfirst=0,r.loaded=0;var i=this.xhrSetup;try{if(i)try{i(t,e.url)}catch(r){t.open("GET",e.url,!0),i(t,e.url)}t.readyState||t.open("GET",e.url,!0)}catch(r){return void this.callbacks.onError({code:t.status,text:r.message},e,t)}e.rangeEnd&&t.setRequestHeader("Range","bytes="+e.rangeStart+"-"+(e.rangeEnd-1)),t.onreadystatechange=this.readystatechange.bind(this),t.onprogress=this.loadprogress.bind(this),t.responseType=e.responseType,this.requestTimeout=window.setTimeout(this.loadtimeout.bind(this),this.config.timeout),t.send()},t.prototype.readystatechange=function(t){var e=t.currentTarget,r=e.readyState,i=this.stats,n=this.context,o=this.config;if(!i.aborted&&r>=2)if(window.clearTimeout(this.requestTimeout),0===i.tfirst&&(i.tfirst=Math.max(performance.now(),i.trequest)),4===r){var s=e.status;if(s>=200&&s<300){i.tload=Math.max(i.tfirst,performance.now());var l=void 0,u=void 0;"arraybuffer"===n.responseType?(l=e.response,u=l.byteLength):(l=e.responseText,u=l.length),i.loaded=i.total=u;var d={url:e.responseURL,data:l};this.callbacks.onSuccess(d,i,n,e)}else i.retry>=o.maxRetry||s>=400&&s<499?(a.b.error(s+" while loading "+n.url),this.callbacks.onError({code:s,text:e.statusText},n,e)):(a.b.warn(s+" while loading "+n.url+", retrying in "+this.retryDelay+"..."),this.destroy(),this.retryTimeout=window.setTimeout(this.loadInternal.bind(this),this.retryDelay),this.retryDelay=Math.min(2*this.retryDelay,o.maxRetryDelay),i.retry++)}else this.requestTimeout=window.setTimeout(this.loadtimeout.bind(this),o.timeout)},t.prototype.loadtimeout=function(){a.b.warn("timeout while loading "+this.context.url),this.callbacks.onTimeout(this.stats,this.context,null)},t.prototype.loadprogress=function(t){var e=t.currentTarget,r=this.stats;r.loaded=t.loaded,t.lengthComputable&&(r.total=t.total);var i=this.callbacks.onProgress;i&&i(r,this.context,null,e)},t}();e.a=n},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(1),s=r(3),l=r(0),u=r(2),d=function(){function t(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,r,i){return r&&t(e.prototype,r),i&&t(e,i),e}}(),c=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,o.a.MANIFEST_LOADING,o.a.MANIFEST_PARSED,o.a.AUDIO_TRACK_LOADED,o.a.ERROR));return n.ticks=0,n.ontick=n.tick.bind(n),n}return n(e,t),e.prototype.destroy=function(){this.cleanTimer(),s.a.prototype.destroy.call(this)},e.prototype.cleanTimer=function(){this.timer&&(clearTimeout(this.timer),this.timer=null)},e.prototype.tick=function(){1===++this.ticks&&(this.doTick(),this.ticks>1&&setTimeout(this.tick,1),this.ticks=0)},e.prototype.doTick=function(){this.updateTrack(this.trackId)},e.prototype.onError=function(t){t.fatal&&t.type===u.b.NETWORK_ERROR&&this.cleanTimer()},e.prototype.onManifestLoading=function(){this.tracks=[],this.trackId=-1},e.prototype.onManifestParsed=function(t){var e=this,r=t.audioTracks||[],i=!1;this.tracks=r,this.hls.trigger(o.a.AUDIO_TRACKS_UPDATED,{audioTracks:r});var a=0;r.forEach(function(t){if(t.default&&!i)return e.audioTrack=a,void(i=!0);a++}),!1===i&&r.length&&(l.b.log("no default audio track defined, use first audio track as default"),this.audioTrack=0)},e.prototype.onAudioTrackLoaded=function(t){t.id<this.tracks.length&&(l.b.log("audioTrack "+t.id+" loaded"),this.tracks[t.id].details=t.details,t.details.live&&!this.timer&&(this.timer=setInterval(this.ontick,1e3*t.details.targetduration)),!t.details.live&&this.timer&&this.cleanTimer())},e.prototype.setAudioTrackInternal=function(t){if(t>=0&&t<this.tracks.length){this.cleanTimer(),this.trackId=t,l.b.log("switching to audioTrack "+t);var e=this.tracks[t],r=this.hls,i=e.type,a=e.url,n={id:t,type:i,url:a};r.trigger(o.a.AUDIO_TRACK_SWITCHING,n);var s=e.details;!a||void 0!==s&&!0!==s.live||(l.b.log("(re)loading playlist for audioTrack "+t),r.trigger(o.a.AUDIO_TRACK_LOADING,{url:a,id:t}))}},e.prototype.updateTrack=function(t){if(t>=0&&t<this.tracks.length){this.cleanTimer(),this.trackId=t,l.b.log("updating audioTrack "+t);var e=this.tracks[t],r=e.url,i=e.details;!r||void 0!==i&&!0!==i.live||(l.b.log("(re)loading playlist for audioTrack "+t),this.hls.trigger(o.a.AUDIO_TRACK_LOADING,{url:r,id:t}))}},d(e,[{key:"audioTracks",get:function(){return this.tracks}},{key:"audioTrack",get:function(){return this.trackId},set:function(t){this.trackId===t&&void 0!==this.tracks[t].details||this.setAudioTrackInternal(t)}}]),e}(s.a);e.a=c},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(8),s=r(9),l=r(18),u=r(1),d=r(22),c=r(23),h=r(2),f=r(0),p=r(24),v=r(13),g=r(7),y=r(6),m=function(){function t(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,r,i){return r&&t(e.prototype,r),i&&t(e,i),e}}(),b={STOPPED:"STOPPED",STARTING:"STARTING",IDLE:"IDLE",PAUSED:"PAUSED",KEY_LOADING:"KEY_LOADING",FRAG_LOADING:"FRAG_LOADING",FRAG_LOADING_WAITING_RETRY:"FRAG_LOADING_WAITING_RETRY",WAITING_TRACK:"WAITING_TRACK",PARSING:"PARSING",PARSED:"PARSED",BUFFER_FLUSHING:"BUFFER_FLUSHING",ENDED:"ENDED",ERROR:"ERROR",WAITING_INIT_PTS:"WAITING_INIT_PTS"},E=function(t){function e(r,n){i(this,e);var o=a(this,t.call(this,r,u.a.MEDIA_ATTACHED,u.a.MEDIA_DETACHING,u.a.AUDIO_TRACKS_UPDATED,u.a.AUDIO_TRACK_SWITCHING,u.a.AUDIO_TRACK_LOADED,u.a.KEY_LOADED,u.a.FRAG_LOADED,u.a.FRAG_PARSING_INIT_SEGMENT,u.a.FRAG_PARSING_DATA,u.a.FRAG_PARSED,u.a.ERROR,u.a.BUFFER_RESET,u.a.BUFFER_CREATED,u.a.BUFFER_APPENDED,u.a.BUFFER_FLUSHED,u.a.INIT_PTS_FOUND));return o.fragmentTracker=n,o.config=r.config,o.audioCodecSwap=!1,o._state=b.STOPPED,o.initPTS=[],o.waitingFragment=null,o.videoTrackCC=null,o}return n(e,t),e.prototype.onHandlerDestroying=function(){this.stopLoad()},e.prototype.onHandlerDestroyed=function(){this.state=b.STOPPED,this.fragmentTracker=null},e.prototype.onInitPtsFound=function(t){var e=t.id,r=t.frag.cc,i=t.initPTS;"main"===e&&(this.initPTS[r]=i,this.videoTrackCC=r,f.b.log("InitPTS for cc: "+r+" found from video track: "+i),this.state===b.WAITING_INIT_PTS&&this.tick())},e.prototype.startLoad=function(t){if(this.tracks){var e=this.lastCurrentTime;this.stopLoad(),this.setInterval(100),this.fragLoadError=0,e>0&&-1===t?(f.b.log("audio:override startPosition with lastCurrentTime @"+e.toFixed(3)),this.state=b.IDLE):(this.lastCurrentTime=this.startPosition?this.startPosition:t,this.state=b.STARTING),this.nextLoadPosition=this.startPosition=this.lastCurrentTime,this.tick()}else this.startPosition=t,this.state=b.STOPPED},e.prototype.stopLoad=function(){var t=this.fragCurrent;t&&(t.loader&&t.loader.abort(),this.fragmentTracker.removeFragment(t),this.fragCurrent=null),this.fragPrevious=null,this.demuxer&&(this.demuxer.destroy(),this.demuxer=null),this.state=b.STOPPED},e.prototype.doTick=function(){var t=void 0,e=void 0,r=void 0,i=this.hls,a=i.config;switch(this.state){case b.ERROR:case b.PAUSED:case b.BUFFER_FLUSHING:break;case b.STARTING:this.state=b.WAITING_TRACK,this.loadedmetadata=!1;break;case b.IDLE:var n=this.tracks;if(!n)break;if(!this.media&&(this.startFragRequested||!a.startFragPrefetch))break;if(this.loadedmetadata)t=this.media.currentTime;else if(void 0===(t=this.nextLoadPosition))break;var l=this.mediaBuffer?this.mediaBuffer:this.media,d=this.videoBuffer?this.videoBuffer:this.media,c=s.a.bufferInfo(l,t,a.maxBufferHole),h=s.a.bufferInfo(d,t,a.maxBufferHole),v=c.len,y=c.end,m=this.fragPrevious,E=Math.min(a.maxBufferLength,a.maxMaxBufferLength),T=Math.max(E,h.len),S=this.audioSwitch,R=this.trackId;if((v<T||S)&&R<n.length){if(void 0===(r=n[R].details)){this.state=b.WAITING_TRACK;break}if(!S&&!r.live&&m&&m.sn===r.endSN&&!c.nextStart&&(!this.media.seeking||this.media.duration-y<m.duration/2)){this.hls.trigger(u.a.BUFFER_EOS,{type:"audio"}),this.state=b.ENDED;break}var A=r.fragments,_=A.length,w=A[0].start,L=A[_-1].start+A[_-1].duration,D=void 0;if(S)if(r.live&&!r.PTSKnown)f.b.log("switching audiotrack, live stream, unknown PTS,load first fragment"),y=0;else if(y=t,r.PTSKnown&&t<w){if(!(c.end>w||c.nextStart))return;f.b.log("alt audio track ahead of main track, seek to start of alt audio track"),this.media.currentTime=w+.05}if(r.initSegment&&!r.initSegment.data)D=r.initSegment;else if(y<=w){if(D=A[0],null!==this.videoTrackCC&&D.cc!==this.videoTrackCC&&(D=Object(p.b)(A,this.videoTrackCC)),r.live&&D.loadIdx&&D.loadIdx===this.fragLoadIdx){var I=c.nextStart?c.nextStart:w;return f.b.log("no alt audio available @currentTime:"+this.media.currentTime+", seeking @"+(I+.05)),void(this.media.currentTime=I+.05)}}else{var k=void 0,O=a.maxFragLookUpTolerance,C=m?A[m.sn-A[0].sn+1]:void 0,P=function(t){var e=Math.min(O,t.duration);return t.start+t.duration-e<=y?1:t.start-e>y&&t.start?-1:0};y<L?(y>L-O&&(O=0),k=C&&!P(C)?C:o.a.search(A,P)):k=A[_-1],k&&(D=k,w=k.start,m&&D.level===m.level&&D.sn===m.sn&&(D.sn<r.endSN?(D=A[D.sn+1-r.startSN],f.b.log("SN just loaded, load next one: "+D.sn)):D=null))}D&&(D.decryptdata&&null!=D.decryptdata.uri&&null==D.decryptdata.key?(f.b.log("Loading key for "+D.sn+" of ["+r.startSN+" ,"+r.endSN+"],track "+R),this.state=b.KEY_LOADING,i.trigger(u.a.KEY_LOADING,{frag:D})):(f.b.log("Loading "+D.sn+", cc: "+D.cc+" of ["+r.startSN+" ,"+r.endSN+"],track "+R+", currentTime:"+t+",bufferEnd:"+y.toFixed(3)),(S||this.fragmentTracker.getState(D)===g.a.NOT_LOADED)&&(this.fragCurrent=D,this.startFragRequested=!0,isNaN(D.sn)||(this.nextLoadPosition=D.start+D.duration),i.trigger(u.a.FRAG_LOADING,{frag:D}),this.state=b.FRAG_LOADING)))}break;case b.WAITING_TRACK:e=this.tracks[this.trackId],e&&e.details&&(this.state=b.IDLE);break;case b.FRAG_LOADING_WAITING_RETRY:var x=performance.now(),F=this.retryDate;l=this.media;var N=l&&l.seeking;(!F||x>=F||N)&&(f.b.log("audioStreamController: retryDate reached, switch back to IDLE state"),this.state=b.IDLE);break;case b.WAITING_INIT_PTS:var M=this.videoTrackCC;if(void 0===this.initPTS[M])break;var U=this.waitingFragment;if(U){var B=U.frag.cc;M!==B?(e=this.tracks[this.trackId],e.details&&e.details.live&&(f.b.warn("Waiting fragment CC ("+B+") does not match video track CC ("+M+")"),this.waitingFragment=null,this.state=b.IDLE)):(this.state=b.FRAG_LOADING,this.onFragLoaded(this.waitingFragment),this.waitingFragment=null)}else this.state=b.IDLE;break;case b.STOPPED:case b.FRAG_LOADING:case b.PARSING:case b.PARSED:case b.ENDED:}},e.prototype.onMediaAttached=function(t){var e=this.media=this.mediaBuffer=t.media;this.onvseeking=this.onMediaSeeking.bind(this),this.onvended=this.onMediaEnded.bind(this),e.addEventListener("seeking",this.onvseeking),e.addEventListener("ended",this.onvended);var r=this.config;this.tracks&&r.autoStartLoad&&this.startLoad(r.startPosition)},e.prototype.onMediaDetaching=function(){var t=this.media;t&&t.ended&&(f.b.log("MSE detaching and video ended, reset startPosition"),this.startPosition=this.lastCurrentTime=0),t&&(t.removeEventListener("seeking",this.onvseeking),t.removeEventListener("ended",this.onvended),this.onvseeking=this.onvseeked=this.onvended=null),this.media=this.mediaBuffer=this.videoBuffer=null,this.loadedmetadata=!1,this.stopLoad()},e.prototype.onMediaSeeking=function(){this.state===b.ENDED&&(this.state=b.IDLE),this.media&&(this.lastCurrentTime=this.media.currentTime),this.tick()},e.prototype.onMediaEnded=function(){this.startPosition=this.lastCurrentTime=0},e.prototype.onAudioTracksUpdated=function(t){f.b.log("audio tracks updated"),this.tracks=t.audioTracks},e.prototype.onAudioTrackSwitching=function(t){var e=!!t.url;this.trackId=t.id,this.fragCurrent=null,this.state=b.PAUSED,this.waitingFragment=null,e?this.setInterval(100):this.demuxer&&(this.demuxer.destroy(),this.demuxer=null),e&&(this.audioSwitch=!0,this.state=b.IDLE),this.tick()},e.prototype.onAudioTrackLoaded=function(t){var e=t.details,r=t.id,i=this.tracks[r],a=e.totalduration,n=0;if(f.b.log("track "+r+" loaded ["+e.startSN+","+e.endSN+"],duration:"+a),e.live){var o=i.details;o&&e.fragments.length>0?(d.a(o,e),n=e.fragments[0].start,e.PTSKnown?f.b.log("live audio playlist sliding:"+n.toFixed(3)):f.b.log("live audio playlist - outdated PTS, unknown sliding")):(e.PTSKnown=!1,f.b.log("live audio playlist - first load, unknown sliding"))}else e.PTSKnown=!1;if(i.details=e,!this.startFragRequested){if(-1===this.startPosition){var s=e.startTimeOffset;isNaN(s)?this.startPosition=0:(f.b.log("start time offset found in playlist, adjust startPosition to "+s),this.startPosition=s)}this.nextLoadPosition=this.startPosition}this.state===b.WAITING_TRACK&&(this.state=b.IDLE),this.tick()},e.prototype.onKeyLoaded=function(){this.state===b.KEY_LOADING&&(this.state=b.IDLE,this.tick())},e.prototype.onFragLoaded=function(t){var e=this.fragCurrent,r=t.frag;if(this.state===b.FRAG_LOADING&&e&&"audio"===r.type&&r.level===e.level&&r.sn===e.sn){var i=this.tracks[this.trackId],a=i.details,n=a.totalduration,o=e.level,s=e.sn,d=e.cc,c=this.config.defaultAudioCodec||i.audioCodec||"mp4a.40.2",h=this.stats=t.stats;if("initSegment"===s)this.state=b.IDLE,h.tparsed=h.tbuffered=performance.now(),a.initSegment.data=t.payload,this.hls.trigger(u.a.FRAG_BUFFERED,{stats:h,frag:e,id:"audio"}),this.tick();else{this.state=b.PARSING,this.appended=!1,this.demuxer||(this.demuxer=new l.a(this.hls,"audio"));var p=this.initPTS[d],v=a.initSegment?a.initSegment.data:[];if(a.initSegment||void 0!==p){this.pendingBuffering=!0,f.b.log("Demuxing "+s+" of ["+a.startSN+" ,"+a.endSN+"],track "+o);this.demuxer.push(t.payload,v,c,null,e,n,!1,p)}else f.b.log("unknown video PTS for continuity counter "+d+", waiting for video PTS before demuxing audio frag "+s+" of ["+a.startSN+" ,"+a.endSN+"],track "+o),this.waitingFragment=t,this.state=b.WAITING_INIT_PTS}}this.fragLoadError=0},e.prototype.onFragParsingInitSegment=function(t){var e=this.fragCurrent,r=t.frag;if(e&&"audio"===t.id&&r.sn===e.sn&&r.level===e.level&&this.state===b.PARSING){var i=t.tracks,a=void 0;if(i.video&&delete i.video,a=i.audio){a.levelCodec=a.codec,a.id=t.id,this.hls.trigger(u.a.BUFFER_CODECS,i),f.b.log("audio track:audio,container:"+a.container+",codecs[level/parsed]=["+a.levelCodec+"/"+a.codec+"]");var n=a.initSegment;if(n){var o={type:"audio",data:n,parent:"audio",content:"initSegment"};this.audioSwitch?this.pendingData=[o]:(this.appended=!0,this.pendingBuffering=!0,this.hls.trigger(u.a.BUFFER_APPENDING,o))}this.tick()}}},e.prototype.onFragParsingData=function(t){var e=this,r=this.fragCurrent,i=t.frag;if(r&&"audio"===t.id&&"audio"===t.type&&i.sn===r.sn&&i.level===r.level&&this.state===b.PARSING){var a=this.trackId,n=this.tracks[a],o=this.hls;isNaN(t.endPTS)&&(t.endPTS=t.startPTS+r.duration,t.endDTS=t.startDTS+r.duration),r.addElementaryStream(y.a.ElementaryStreamTypes.AUDIO),f.b.log("parsed "+t.type+",PTS:["+t.startPTS.toFixed(3)+","+t.endPTS.toFixed(3)+"],DTS:["+t.startDTS.toFixed(3)+"/"+t.endDTS.toFixed(3)+"],nb:"+t.nb),d.b(n.details,r,t.startPTS,t.endPTS);var s=this.audioSwitch,l=this.media,c=!1;if(s&&l)if(l.readyState){var p=l.currentTime;f.b.log("switching audio track : currentTime:"+p),p>=t.startPTS&&(f.b.log("switching audio track : flushing all audio"),this.state=b.BUFFER_FLUSHING,o.trigger(u.a.BUFFER_FLUSHING,{startOffset:0,endOffset:Number.POSITIVE_INFINITY,type:"audio"}),c=!0,this.audioSwitch=!1,o.trigger(u.a.AUDIO_TRACK_SWITCHED,{id:a}))}else this.audioSwitch=!1,o.trigger(u.a.AUDIO_TRACK_SWITCHED,{id:a});var v=this.pendingData;if(!v)return console.warn("Apparently attempt to enqueue media payload without codec initialization data upfront"),void o.trigger(u.a.ERROR,{type:h.b.MEDIA_ERROR,details:null,fatal:!0});this.audioSwitch||([t.data1,t.data2].forEach(function(e){e&&e.length&&v.push({type:t.type,data:e,parent:"audio",content:"data"})}),!c&&v.length&&(v.forEach(function(t){e.state===b.PARSING&&(e.pendingBuffering=!0,e.hls.trigger(u.a.BUFFER_APPENDING,t))}),this.pendingData=[],this.appended=!0)),this.tick()}},e.prototype.onFragParsed=function(t){var e=this.fragCurrent,r=t.frag;e&&"audio"===t.id&&r.sn===e.sn&&r.level===e.level&&this.state===b.PARSING&&(this.stats.tparsed=performance.now(),this.state=b.PARSED,this._checkAppendedParsed())},e.prototype.onBufferReset=function(){this.mediaBuffer=this.videoBuffer=null,this.loadedmetadata=!1},e.prototype.onBufferCreated=function(t){var e=t.tracks.audio;e&&(this.mediaBuffer=e.buffer,this.loadedmetadata=!0),t.tracks.video&&(this.videoBuffer=t.tracks.video.buffer)},e.prototype.onBufferAppended=function(t){if("audio"===t.parent){var e=this.state;e!==b.PARSING&&e!==b.PARSED||(this.pendingBuffering=t.pending>0,this._checkAppendedParsed())}},e.prototype._checkAppendedParsed=function(){if(!(this.state!==b.PARSED||this.appended&&this.pendingBuffering)){var t=this.fragCurrent,e=this.stats,r=this.hls;if(t){this.fragPrevious=t,e.tbuffered=performance.now(),r.trigger(u.a.FRAG_BUFFERED,{stats:e,frag:t,id:"audio"});var i=this.mediaBuffer?this.mediaBuffer:this.media;f.b.log("audio buffered : "+c.a.toString(i.buffered)),this.audioSwitch&&this.appended&&(this.audioSwitch=!1,r.trigger(u.a.AUDIO_TRACK_SWITCHED,{id:this.trackId})),this.state=b.IDLE}this.tick()}},e.prototype.onError=function(t){var e=t.frag;if(!e||"audio"===e.type)switch(t.details){case h.a.FRAG_LOAD_ERROR:case h.a.FRAG_LOAD_TIMEOUT:if(!t.fatal){var r=this.fragLoadError;r?r++:r=1;var i=this.config;if(r<=i.fragLoadingMaxRetry){this.fragLoadError=r;var a=Math.min(Math.pow(2,r-1)*i.fragLoadingRetryDelay,i.fragLoadingMaxRetryTimeout);f.b.warn("audioStreamController: frag loading failed, retry in "+a+" ms"),this.retryDate=performance.now()+a,this.state=b.FRAG_LOADING_WAITING_RETRY}else f.b.error("audioStreamController: "+t.details+" reaches max retry, redispatch as fatal ..."),t.fatal=!0,this.state=b.ERROR}break;case h.a.AUDIO_TRACK_LOAD_ERROR:case h.a.AUDIO_TRACK_LOAD_TIMEOUT:case h.a.KEY_LOAD_ERROR:case h.a.KEY_LOAD_TIMEOUT:this.state!==b.ERROR&&(this.state=t.fatal?b.ERROR:b.IDLE,f.b.warn("audioStreamController: "+t.details+" while loading frag,switch to "+this.state+" state ..."));break;case h.a.BUFFER_FULL_ERROR:if("audio"===t.parent&&(this.state===b.PARSING||this.state===b.PARSED)){var n=this.mediaBuffer,o=this.media.currentTime;if(n&&s.a.isBuffered(n,o)&&s.a.isBuffered(n,o+.5)){var l=this.config;l.maxMaxBufferLength>=l.maxBufferLength&&(l.maxMaxBufferLength/=2,f.b.warn("audio:reduce max buffer length to "+l.maxMaxBufferLength+"s")),this.state=b.IDLE}else f.b.warn("buffer full error also media.currentTime is not buffered, flush audio buffer"),this.fragCurrent=null,this.state=b.BUFFER_FLUSHING,this.hls.trigger(u.a.BUFFER_FLUSHING,{startOffset:0,endOffset:Number.POSITIVE_INFINITY,type:"audio"})}}},e.prototype.onBufferFlushed=function(){var t=this,e=this.pendingData;e&&e.length?(f.b.log("appending pending audio data on Buffer Flushed"),e.forEach(function(e){t.hls.trigger(u.a.BUFFER_APPENDING,e)}),this.appended=!0,this.pendingData=[],this.state=b.PARSED):(this.state=b.IDLE,this.fragPrevious=null,this.tick())},m(e,[{key:"state",set:function(t){if(this.state!==t){var e=this.state;this._state=t,f.b.log("audio stream:"+e+"->"+t)}},get:function(){return this._state}}]),e}(v.a);e.a=E},function(t,e,r){"use strict";function i(t,e,r,i){for(var n=void 0,o=void 0,s=void 0,l=void 0,u=void 0,d=window.VTTCue||window.TextTrackCue,c=0;c<i.rows.length;c++)if(n=i.rows[c],s=!0,l=0,u="",!n.isEmpty()){for(var h=0;h<n.chars.length;h++)n.chars[h].uchar.match(/\s/)&&s?l++:(u+=n.chars[h].uchar,s=!1);n.cueStartTime=e,e===r&&(r+=1e-4),o=new d(e,r,Object(a.b)(u.trim())),l>=16?l--:l++,navigator.userAgent.match(/Firefox\//)?o.line=c+1:o.line=c>7?c-2:c+1,o.align="left",o.position=Math.max(0,Math.min(100,l/32*100+(navigator.userAgent.match(/Firefox\//)?50:0))),t.addCue(o)}}Object.defineProperty(e,"__esModule",{value:!0}),e.newCue=i;var a=r(26)},function(t,e,r){"use strict";e.a=function(){function t(t){return"string"==typeof t&&(!!n[t.toLowerCase()]&&t.toLowerCase())}function e(t){return"string"==typeof t&&(!!o[t.toLowerCase()]&&t.toLowerCase())}function r(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var i in r)t[i]=r[i]}return t}function i(i,n,o){var s=this,l=function(){if("undefined"!=typeof navigator)return/MSIE\s8\.0/.test(navigator.userAgent)}(),u={};l?s=document.createElement("custom"):u.enumerable=!0,s.hasBeenReset=!1;var d="",c=!1,h=i,f=n,p=o,v=null,g="",y=!0,m="auto",b="start",E=50,T="middle",S=50,R="middle";if(Object.defineProperty(s,"id",r({},u,{get:function(){return d},set:function(t){d=""+t}})),Object.defineProperty(s,"pauseOnExit",r({},u,{get:function(){return c},set:function(t){c=!!t}})),Object.defineProperty(s,"startTime",r({},u,{get:function(){return h},set:function(t){if("number"!=typeof t)throw new TypeError("Start time must be set to a number.");h=t,this.hasBeenReset=!0}})),Object.defineProperty(s,"endTime",r({},u,{get:function(){return f},set:function(t){if("number"!=typeof t)throw new TypeError("End time must be set to a number.");f=t,this.hasBeenReset=!0}})),Object.defineProperty(s,"text",r({},u,{get:function(){return p},set:function(t){p=""+t,this.hasBeenReset=!0}})),Object.defineProperty(s,"region",r({},u,{get:function(){return v},set:function(t){v=t,this.hasBeenReset=!0}})),Object.defineProperty(s,"vertical",r({},u,{get:function(){return g},set:function(e){var r=t(e);if(!1===r)throw new SyntaxError("An invalid or illegal string was specified.");g=r,this.hasBeenReset=!0}})),Object.defineProperty(s,"snapToLines",r({},u,{get:function(){return y},set:function(t){y=!!t,this.hasBeenReset=!0}})),Object.defineProperty(s,"line",r({},u,{get:function(){return m},set:function(t){if("number"!=typeof t&&t!==a)throw new SyntaxError("An invalid number or illegal string was specified.");m=t,this.hasBeenReset=!0}})),Object.defineProperty(s,"lineAlign",r({},u,{get:function(){return b},set:function(t){var r=e(t);if(!r)throw new SyntaxError("An invalid or illegal string was specified.");b=r,this.hasBeenReset=!0}})),Object.defineProperty(s,"position",r({},u,{get:function(){return E},set:function(t){if(t<0||t>100)throw new Error("Position must be between 0 and 100.");E=t,this.hasBeenReset=!0}})),Object.defineProperty(s,"positionAlign",r({},u,{get:function(){return T},set:function(t){var r=e(t);if(!r)throw new SyntaxError("An invalid or illegal string was specified.");T=r,this.hasBeenReset=!0}})),Object.defineProperty(s,"size",r({},u,{get:function(){return S},set:function(t){if(t<0||t>100)throw new Error("Size must be between 0 and 100.");S=t,this.hasBeenReset=!0}})),Object.defineProperty(s,"align",r({},u,{get:function(){return R},set:function(t){var r=e(t);if(!r)throw new SyntaxError("An invalid or illegal string was specified.");R=r,this.hasBeenReset=!0}})),s.displayState=void 0,l)return s}if("undefined"!=typeof window&&window.VTTCue)return window.VTTCue;var a="auto",n={"":!0,lr:!0,rl:!0},o={start:!0,middle:!0,end:!0,left:!0,right:!0};return i.prototype.getCueAsHTML=function(){return window.WebVTT.convertCueToDOMTree(window,this.text)},i}()},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function o(t,e){return t&&t.label===e.name&&!(t.textTrack1||t.textTrack2)}function s(t,e,r,i){return Math.min(e,i)-Math.max(t,r)}var l=r(1),u=r(3),d=r(63),c=r(64),h=r(65),f=r(0),p=r(25),v=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,l.a.MEDIA_ATTACHING,l.a.MEDIA_DETACHING,l.a.FRAG_PARSING_USERDATA,l.a.FRAG_DECRYPTED,l.a.MANIFEST_LOADING,l.a.MANIFEST_LOADED,l.a.FRAG_LOADED,l.a.LEVEL_SWITCHING,l.a.INIT_PTS_FOUND));if(n.hls=r,n.config=r.config,n.enabled=!0,n.Cues=r.config.cueHandler,n.textTracks=[],n.tracks=[],n.unparsedVttFrags=[],n.initPTS=void 0,n.cueRanges=[],n.captionsTracks={},n.captionsProperties={textTrack1:{label:n.config.captionsTextTrack1Label,languageCode:n.config.captionsTextTrack1LanguageCode},textTrack2:{label:n.config.captionsTextTrack2Label,languageCode:n.config.captionsTextTrack2LanguageCode}},n.config.enableCEA708Captions){var o=new c.a(n,"textTrack1"),s=new c.a(n,"textTrack2");n.cea608Parser=new d.a(0,o,s)}return n}return n(e,t),e.prototype.addCues=function(t,e,r,i){for(var a=this.cueRanges,n=!1,o=a.length;o--;){var l=a[o],u=s(l[0],l[1],e,r);if(u>=0&&(l[0]=Math.min(l[0],e),l[1]=Math.max(l[1],r),n=!0,u/(r-e)>.5))return}n||a.push([e,r]),this.Cues.newCue(this.captionsTracks[t],e,r,i)},e.prototype.onInitPtsFound=function(t){var e=this;void 0===this.initPTS&&(this.initPTS=t.initPTS),this.unparsedVttFrags.length&&(this.unparsedVttFrags.forEach(function(t){e.onFragLoaded(t)}),this.unparsedVttFrags=[])},e.prototype.getExistingTrack=function(t){var e=this.media;if(e)for(var r=0;r<e.textTracks.length;r++){var i=e.textTracks[r];if(i[t])return i}return null},e.prototype.createCaptionsTrack=function(t){var e=this.captionsProperties[t],r=e.label,i=e.languageCode,a=this.captionsTracks;if(!a[t]){var n=this.getExistingTrack(t);if(n)a[t]=n,Object(p.a)(a[t]),Object(p.b)(a[t],this.media);else{var o=this.createTextTrack("captions",r,i);o&&(o[t]=!0,a[t]=o)}}},e.prototype.createTextTrack=function(t,e,r){var i=this.media;if(i)return i.addTextTrack(t,e,r)},e.prototype.destroy=function(){u.a.prototype.destroy.call(this)},e.prototype.onMediaAttaching=function(t){this.media=t.media,this._cleanTracks()},e.prototype.onMediaDetaching=function(){var t=this.captionsTracks;Object.keys(t).forEach(function(e){Object(p.a)(t[e]),delete t[e]})},e.prototype.onManifestLoading=function(){this.lastSn=-1,this.prevCC=-1,this.vttCCs={ccOffset:0,presentationOffset:0},this._cleanTracks()},e.prototype._cleanTracks=function(){var t=this.media;if(t){var e=t.textTracks;if(e)for(var r=0;r<e.length;r++)Object(p.a)(e[r])}},e.prototype.onManifestLoaded=function(t){var e=this;if(this.textTracks=[],this.unparsedVttFrags=this.unparsedVttFrags||[],this.initPTS=void 0,this.cueRanges=[],this.config.enableWebVTT){this.tracks=t.subtitles||[];var r=this.media?this.media.textTracks:[];this.tracks.forEach(function(t,i){var a=void 0;if(i<r.length){var n=r[i];o(n,t)&&(a=n)}a||(a=e.createTextTrack("subtitles",t.name,t.lang)),t.default?a.mode=e.hls.subtitleDisplay?"showing":"hidden":a.mode="disabled",e.textTracks.push(a)})}},e.prototype.onLevelSwitching=function(){this.enabled="NONE"!==this.hls.currentLevel.closedCaptions},e.prototype.onFragLoaded=function(t){var e=t.frag,r=t.payload;if("main"===e.type){var i=e.sn;if(i!==this.lastSn+1){var a=this.cea608Parser;a&&a.reset()}this.lastSn=i}else if("subtitle"===e.type)if(r.byteLength){if(void 0===this.initPTS)return void this.unparsedVttFrags.push(t);var n=e.decryptdata;null!=n&&null!=n.key&&"AES-128"===n.method||this._parseVTTs(e,r)}else this.hls.trigger(l.a.SUBTITLE_FRAG_PROCESSED,{success:!1,frag:e})},e.prototype._parseVTTs=function(t,e){var r=this.vttCCs;r[t.cc]||(r[t.cc]={start:t.start,prevCC:this.prevCC,new:!0},this.prevCC=t.cc);var i=this.textTracks,a=this.hls;h.a.parse(e,this.initPTS,r,t.cc,function(e){var r=i[t.trackId];if("disabled"===r.mode)return void a.trigger(l.a.SUBTITLE_FRAG_PROCESSED,{success:!1,frag:t});e.forEach(function(t){if(!r.cues.getCueById(t.id))try{r.addCue(t)}catch(i){var e=new window.TextTrackCue(t.startTime,t.endTime,t.text);e.id=t.id,r.addCue(e)}}),a.trigger(l.a.SUBTITLE_FRAG_PROCESSED,{success:!0,frag:t})},function(e){f.b.log("Failed to parse VTT cue: "+e),a.trigger(l.a.SUBTITLE_FRAG_PROCESSED,{success:!1,frag:t})})},e.prototype.onFragDecrypted=function(t){var e=t.payload,r=t.frag;if("subtitle"===r.type){if(void 0===this.initPTS)return void this.unparsedVttFrags.push(t);this._parseVTTs(r,e)}},e.prototype.onFragParsingUserdata=function(t){if(this.enabled&&this.config.enableCEA708Captions)for(var e=0;e<t.samples.length;e++){var r=this.extractCea608Data(t.samples[e].bytes);this.cea608Parser.addData(t.samples[e].pts,r)}},e.prototype.extractCea608Data=function(t){for(var e=31&t[0],r=2,i=void 0,a=void 0,n=void 0,o=void 0,s=void 0,l=[],u=0;u<e;u++)i=t[r++],a=127&t[r++],n=127&t[r++],o=0!=(4&i),s=3&i,0===a&&0===n||o&&0===s&&(l.push(a),l.push(n));return l},e}(u.a);e.a=v},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a={42:225,92:233,94:237,95:243,96:250,123:231,124:247,125:209,126:241,127:9608,128:174,129:176,130:189,131:191,132:8482,133:162,134:163,135:9834,136:224,137:32,138:232,139:226,140:234,141:238,142:244,143:251,144:193,145:201,146:211,147:218,148:220,149:252,150:8216,151:161,152:42,153:8217,154:9473,155:169,156:8480,157:8226,158:8220,159:8221,160:192,161:194,162:199,163:200,164:202,165:203,166:235,167:206,168:207,169:239,170:212,171:217,172:249,173:219,174:171,175:187,176:195,177:227,178:205,179:204,180:236,181:210,182:242,183:213,184:245,185:123,186:125,187:92,188:94,189:95,190:124,191:8764,192:196,193:228,194:214,195:246,196:223,197:165,198:164,199:9475,200:197,201:229,202:216,203:248,204:9487,205:9491,206:9495,207:9499},n=function(t){var e=t;return a.hasOwnProperty(t)&&(e=a[t]),String.fromCharCode(e)},o=15,s=100,l={17:1,18:3,21:5,22:7,23:9,16:11,19:12,20:14},u={17:2,18:4,21:6,22:8,23:10,19:13,20:15},d={25:1,26:3,29:5,30:7,31:9,24:11,27:12,28:14},c={25:2,26:4,29:6,30:8,31:10,27:13,28:15},h=["white","green","blue","cyan","red","yellow","magenta","black","transparent"],f={verboseFilter:{DATA:3,DEBUG:3,INFO:2,WARNING:2,TEXT:1,ERROR:0},time:null,verboseLevel:0,setTime:function(t){this.time=t},log:function(t,e){var r=this.verboseFilter[t];this.verboseLevel>=r&&console.log(this.time+" ["+t+"] "+e)}},p=function(t){for(var e=[],r=0;r<t.length;r++)e.push(t[r].toString(16));return e},v=function(){function t(e,r,a,n,o){i(this,t),this.foreground=e||"white",this.underline=r||!1,this.italics=a||!1,this.background=n||"black",this.flash=o||!1}return t.prototype.reset=function(){this.foreground="white",this.underline=!1,this.italics=!1,this.background="black",this.flash=!1},t.prototype.setStyles=function(t){for(var e=["foreground","underline","italics","background","flash"],r=0;r<e.length;r++){var i=e[r];t.hasOwnProperty(i)&&(this[i]=t[i])}},t.prototype.isDefault=function(){return"white"===this.foreground&&!this.underline&&!this.italics&&"black"===this.background&&!this.flash},t.prototype.equals=function(t){return this.foreground===t.foreground&&this.underline===t.underline&&this.italics===t.italics&&this.background===t.background&&this.flash===t.flash},t.prototype.copy=function(t){this.foreground=t.foreground,this.underline=t.underline,this.italics=t.italics,this.background=t.background,this.flash=t.flash},t.prototype.toString=function(){return"color="+this.foreground+", underline="+this.underline+", italics="+this.italics+", background="+this.background+", flash="+this.flash},t}(),g=function(){function t(e,r,a,n,o,s){i(this,t),this.uchar=e||" ",this.penState=new v(r,a,n,o,s)}return t.prototype.reset=function(){this.uchar=" ",this.penState.reset()},t.prototype.setChar=function(t,e){this.uchar=t,this.penState.copy(e)},t.prototype.setPenState=function(t){this.penState.copy(t)},t.prototype.equals=function(t){return this.uchar===t.uchar&&this.penState.equals(t.penState)},t.prototype.copy=function(t){this.uchar=t.uchar,this.penState.copy(t.penState)},t.prototype.isEmpty=function(){return" "===this.uchar&&this.penState.isDefault()},t}(),y=function(){function t(){i(this,t),this.chars=[];for(var e=0;e<s;e++)this.chars.push(new g);this.pos=0,this.currPenState=new v}return t.prototype.equals=function(t){for(var e=!0,r=0;r<s;r++)if(!this.chars[r].equals(t.chars[r])){e=!1;break}return e},t.prototype.copy=function(t){for(var e=0;e<s;e++)this.chars[e].copy(t.chars[e])},t.prototype.isEmpty=function(){for(var t=!0,e=0;e<s;e++)if(!this.chars[e].isEmpty()){t=!1;break}return t},t.prototype.setCursor=function(t){this.pos!==t&&(this.pos=t),this.pos<0?(f.log("ERROR","Negative cursor position "+this.pos),this.pos=0):this.pos>s&&(f.log("ERROR","Too large cursor position "+this.pos),this.pos=s)},t.prototype.moveCursor=function(t){var e=this.pos+t;if(t>1)for(var r=this.pos+1;r<e+1;r++)this.chars[r].setPenState(this.currPenState);this.setCursor(e)},t.prototype.backSpace=function(){this.moveCursor(-1),this.chars[this.pos].setChar(" ",this.currPenState)},t.prototype.insertChar=function(t){t>=144&&this.backSpace();var e=n(t);if(this.pos>=s)return void f.log("ERROR","Cannot insert "+t.toString(16)+" ("+e+") at position "+this.pos+". Skipping it!");this.chars[this.pos].setChar(e,this.currPenState),this.moveCursor(1)},t.prototype.clearFromPos=function(t){var e=void 0;for(e=t;e<s;e++)this.chars[e].reset()},t.prototype.clear=function(){this.clearFromPos(0),this.pos=0,this.currPenState.reset()},t.prototype.clearToEndOfRow=function(){this.clearFromPos(this.pos)},t.prototype.getTextString=function(){for(var t=[],e=!0,r=0;r<s;r++){var i=this.chars[r].uchar;" "!==i&&(e=!1),t.push(i)}return e?"":t.join("")},t.prototype.setPenStyles=function(t){this.currPenState.setStyles(t),this.chars[this.pos].setPenState(this.currPenState)},t}(),m=function(){function t(){i(this,t),this.rows=[];for(var e=0;e<o;e++)this.rows.push(new y);this.currRow=o-1,this.nrRollUpRows=null,this.reset()}return t.prototype.reset=function(){for(var t=0;t<o;t++)this.rows[t].clear();this.currRow=o-1},t.prototype.equals=function(t){for(var e=!0,r=0;r<o;r++)if(!this.rows[r].equals(t.rows[r])){e=!1;break}return e},t.prototype.copy=function(t){for(var e=0;e<o;e++)this.rows[e].copy(t.rows[e])},t.prototype.isEmpty=function(){for(var t=!0,e=0;e<o;e++)if(!this.rows[e].isEmpty()){t=!1;break}return t},t.prototype.backSpace=function(){this.rows[this.currRow].backSpace()},t.prototype.clearToEndOfRow=function(){this.rows[this.currRow].clearToEndOfRow()},t.prototype.insertChar=function(t){this.rows[this.currRow].insertChar(t)},t.prototype.setPen=function(t){this.rows[this.currRow].setPenStyles(t)},t.prototype.moveCursor=function(t){this.rows[this.currRow].moveCursor(t)},t.prototype.setCursor=function(t){f.log("INFO","setCursor: "+t),this.rows[this.currRow].setCursor(t)},t.prototype.setPAC=function(t){f.log("INFO","pacData = "+JSON.stringify(t));var e=t.row-1;if(this.nrRollUpRows&&e<this.nrRollUpRows-1&&(e=this.nrRollUpRows-1),this.nrRollUpRows&&this.currRow!==e){for(var r=0;r<o;r++)this.rows[r].clear();var i=this.currRow+1-this.nrRollUpRows,a=this.lastOutputScreen;if(a){var n=a.rows[i].cueStartTime;if(n&&n<f.time)for(var s=0;s<this.nrRollUpRows;s++)this.rows[e-this.nrRollUpRows+s+1].copy(a.rows[i+s])}}this.currRow=e;var l=this.rows[this.currRow];if(null!==t.indent){var u=t.indent,d=Math.max(u-1,0);l.setCursor(t.indent),t.color=l.chars[d].penState.foreground}var c={foreground:t.color,underline:t.underline,italics:t.italics,background:"black",flash:!1};this.setPen(c)},t.prototype.setBkgData=function(t){f.log("INFO","bkgData = "+JSON.stringify(t)),this.backSpace(),this.setPen(t),this.insertChar(32)},t.prototype.setRollUpRows=function(t){this.nrRollUpRows=t},t.prototype.rollUp=function(){if(null===this.nrRollUpRows)return void f.log("DEBUG","roll_up but nrRollUpRows not set yet");f.log("TEXT",this.getDisplayText());var t=this.currRow+1-this.nrRollUpRows,e=this.rows.splice(t,1)[0];e.clear(),this.rows.splice(this.currRow,0,e),f.log("INFO","Rolling up")},t.prototype.getDisplayText=function(t){t=t||!1;for(var e=[],r="",i=-1,a=0;a<o;a++){var n=this.rows[a].getTextString();n&&(i=a+1,t?e.push("Row "+i+": '"+n+"'"):e.push(n.trim()))}return e.length>0&&(r=t?"["+e.join(" | ")+"]":e.join("\n")),r},t.prototype.getTextAndFormat=function(){return this.rows},t}(),b=function(){function t(e,r){i(this,t),this.chNr=e,this.outputFilter=r,this.mode=null,this.verbose=0,this.displayedMemory=new m,this.nonDisplayedMemory=new m,this.lastOutputScreen=new m,this.currRollUpRow=this.displayedMemory.rows[o-1],this.writeScreen=this.displayedMemory,this.mode=null,this.cueStartTime=null}return t.prototype.reset=function(){this.mode=null,this.displayedMemory.reset(),this.nonDisplayedMemory.reset(),this.lastOutputScreen.reset(),this.currRollUpRow=this.displayedMemory.rows[o-1],this.writeScreen=this.displayedMemory,this.mode=null,this.cueStartTime=null,this.lastCueEndTime=null},t.prototype.getHandler=function(){return this.outputFilter},t.prototype.setHandler=function(t){this.outputFilter=t},t.prototype.setPAC=function(t){this.writeScreen.setPAC(t)},t.prototype.setBkgData=function(t){this.writeScreen.setBkgData(t)},t.prototype.setMode=function(t){t!==this.mode&&(this.mode=t,f.log("INFO","MODE="+t),"MODE_POP-ON"===this.mode?this.writeScreen=this.nonDisplayedMemory:(this.writeScreen=this.displayedMemory,this.writeScreen.reset()),"MODE_ROLL-UP"!==this.mode&&(this.displayedMemory.nrRollUpRows=null,this.nonDisplayedMemory.nrRollUpRows=null),this.mode=t)},t.prototype.insertChars=function(t){for(var e=0;e<t.length;e++)this.writeScreen.insertChar(t[e]);var r=this.writeScreen===this.displayedMemory?"DISP":"NON_DISP";f.log("INFO",r+": "+this.writeScreen.getDisplayText(!0)),"MODE_PAINT-ON"!==this.mode&&"MODE_ROLL-UP"!==this.mode||(f.log("TEXT","DISPLAYED: "+this.displayedMemory.getDisplayText(!0)),this.outputDataUpdate())},t.prototype.ccRCL=function(){f.log("INFO","RCL - Resume Caption Loading"),this.setMode("MODE_POP-ON")},t.prototype.ccBS=function(){f.log("INFO","BS - BackSpace"),"MODE_TEXT"!==this.mode&&(this.writeScreen.backSpace(),this.writeScreen===this.displayedMemory&&this.outputDataUpdate())},t.prototype.ccAOF=function(){},t.prototype.ccAON=function(){},t.prototype.ccDER=function(){f.log("INFO","DER- Delete to End of Row"),this.writeScreen.clearToEndOfRow(),this.outputDataUpdate()},t.prototype.ccRU=function(t){f.log("INFO","RU("+t+") - Roll Up"),this.writeScreen=this.displayedMemory,this.setMode("MODE_ROLL-UP"),this.writeScreen.setRollUpRows(t)},t.prototype.ccFON=function(){f.log("INFO","FON - Flash On"),this.writeScreen.setPen({flash:!0})},t.prototype.ccRDC=function(){f.log("INFO","RDC - Resume Direct Captioning"),this.setMode("MODE_PAINT-ON")},t.prototype.ccTR=function(){f.log("INFO","TR"),this.setMode("MODE_TEXT")},t.prototype.ccRTD=function(){f.log("INFO","RTD"),this.setMode("MODE_TEXT")},t.prototype.ccEDM=function(){f.log("INFO","EDM - Erase Displayed Memory"),this.displayedMemory.reset(),this.outputDataUpdate(!0)},t.prototype.ccCR=function(){f.log("CR - Carriage Return"),this.writeScreen.rollUp(),this.outputDataUpdate(!0)},t.prototype.ccENM=function(){f.log("INFO","ENM - Erase Non-displayed Memory"),this.nonDisplayedMemory.reset()},t.prototype.ccEOC=function(){if(f.log("INFO","EOC - End Of Caption"),"MODE_POP-ON"===this.mode){var t=this.displayedMemory;this.displayedMemory=this.nonDisplayedMemory,this.nonDisplayedMemory=t,this.writeScreen=this.nonDisplayedMemory,f.log("TEXT","DISP: "+this.displayedMemory.getDisplayText())}this.outputDataUpdate(!0)},t.prototype.ccTO=function(t){f.log("INFO","TO("+t+") - Tab Offset"),this.writeScreen.moveCursor(t)},t.prototype.ccMIDROW=function(t){var e={flash:!1};if(e.underline=t%2==1,e.italics=t>=46,e.italics)e.foreground="white";else{var r=Math.floor(t/2)-16,i=["white","green","blue","cyan","red","yellow","magenta"];e.foreground=i[r]}f.log("INFO","MIDROW: "+JSON.stringify(e)),this.writeScreen.setPen(e)},t.prototype.outputDataUpdate=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],e=f.time;null!==e&&this.outputFilter&&(null!==this.cueStartTime||this.displayedMemory.isEmpty()?this.displayedMemory.equals(this.lastOutputScreen)||(this.outputFilter.newCue&&(this.outputFilter.newCue(this.cueStartTime,e,this.lastOutputScreen),!0===t&&this.outputFilter.dispatchCue&&this.outputFilter.dispatchCue()),this.cueStartTime=this.displayedMemory.isEmpty()?null:e):this.cueStartTime=e,this.lastOutputScreen.copy(this.displayedMemory))},t.prototype.cueSplitAtTime=function(t){this.outputFilter&&(this.displayedMemory.isEmpty()||(this.outputFilter.newCue&&this.outputFilter.newCue(this.cueStartTime,t,this.displayedMemory),this.cueStartTime=t))},t}(),E=function(){function t(e,r,a){i(this,t),this.field=e||1,this.outputs=[r,a],this.channels=[new b(1,r),new b(2,a)],this.currChNr=-1,this.lastCmdA=null,this.lastCmdB=null,this.bufferedData=[],this.startTime=null,this.lastTime=null,this.dataCounters={padding:0,char:0,cmd:0,other:0}}return t.prototype.getHandler=function(t){return this.channels[t].getHandler()},t.prototype.setHandler=function(t,e){this.channels[t].setHandler(e)},t.prototype.addData=function(t,e){var r=void 0,i=void 0,a=void 0,n=!1;this.lastTime=t,f.setTime(t);for(var o=0;o<e.length;o+=2)if(i=127&e[o],a=127&e[o+1],0!==i||0!==a){if(f.log("DATA","["+p([e[o],e[o+1]])+"] -> ("+p([i,a])+")"),r=this.parseCmd(i,a),r||(r=this.parseMidrow(i,a)),r||(r=this.parsePAC(i,a)),r||(r=this.parseBackgroundAttributes(i,a)),!r&&(n=this.parseChars(i,a)))if(this.currChNr&&this.currChNr>=0){var s=this.channels[this.currChNr-1];s.insertChars(n)}else f.log("WARNING","No channel found yet. TEXT-MODE?");r?this.dataCounters.cmd+=2:n?this.dataCounters.char+=2:(this.dataCounters.other+=2,f.log("WARNING","Couldn't parse cleaned data "+p([i,a])+" orig: "+p([e[o],e[o+1]])))}else this.dataCounters.padding+=2},t.prototype.parseCmd=function(t,e){var r=null,i=(20===t||28===t)&&e>=32&&e<=47,a=(23===t||31===t)&&e>=33&&e<=35;if(!i&&!a)return!1;if(t===this.lastCmdA&&e===this.lastCmdB)return this.lastCmdA=null,this.lastCmdB=null,f.log("DEBUG","Repeated command ("+p([t,e])+") is dropped"),!0;r=20===t||23===t?1:2;var n=this.channels[r-1];return 20===t||28===t?32===e?n.ccRCL():33===e?n.ccBS():34===e?n.ccAOF():35===e?n.ccAON():36===e?n.ccDER():37===e?n.ccRU(2):38===e?n.ccRU(3):39===e?n.ccRU(4):40===e?n.ccFON():41===e?n.ccRDC():42===e?n.ccTR():43===e?n.ccRTD():44===e?n.ccEDM():45===e?n.ccCR():46===e?n.ccENM():47===e&&n.ccEOC():n.ccTO(e-32),this.lastCmdA=t,this.lastCmdB=e,this.currChNr=r,!0},t.prototype.parseMidrow=function(t,e){var r=null;if((17===t||25===t)&&e>=32&&e<=47){if((r=17===t?1:2)!==this.currChNr)return f.log("ERROR","Mismatch channel in midrow parsing"),!1;return this.channels[r-1].ccMIDROW(e),f.log("DEBUG","MIDROW ("+p([t,e])+")"),!0}return!1},t.prototype.parsePAC=function(t,e){var r=null,i=null,a=(t>=17&&t<=23||t>=25&&t<=31)&&e>=64&&e<=127,n=(16===t||24===t)&&e>=64&&e<=95;if(!a&&!n)return!1;if(t===this.lastCmdA&&e===this.lastCmdB)return this.lastCmdA=null,this.lastCmdB=null,!0;r=t<=23?1:2,i=e>=64&&e<=95?1===r?l[t]:d[t]:1===r?u[t]:c[t];var o=this.interpretPAC(i,e);return this.channels[r-1].setPAC(o),this.lastCmdA=t,this.lastCmdB=e,this.currChNr=r,!0},t.prototype.interpretPAC=function(t,e){var r=e,i={color:null,italics:!1,indent:null,underline:!1,row:t};return r=e>95?e-96:e-64,i.underline=1==(1&r),r<=13?i.color=["white","green","blue","cyan","red","yellow","magenta","white"][Math.floor(r/2)]:r<=15?(i.italics=!0,i.color="white"):i.indent=4*Math.floor((r-16)/2),i},t.prototype.parseChars=function(t,e){var r=null,i=null,a=null;if(t>=25?(r=2,a=t-8):(r=1,a=t),a>=17&&a<=19){var o=e;o=17===a?e+80:18===a?e+112:e+144,f.log("INFO","Special char '"+n(o)+"' in channel "+r),i=[o]}else t>=32&&t<=127&&(i=0===e?[t]:[t,e]);if(i){var s=p(i);f.log("DEBUG","Char codes =  "+s.join(",")),this.lastCmdA=null,this.lastCmdB=null}return i},t.prototype.parseBackgroundAttributes=function(t,e){var r=void 0,i=void 0,a=void 0,n=void 0,o=(16===t||24===t)&&e>=32&&e<=47,s=(23===t||31===t)&&e>=45&&e<=47;return!(!o&&!s)&&(r={},16===t||24===t?(i=Math.floor((e-32)/2),r.background=h[i],e%2==1&&(r.background=r.background+"_semi")):45===e?r.background="transparent":(r.foreground="black",47===e&&(r.underline=!0)),a=t<24?1:2,n=this.channels[a-1],n.setBkgData(r),this.lastCmdA=null,this.lastCmdB=null,!0)},t.prototype.reset=function(){for(var t=0;t<this.channels.length;t++)this.channels[t]&&this.channels[t].reset();this.lastCmdA=null,this.lastCmdB=null},t.prototype.cueSplitAtTime=function(t){for(var e=0;e<this.channels.length;e++)this.channels[e]&&this.channels[e].cueSplitAtTime(t)},t}();e.a=E},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=function(){function t(e,r){i(this,t),this.timelineController=e,this.trackName=r,this.startTime=null,this.endTime=null,this.screen=null}return t.prototype.dispatchCue=function(){null!==this.startTime&&(this.timelineController.addCues(this.trackName,this.startTime,this.endTime,this.screen),this.startTime=null)},t.prototype.newCue=function(t,e,r){(null===this.startTime||this.startTime>t)&&(this.startTime=t),this.endTime=e,this.screen=r,this.timelineController.createCaptionsTrack(this.trackName)},t}();e.a=a},function(t,e,r){"use strict";var i=r(26),a=r(5),n=function(t,e,r){return t.substr(r||0,e.length)===e},o=function(t){var e=parseInt(t.substr(-3)),r=parseInt(t.substr(-6,2)),i=parseInt(t.substr(-9,2)),a=t.length>9?parseInt(t.substr(0,t.indexOf(":"))):0;return isNaN(e)||isNaN(r)||isNaN(i)||isNaN(a)?-1:(e+=1e3*r,e+=6e4*i,e+=36e5*a)},s=function(t){for(var e=5381,r=t.length;r;)e=33*e^t.charCodeAt(--r);return(e>>>0).toString()},l=function(t,e,r){var i=t[e],a=t[i.prevCC];if(!a||!a.new&&i.new)return t.ccOffset=t.presentationOffset=i.start,void(i.new=!1);for(;a&&a.new;)t.ccOffset+=i.start-a.start,i.new=!1,i=a,a=t[i.prevCC];t.presentationOffset=r},u={parse:function(t,e,r,u,d,c){var h=/\r\n|\n\r|\n|\r/g,f=Object(a.b)(new Uint8Array(t)).trim().replace(h,"\n").split("\n"),p="00:00.000",v=0,g=0,y=0,m=[],b=void 0,E=!0,T=new i.a;T.oncue=function(t){var e=r[u],i=r.ccOffset;e&&e.new&&(void 0!==g?i=r.ccOffset=e.start:l(r,u,y)),y&&(i=y+r.ccOffset-r.presentationOffset),t.startTime+=i-g,t.endTime+=i-g,t.id=s(t.startTime.toString())+s(t.endTime.toString())+s(t.text),t.text=decodeURIComponent(encodeURIComponent(t.text)),t.endTime>0&&m.push(t)},T.onparsingerror=function(t){b=t},T.onflush=function(){if(b&&c)return void c(b);d(m)},f.forEach(function(t){if(E){if(n(t,"X-TIMESTAMP-MAP=")){E=!1,t.substr(16).split(",").forEach(function(t){n(t,"LOCAL:")?p=t.substr(6):n(t,"MPEGTS:")&&(v=parseInt(t.substr(7)))});try{e=e<0?e+8589934592:e,v-=e,g=o(p)/1e3,y=v/9e4,-1===g&&(b=new Error("Malformed X-TIMESTAMP-MAP: "+t))}catch(e){b=new Error("Malformed X-TIMESTAMP-MAP: "+t)}return}""===t&&(E=!1)}T.parse(t+"\n")}),T.flush()}};e.a=u},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function o(t){for(var e=[],r=0;r<t.length;r++)"subtitles"===t[r].kind&&e.push(t[r]);return e}var s=r(1),l=r(3),u=r(0),d=function(){function t(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,r,i){return r&&t(e.prototype,r),i&&t(e,i),e}}(),c=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,s.a.MEDIA_ATTACHED,s.a.MEDIA_DETACHING,s.a.MANIFEST_LOADING,s.a.MANIFEST_LOADED,s.a.SUBTITLE_TRACK_LOADED));return n.tracks=[],n.trackId=-1,n.media=void 0,n.subtitleDisplay=!1,n}return n(e,t),e.prototype._onTextTracksChanged=function(){if(this.media){for(var t=-1,e=o(this.media.textTracks),r=0;r<e.length;r++)if("hidden"===e[r].mode)t=r;else if("showing"===e[r].mode){t=r;break}this.subtitleTrack=t}},e.prototype.destroy=function(){l.a.prototype.destroy.call(this)},e.prototype.onMediaAttached=function(t){var e=this;this.media=t.media,this.media&&(void 0!==this.queuedDefaultTrack&&(this.subtitleTrack=this.queuedDefaultTrack,delete this.queuedDefaultTrack),this.trackChangeListener=this._onTextTracksChanged.bind(this),this.useTextTrackPolling=!(this.media.textTracks&&"onchange"in this.media.textTracks),this.useTextTrackPolling?this.subtitlePollingInterval=setInterval(function(){e.trackChangeListener()},500):this.media.textTracks.addEventListener("change",this.trackChangeListener))},e.prototype.onMediaDetaching=function(){this.media&&(this.useTextTrackPolling?clearInterval(this.subtitlePollingInterval):this.media.textTracks.removeEventListener("change",this.trackChangeListener),this.media=void 0)},e.prototype.onManifestLoading=function(){this.tracks=[],this.trackId=-1},e.prototype.onManifestLoaded=function(t){var e=this,r=t.subtitles||[];this.tracks=r,this.trackId=-1,this.hls.trigger(s.a.SUBTITLE_TRACKS_UPDATED,{subtitleTracks:r}),r.forEach(function(t){t.default&&(e.media?e.subtitleTrack=t.id:e.queuedDefaultTrack=t.id)})},e.prototype.onTick=function(){var t=this.trackId,e=this.tracks[t];if(e){var r=e.details;void 0!==r&&!0!==r.live||(u.b.log("(re)loading playlist for subtitle track "+t),this.hls.trigger(s.a.SUBTITLE_TRACK_LOADING,{url:e.url,id:t}))}},e.prototype.onSubtitleTrackLoaded=function(t){var e=this;t.id<this.tracks.length&&(u.b.log("subtitle track "+t.id+" loaded"),this.tracks[t.id].details=t.details,t.details.live&&!this.timer&&(this.timer=setInterval(function(){e.onTick()},1e3*t.details.targetduration,this)),!t.details.live&&this.timer&&(clearInterval(this.timer),this.timer=null))},e.prototype.setSubtitleTrackInternal=function(t){if(!(t<-1||t>=this.tracks.length)){this.timer&&(clearInterval(this.timer),this.timer=null);var e=o(this.media.textTracks);if(-1!==this.trackId&&(e[this.trackId].mode="disabled"),this.trackId=t,u.b.log("switching to subtitle track "+t),this.hls.trigger(s.a.SUBTITLE_TRACK_SWITCH,{id:t}),-1!==t){var r=this.tracks[t];t<e.length&&(e[t].mode=this.subtitleDisplay?"showing":"hidden");var i=r.details;void 0!==i&&!0!==i.live||(u.b.log("(re)loading playlist for subtitle track "+t),this.hls.trigger(s.a.SUBTITLE_TRACK_LOADING,{url:r.url,id:t}))}}},d(e,[{key:"subtitleTracks",get:function(){return this.tracks}},{key:"subtitleTrack",get:function(){return this.trackId},set:function(t){this.trackId!==t&&this.setSubtitleTrackInternal(t)}}]),e}(l.a);e.a=c},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(1),s=r(0),l=r(11),u=r(13),d={STOPPED:"STOPPED",IDLE:"IDLE",KEY_LOADING:"KEY_LOADING",FRAG_LOADING:"FRAG_LOADING"},c=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,o.a.MEDIA_ATTACHED,o.a.ERROR,o.a.KEY_LOADED,o.a.FRAG_LOADED,o.a.SUBTITLE_TRACKS_UPDATED,o.a.SUBTITLE_TRACK_SWITCH,o.a.SUBTITLE_TRACK_LOADED,o.a.SUBTITLE_FRAG_PROCESSED));return n.config=r.config,n.vttFragSNsProcessed={},n.vttFragQueues=void 0,n.currentlyProcessing=null,n.state=d.STOPPED,n.currentTrackId=-1,n.decrypter=new l.a(r.observer,r.config),n}return n(e,t),e.prototype.onHandlerDestroyed=function(){this.state=d.STOPPED},e.prototype.clearVttFragQueues=function(){var t=this;this.vttFragQueues={},this.tracks.forEach(function(e){t.vttFragQueues[e.id]=[]})},e.prototype.nextFrag=function(){if(null===this.currentlyProcessing&&this.currentTrackId>-1&&this.vttFragQueues[this.currentTrackId].length){var t=this.currentlyProcessing=this.vttFragQueues[this.currentTrackId].shift();this.fragCurrent=t,this.hls.trigger(o.a.FRAG_LOADING,{frag:t}),this.state=d.FRAG_LOADING}},e.prototype.onSubtitleFragProcessed=function(t){t.success&&this.vttFragSNsProcessed[t.frag.trackId].push(t.frag.sn),this.currentlyProcessing=null,this.state=d.IDLE,this.nextFrag()},e.prototype.onMediaAttached=function(){this.state=d.IDLE},e.prototype.onError=function(t){var e=t.frag;e&&"subtitle"!==e.type||this.currentlyProcessing&&(this.currentlyProcessing=null,this.nextFrag())},e.prototype.doTick=function(){var t=this;switch(this.state){case d.IDLE:var e=this.tracks,r=this.currentTrackId,i=this.vttFragSNsProcessed[r],a=this.vttFragQueues[r],n=this.currentlyProcessing?this.currentlyProcessing.sn:-1,l=function(t){return i.indexOf(t.sn)>-1},u=function(t){return a.some(function(e){return e.sn===t.sn})};if(!e)break;var c;if(r<e.length&&(c=e[r].details),void 0===c)break;c.fragments.forEach(function(e){l(e)||e.sn===n||u(e)||(e.decryptdata&&null!=e.decryptdata.uri&&null==e.decryptdata.key?(s.b.log("Loading key for "+e.sn),t.state=d.KEY_LOADING,t.hls.trigger(o.a.KEY_LOADING,{frag:e})):(e.trackId=r,a.push(e),t.nextFrag()))})}},e.prototype.onSubtitleTracksUpdated=function(t){var e=this;s.b.log("subtitle tracks updated"),this.tracks=t.subtitleTracks,this.clearVttFragQueues(),this.vttFragSNsProcessed={},this.tracks.forEach(function(t){e.vttFragSNsProcessed[t.id]=[]})},e.prototype.onSubtitleTrackSwitch=function(t){if(this.currentTrackId=t.id,-1!==this.currentTrackId){void 0!==this.tracks[this.currentTrackId].details&&this.tick()}},e.prototype.onSubtitleTrackLoaded=function(){this.tick()},e.prototype.onKeyLoaded=function(){this.state===d.KEY_LOADING&&(this.state=d.IDLE,this.tick())},e.prototype.onFragLoaded=function(t){var e=this.fragCurrent,r=t.frag.decryptdata,i=t.frag,a=this.hls;if(this.state===d.FRAG_LOADING&&e&&"subtitle"===t.frag.type&&e.sn===t.frag.sn&&t.payload.byteLength>0&&null!=r&&null!=r.key&&"AES-128"===r.method){var n=void 0;try{n=performance.now()}catch(t){n=Date.now()}this.decrypter.decrypt(t.payload,r.key.buffer,r.iv.buffer,function(t){var e=void 0;try{e=performance.now()}catch(t){e=Date.now()}a.trigger(o.a.FRAG_DECRYPTED,{frag:i,payload:t,stats:{tstart:n,tdecrypt:e}})})}},e}(u.a);e.a=c},function(t,e,r){"use strict";function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function n(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}var o=r(3),s=r(1),l=r(2),u=r(0),d=function(){function t(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,r,i){return r&&t(e.prototype,r),i&&t(e,i),e}}(),c={WIDEVINE:"com.widevine.alpha",PLAYREADY:"com.microsoft.playready"},h=function(t,e,r){var i={videoCapabilities:[]};return e.forEach(function(t){i.videoCapabilities.push({contentType:'video/mp4; codecs="'+t+'"'})}),[i]},f=function(t,e,r){switch(t){case c.WIDEVINE:return h(0,r);default:throw Error("Unknown key-system: "+t)}},p=function(t){function e(r){i(this,e);var n=a(this,t.call(this,r,s.a.MEDIA_ATTACHED,s.a.MANIFEST_PARSED));return n._widevineLicenseUrl=r.config.widevineLicenseUrl,n._licenseXhrSetup=r.config.licenseXhrSetup,n._emeEnabled=r.config.emeEnabled,n._requestMediaKeySystemAccess=r.config.requestMediaKeySystemAccessFunc,n._mediaKeysList=[],n._media=null,n._hasSetMediaKeys=!1,n._isMediaEncrypted=!1,n._requestLicenseFailureCount=0,n}return n(e,t),e.prototype.getLicenseServerUrl=function(t){var e=void 0;switch(t){case c.WIDEVINE:e=this._widevineLicenseUrl;break;default:e=null}return e||(u.b.error('No license server URL configured for key-system "'+t+'"'),this.hls.trigger(s.a.ERROR,{type:l.b.KEY_SYSTEM_ERROR,details:l.a.KEY_SYSTEM_LICENSE_REQUEST_FAILED,fatal:!0})),e},e.prototype._attemptKeySystemAccess=function(t,e,r){var i=this,a=f(t,0,r);if(!a)return void u.b.warn("Can not create config for key-system (maybe because platform is not supported):",t);u.b.log("Requesting encrypted media key-system access"),this.requestMediaKeySystemAccess(t,a).then(function(e){i._onMediaKeySystemAccessObtained(t,e)}).catch(function(e){u.b.error('Failed to obtain key-system "'+t+'" access:',e)})},e.prototype._onMediaKeySystemAccessObtained=function(t,e){var r=this;u.b.log('Access for key-system "'+t+'" obtained');var i={mediaKeys:null,mediaKeysSession:null,mediaKeysSessionInitialized:!1,mediaKeySystemAccess:e,mediaKeySystemDomain:t};this._mediaKeysList.push(i),e.createMediaKeys().then(function(e){i.mediaKeys=e,u.b.log('Media-keys created for key-system "'+t+'"'),r._onMediaKeysCreated()}).catch(function(t){u.b.error("Failed to create media-keys:",t)})},e.prototype._onMediaKeysCreated=function(){var t=this;this._mediaKeysList.forEach(function(e){e.mediaKeysSession||(e.mediaKeysSession=e.mediaKeys.createSession(),t._onNewMediaKeySession(e.mediaKeysSession))})},e.prototype._onNewMediaKeySession=function(t){var e=this;u.b.log("New key-system session "+t.sessionId),t.addEventListener("message",function(r){e._onKeySessionMessage(t,r.message)},!1)},e.prototype._onKeySessionMessage=function(t,e){u.b.log("Got EME message event, creating license request"),this._requestLicense(e,function(e){u.b.log("Received license data, updating key-session"),t.update(e)})},e.prototype._onMediaEncrypted=function(t,e){u.b.log('Media is encrypted using "'+t+'" init data type'),this._isMediaEncrypted=!0,this._mediaEncryptionInitDataType=t,this._mediaEncryptionInitData=e,this._attemptSetMediaKeys(),this._generateRequestWithPreferredKeySession()},e.prototype._attemptSetMediaKeys=function(){if(!this._hasSetMediaKeys){var t=this._mediaKeysList[0];if(!t||!t.mediaKeys)return u.b.error("Fatal: Media is encrypted but no CDM access or no keys have been obtained yet"),void this.hls.trigger(s.a.ERROR,{type:l.b.KEY_SYSTEM_ERROR,details:l.a.KEY_SYSTEM_NO_KEYS,fatal:!0});u.b.log("Setting keys for encrypted media"),this._media.setMediaKeys(t.mediaKeys),this._hasSetMediaKeys=!0}},e.prototype._generateRequestWithPreferredKeySession=function(){var t=this,e=this._mediaKeysList[0];if(!e)return u.b.error("Fatal: Media is encrypted but not any key-system access has been obtained yet"),void this.hls.trigger(s.a.ERROR,{type:l.b.KEY_SYSTEM_ERROR,details:l.a.KEY_SYSTEM_NO_ACCESS,fatal:!0});if(e.mediaKeysSessionInitialized)return void u.b.warn("Key-Session already initialized but requested again");var r=e.mediaKeysSession;r||(u.b.error("Fatal: Media is encrypted but no key-session existing"),this.hls.trigger(s.a.ERROR,{type:l.b.KEY_SYSTEM_ERROR,details:l.a.KEY_SYSTEM_NO_SESSION,fatal:!0}));var i=this._mediaEncryptionInitDataType,a=this._mediaEncryptionInitData;u.b.log('Generating key-session request for "'+i+'" init data type'),e.mediaKeysSessionInitialized=!0,r.generateRequest(i,a).then(function(){u.b.debug("Key-session generation succeeded")}).catch(function(e){u.b.error("Error generating key-session request:",e),t.hls.trigger(s.a.ERROR,{type:l.b.KEY_SYSTEM_ERROR,details:l.a.KEY_SYSTEM_NO_SESSION,fatal:!1})})},e.prototype._createLicenseXhr=function(t,e,r){var i=new XMLHttpRequest,a=this._licenseXhrSetup;try{if(a)try{a(i,t)}catch(e){i.open("POST",t,!0),a(i,t)}i.readyState||i.open("POST",t,!0)}catch(t){return u.b.error("Error setting up key-system license XHR",t),void this.hls.trigger(s.a.ERROR,{type:l.b.KEY_SYSTEM_ERROR,details:l.a.KEY_SYSTEM_LICENSE_REQUEST_FAILED,fatal:!0})}return i.responseType="arraybuffer",i.onreadystatechange=this._onLicenseRequestReadyStageChange.bind(this,i,t,e,r),i},e.prototype._onLicenseRequestReadyStageChange=function(t,e,r,i){switch(t.readyState){case 4:if(200===t.status)this._requestLicenseFailureCount=0,u.b.log("License request succeeded"),i(t.response);else{if(u.b.error("License Request XHR failed ("+e+"). Status: "+t.status+" ("+t.statusText+")"),++this._requestLicenseFailureCount<=3){var a=3-this._requestLicenseFailureCount+1;return u.b.warn("Retrying license request, "+a+" attempts left"),void this._requestLicense(r,i)}this.hls.trigger(s.a.ERROR,{type:l.b.KEY_SYSTEM_ERROR,details:l.a.KEY_SYSTEM_LICENSE_REQUEST_FAILED,fatal:!0})}}},e.prototype._generateLicenseRequestChallenge=function(t,e){var r=void 0;return t.mediaKeySystemDomain===c.PLAYREADY?u.b.error("PlayReady is not supported (yet)"):t.mediaKeySystemDomain===c.WIDEVINE?r=e:u.b.error("Unsupported key-system:",t.mediaKeySystemDomain),r},e.prototype._requestLicense=function(t,e){u.b.log("Requesting content license for key-system");var r=this._mediaKeysList[0];if(!r)return u.b.error("Fatal error: Media is encrypted but no key-system access has been obtained yet"),void this.hls.trigger(s.a.ERROR,{type:l.b.KEY_SYSTEM_ERROR,details:l.a.KEY_SYSTEM_NO_ACCESS,fatal:!0});var i=this.getLicenseServerUrl(r.mediaKeySystemDomain),a=this._createLicenseXhr(i,t,e);u.b.log("Sending license request to URL: "+i),a.send(this._generateLicenseRequestChallenge(r,t))},e.prototype.onMediaAttached=function(t){var e=this;if(this._emeEnabled){var r=t.media;this._media=r,r.addEventListener("encrypted",function(t){e._onMediaEncrypted(t.initDataType,t.initData)})}},e.prototype.onManifestParsed=function(t){if(this._emeEnabled){var e=t.levels.map(function(t){return t.audioCodec}),r=t.levels.map(function(t){return t.videoCodec});this._attemptKeySystemAccess(c.WIDEVINE,e,r)}},d(e,[{key:"requestMediaKeySystemAccess",get:function(){if(!this._requestMediaKeySystemAccess)throw new Error("No requestMediaKeySystemAccess function configured");return this._requestMediaKeySystemAccess}}]),e}(o.a);e.a=p},function(t,e,r){"use strict";r.d(e,"a",function(){return i});var i=function(){return"undefined"!=typeof window&&window.navigator&&window.navigator.requestMediaKeySystemAccess?window.navigator.requestMediaKeySystemAccess.bind(window.navigator):null}()},function(t,e){/*! http://mths.be/endswith v0.2.0 by @mathias */
String.prototype.endsWith||function(){"use strict";var t=function(){try{var t={},e=Object.defineProperty,r=e(t,t,t)&&e}catch(t){}return r}(),e={}.toString,r=function(t){if(null==this)throw TypeError();var r=String(this);if(t&&"[object RegExp]"==e.call(t))throw TypeError();var i=r.length,a=String(t),n=a.length,o=i;if(arguments.length>1){var s=arguments[1];void 0!==s&&(o=s?Number(s):0)!=o&&(o=0)}var l=Math.min(Math.max(o,0),i),u=l-n;if(u<0)return!1;for(var d=-1;++d<n;)if(r.charCodeAt(u+d)!=a.charCodeAt(d))return!1;return!0};t?t(String.prototype,"endsWith",{value:r,configurable:!0,writable:!0}):String.prototype.endsWith=r}()}]).default});
//# sourceMappingURL=hls.min.js.map